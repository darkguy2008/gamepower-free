<html>
<head>
    <style>
    * {
	    margin: 0;
	    padding: 0;
	    font-family: Tahoma;
	    font-size: 10pt;
    }
    h1 { font-size: 16pt; }
    h2 { font-size: 12pt; }
    hr { margin: .5em 0;}
    body {
	    padding: 1em;
    }
    pre {
	    font-family: Consolas, 'Courier New';
        margin: 1em;
                border: 1px solid #000;
	    padding: .5em;
                background: #eee;
    }
    </style>
</head>
<body>
<hr/>
<h1>Ayuda electr&#243;nica de DIV Games Studio 2.0 (Castellano) <hr/></h1>
<br />
<h2 id="3">Indice general</h2><br/><br/>
<a href="#2000">Introducci&#243;n a DIV Games Studio 2.0</a><br/>
<br/><br/>
<strong>Ayuda sobre el lenguaje de programaci&#243;n</strong><br/><br/>
<a href="#4">Glosario de t&#233;rminos</a><br/>
<a href="#1000">Sintaxis de un programa</a><br/>
<a href="#1017">Relaci&#243;n de sentencias</a><br/>
<a href="#1032">Lista de funciones</a><br/>
<br/><br/>
<a href="#1202">Constantes predefinidas</a><br/>
<a href="#1200">Datos globales predefinidos</a><br/>
<a href="#1201">Datos locales predefinidos</a><br/>
<br/><br/>
<a href="#1035">Expresiones aritm&#233;ticas</a><br/>
<a href="#1037">Condiciones l&#243;gicas</a><br/>
<br/><br/>
<a href="#1176">C&#243;digos del teclado</a><br/>
<br/><br/>
<a href="#2001">Novedades del lenguaje</a><br/><br/>
<strong>Ayuda sobre los comandos de teclado</strong><br/><br/>
<a href="#1291">Comandos en el entorno gr&#225;fico</a><br/>
<a href="#1292">Comandos comunes en los juegos</a><br/>
<a href="#1293">Comandos en el trazador de programas</a><br/>
<a href="#1294">Comandos en el editor de programas</a><br/>
<a href="#1295">Comandos en el editor gr&#225;fico</a><br/>
<br/><br/>
<hr/>
<h1>Glosario de t&#233;rminos <hr/></h1>
<br/><br/>
<h2 id="4">Glosario de t&#233;rminos</h2><br/><br/>
<a href="#1046">!=</a><br/>
<a href="#1045">!</a><br/>
<a href="#1047">&quot;</a><br/>
<a href="#1049">%=</a><br/>
<a href="#1048">%</a><br/>
<a href="#1051">&amp;&amp;</a><br/>
<a href="#1052">&amp;=</a><br/>
<a href="#1050">&amp;</a><br/>
<a href="#1047">&#39;</a><br/>
<a href="#1053">(</a><br/>
<a href="#1053">)</a><br/>
<a href="#1002">*/</a><br/>
<a href="#1055">*=</a><br/>
<a href="#1054">*</a><br/>
<a href="#1057">++</a><br/>
<a href="#1058">+=</a><br/>
<a href="#1056">+</a><br/>
<a href="#1059">,</a><br/>
<a href="#1061">--</a><br/>
<a href="#1062">-=</a><br/>
<a href="#1063">-&gt;</a><br/>
<a href="#1060">-</a><br/>
<a href="#1064">..</a><br/>
<a href="#1063">.</a><br/>
<a href="#1002">/*</a><br/>
<a href="#1002">//</a><br/>
<a href="#1066">/=</a><br/>
<a href="#1065">/</a><br/>
<a href="#1067">:</a><br/>
<a href="#1068">;</a><br/>
<a href="#1071">&lt;&lt;=</a><br/>
<a href="#1070">&lt;&lt;</a><br/>
<a href="#1072">&lt;=</a><br/>
<a href="#1046">&lt;&gt;</a><br/>
<a href="#1069">&lt;</a><br/>
<a href="#1072">=&lt;</a><br/>
<a href="#1074">==</a><br/>
<a href="#1075">=&gt;</a><br/>
<a href="#1073">=</a><br/>
<a href="#1075">&gt;=</a><br/>
<a href="#1078">&gt;&gt;=</a><br/>
<a href="#1077">&gt;&gt;</a><br/>
<a href="#1076">&gt;</a><br/>
<a href="#1079">[</a><br/>
<a href="#1079">]</a><br/>
<a href="#1081">^=</a><br/>
<a href="#1082">^^</a><br/>
<a href="#1079">^</a><br/>
<a href="#1084">|=</a><br/>
<a href="#1083">||</a><br/>
<a href="#1083">|</a><br/>
<a href="#1176">_a, _b, _c, ...</a> <a href="#1400">_case_sensitive</a><br/>
<a href="#1400">_extended_conditions</a><br/>
<a href="#1400">_free_sintax</a><br/>
<a href="#231">_hidden</a><br/>
<a href="#1400">_ignore_errors</a><br/>
<a href="#1400">_max_process</a><br/>
<a href="#1400">_no_check</a><br/>
<a href="#1400">_no_id_check</a><br/>
<a href="#1400">_no_null_check</a><br/>
<a href="#1400">_no_optimization</a><br/>
<a href="#1400">_no_range_check</a><br/>
<a href="#1400">_no_strfix</a><br/>
<a href="#231">_normal</a><br/>
<a href="#1400">_simple_conditions</a><br/>
<a href="#231">_subdir</a><br/>
<a href="#231">_system</a><br/>
<a href="#231">_volid</a><br/>
<a href="#100">abs()</a><br/>
<a href="#246">acos()</a><br/>
<a href="#101">advance()</a><br/>
<a href="#250">all_drawing</a><br/>
<a href="#1162">all_sound</a><br/>
<a href="#1161">all_text</a><br/>
<a href="#1051">and</a><br/>
<a href="#1129">angle</a><br/>
<a href="#1409">argc</a><br/>
<a href="#1409">argv[]</a><br/>
<a href="#1109">ascii</a><br/>
<a href="#245">asin()</a><br/>
<a href="#247">atan()</a><br/>
<a href="#248">atan2()</a><br/>
<a href="#1086">begin</a><br/>
<a href="#1120">bigbro</a><br/>
<a href="#1026">break</a><br/>
<a href="#1404">byte</a><br/>
<a href="#1175">c_0 ... c_9</a><br/>
<a href="#1169">c_m7</a><br/>
<a href="#1412">c_m8</a><br/>
<a href="#1167">c_screen</a><br/>
<a href="#1168">c_scroll</a><br/>
<a href="#254">calculate()</a><br/>
<a href="#1087">case</a><br/>
<a href="#256">change_channel()</a><br/>
<a href="#102">change_sound()</a><br/>
<a href="#1416">channel[]</a><br/>
<a href="#184">char()</a><br/>
<a href="#235">chdir()</a><br/>
<a href="#103">clear_screen()</a><br/>
<a href="#1030">clone</a><br/>
<a href="#1134">cnumber</a><br/>
<a href="#104">collision()</a><br/>
<a href="#1400">compiler_options</a><br/>
<a href="#1171">complete_dump</a><br/>
<a href="#1174">complete_restore</a><br/>
<a href="#262">compress_file()</a><br/>
<a href="#1004">const</a><br/>
<a href="#1027">continue</a><br/>
<a href="#105">convert_palette()</a><br/>
<a href="#243">cos()</a><br/>
<a href="#1122">ctype</a><br/>
<a href="#1031">debug</a><br/>
<a href="#261">decode_file()</a><br/>
<a href="#1088">default</a><br/>
<a href="#106">define_region()</a><br/>
<a href="#250">delete_draw()</a><br/>
<a href="#107">delete_text()</a><br/>
<a href="#1413">dirinfo (struct)</a><br/>
<a href="#238">disk_free()</a><br/>
<a href="#249">draw()</a><br/>
<a href="#1418">draw_z</a><br/>
<a href="#1114">dump_type</a><br/>
<a href="#1089">dup</a><br/>
<a href="#1090">else</a><br/>
<a href="#259">encode()</a><br/>
<a href="#260">encode_file()</a><br/>
<a href="#108">end_fli()</a><br/>
<a href="#1091">end</a><br/>
<a href="#109">exit()</a><br/>
<a href="#110">fade()</a><br/>
<a href="#111">fade_off()</a><br/>
<a href="#112">fade_on()</a><br/>
<a href="#1107">fading</a><br/>
<a href="#1152">false</a><br/>
<a href="#1104">fast_mixer</a><br/>
<a href="#1117">father</a><br/>
<a href="#224">fclose()</a><br/>
<a href="#113">fget_angle()</a><br/>
<a href="#114">fget_dist()</a><br/>
<a href="#1414">fileinfo (struct)</a><br/>
<a href="#229">filelength()</a><br/>
<a href="#1131">file</a><br/>
<a href="#264">find_color()</a><br/>
<a href="#1127">flags</a><br/>
<a href="#230">flush()</a><br/>
<a href="#223">fopen()</a><br/>
<a href="#266">force_pal()</a><br/>
<a href="#1025">for</a><br/>
<a href="#1426">fps</a><br/>
<a href="#115">frame_fli()</a><br/>
<a href="#1029">frame</a><br/>
<a href="#225">fread()</a><br/>
<a href="#258">free()</a><br/>
<a href="#1043">from</a><br/>
<a href="#227">fseek()</a><br/>
<a href="#228">ftell()</a><br/>
<a href="#1408">function</a><br/>
<a href="#226">fwrite()</a><br/>
<a href="#1164">g_height</a><br/>
<a href="#1163">g_wide</a><br/>
<a href="#1165">g_x_center</a><br/>
<a href="#1166">g_y_center</a><br/>
<a href="#116">get_angle()</a><br/>
<a href="#231">get_dirinfo()</a><br/>
<a href="#117">get_dist()</a><br/>
<a href="#118">get_distx()</a><br/>
<a href="#119">get_disty()</a><br/>
<a href="#232">get_fileinfo()</a><br/>
<a href="#120">get_id()</a><br/>
<a href="#121">get_joy_button()</a><br/>
<a href="#122">get_joy_position()</a><br/>
<a href="#123">get_pixel()</a><br/>
<a href="#124">get_point()</a><br/>
<a href="#195">get_point_m8()</a><br/>
<a href="#125">get_real_point()</a><br/>
<a href="#193">get_sector_height()</a><br/>
<a href="#198">get_sector_texture()</a><br/>
<a href="#220">get_song_line()</a><br/>
<a href="#219">get_song_pos()</a><br/>
<a href="#200">get_wall_texture()</a><br/>
<a href="#233">getdrive()</a><br/>
<a href="#1006">global</a><br/>
<a href="#191">go_to_flag()</a><br/>
<a href="#126">graphic_info()</a><br/>
<a href="#1126">graph</a><br/>
<a href="#1133">height</a><br/>
<a href="#1092">id</a><br/>
<a href="#1020">if</a><br/>
<a href="#240">ignore_error()</a><br/>
<a href="#1014">import</a><br/>
<a href="#1402">int</a><br/>
<a href="#127">is_playing_cd()</a><br/>
<a href="#222">is_playing_song()</a><br/>
<a href="#221">is_playing_sound()</a><br/>
<a href="#255">itoa()</a><br/>
<a href="#1103">joy (struct)</a><br/>
<a href="#1111">joy_filter</a><br/>
<a href="#1112">joy_status</a><br/>
<a href="#128">key()</a><br/>
<a href="#129">let_me_alone()</a><br/>
<a href="#130">load()</a><br/>
<a href="#131">load_fnt()</a><br/>
<a href="#132">load_fpg()</a><br/>
<a href="#174">load_map()</a><br/>
<a href="#133">load_pal()</a><br/>
<a href="#134">load_pcm()</a><br/>
<a href="#174">load_pcx()</a><br/>
<a href="#265">load_screen()</a><br/>
<a href="#214">load_song()</a><br/>
<a href="#134">load_wav()</a><br/>
<a href="#189">load_wld()</a><br/>
<a href="#1007">local</a><br/>
<a href="#1024">loop</a><br/>
<a href="#210">lower()</a><br/>
<a href="#1150">m320x200 ... m1024x768</a><br/>
<a href="#1102">m7 (struct)</a><br/>
<a href="#1411">m8 (struct)</a><br/>
<a href="#1424">m8_nextsector</a><br/>
<a href="#1423">m8_sector</a><br/>
<a href="#1425">m8_step</a><br/>
<a href="#1422">m8_wall</a><br/>
<a href="#257">malloc()</a><br/>
<a href="#135">map_block_copy()</a><br/>
<a href="#136">map_get_pixel()</a><br/>
<a href="#137">map_put()</a><br/>
<a href="#138">map_put_pixel()</a><br/>
<a href="#139">map_xput()</a><br/>
<a href="#1178">max_int</a><br/>
<a href="#1115">max_process_time</a><br/>
<a href="#239">memory_free()</a><br/>
<a href="#1177">min_int</a><br/>
<a href="#236">mkdir()</a><br/>
<a href="#1048">mod</a><br/>
<a href="#1100">mouse (struct)</a><br/>
<a href="#251">move_draw()</a><br/>
<a href="#140">move_scroll()</a><br/>
<a href="#141">move_text()</a><br/>
<a href="#142">near_angle()</a><br/>
<a href="#1410">net (struct)</a><br/>
<a href="#181">net_get_games()</a><br/>
<a href="#180">net_join_game()</a><br/>
<a href="#188">new_map()</a><br/>
<a href="#1172">no_restore</a><br/>
<a href="#1045">not</a><br/>
<a href="#1419">num_video_modes</a><br/>
<a href="#1085">offset</a><br/>
<a href="#1083">or</a><br/>
<a href="#143">out_region()</a><br/>
<a href="#1170">partial_dump</a><br/>
<a href="#1173">partial_restore</a><br/>
<a href="#185">path_find()</a><br/>
<a href="#187">path_free()</a><br/>
<a href="#186">path_line()</a><br/>
<a href="#1179">pi</a><br/>
<a href="#144">play_cd()</a><br/>
<a href="#1405">pointer</a><br/>
<a href="#145">pow()</a><br/>
<a href="#1121">priority</a><br/>
<a href="#1008">private</a><br/>
<a href="#1016">process</a><br/>
<a href="#1003">program</a><br/>
<a href="#146">put()</a><br/>
<a href="#147">put_pixel()</a><br/>
<a href="#148">put_screen()</a><br/>
<a href="#213">qsort()</a><br/>
<a href="#1104">quality_mixer</a><br/>
<a href="#1421">radius</a><br/>
<a href="#149">rand()</a><br/>
<a href="#150">rand_seed()</a><br/>
<a href="#152">refresh_scroll()</a><br/>
<a href="#1130">region</a><br/>
<a href="#237">remove()</a><br/>
<a href="#1023">repeat</a><br/>
<a href="#1116">reserved</a><br/>
<a href="#153">reset_fli()</a><br/>
<a href="#175">reset_sound()</a><br/>
<a href="#1135">resolution</a><br/>
<a href="#1113">restore_type</a><br/>
<a href="#1028">return</a><br/>
<a href="#154">roll_palette()</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#155">save()</a><br/>
<a href="#241">save_map()</a><br/>
<a href="#241">save_pcx()</a><br/>
<a href="#1110">scan_code</a><br/>
<a href="#212">screen_copy()</a><br/>
<a href="#1101">scroll (struct)</a><br/>
<a href="#227">seek_cur</a><br/>
<a href="#227">seek_end</a><br/>
<a href="#227">seek_set</a><br/>
<a href="#179">set_color()</a><br/>
<a href="#201">set_env_color()</a><br/>
<a href="#196">set_fog()</a><br/>
<a href="#156">set_fps()</a><br/>
<a href="#157">set_mode()</a><br/>
<a href="#194">set_point_m8()</a><br/>
<a href="#192">set_sector_height()</a><br/>
<a href="#197">set_sector_texture()</a><br/>
<a href="#218">set_song_pos()</a><br/>
<a href="#178">set_volume()</a><br/>
<a href="#199">set_wall_texture()</a><br/>
<a href="#234">setdrive()</a><br/>
<a href="#1104">setup (struct)</a><br/>
<a href="#1093">setup_program</a><br/>
<a href="#1108">shift_status</a><br/>
<a href="#158">signal()</a><br/>
<a href="#242">sin()</a><br/>
<a href="#1094">sizeof()</a><br/>
<a href="#1128">size</a><br/>
<a href="#1119">smallbro</a><br/>
<a href="#216">song()</a><br/>
<a href="#1118">son</a><br/>
<a href="#159">sound()</a><br/>
<a href="#1104">sound_bits_16</a><br/>
<a href="#1104">sound_bits_8</a><br/>
<a href="#160">sqrt()</a><br/>
<a href="#161">start_fli()</a><br/>
<a href="#162">start_mode7()</a><br/>
<a href="#190">start_mode8()</a><br/>
<a href="#163">start_scroll()</a><br/>
<a href="#1095">step</a><br/>
<a href="#164">stop_cd()</a><br/>
<a href="#165">stop_mode7()</a><br/>
<a href="#182">stop_mode8()</a><br/>
<a href="#166">stop_scroll()</a><br/>
<a href="#217">stop_song()</a><br/>
<a href="#167">stop_sound()</a><br/>
<a href="#203">strcat()</a><br/>
<a href="#206">strchr()</a><br/>
<a href="#205">strcmp()</a><br/>
<a href="#202">strcpy()</a><br/>
<a href="#211">strdel()</a><br/>
<a href="#1406">string</a><br/>
<a href="#204">strlen()</a><br/>
<a href="#208">strset()</a><br/>
<a href="#207">strstr()</a><br/>
<a href="#1012">struct</a><br/>
<a href="#1021">switch</a><br/>
<a href="#168">system()</a><br/>
<a href="#244">tan()</a><br/>
<a href="#1106">text_z</a><br/>
<a href="#1105">timer[]</a><br/>
<a href="#1096">to</a><br/>
<a href="#1151">true</a><br/>
<a href="#1042">type</a><br/>
<a href="#263">uncompress_file()</a><br/>
<a href="#1420">unit_size</a><br/>
<a href="#177">unload_fnt()</a><br/>
<a href="#169">unload_fpg()</a><br/>
<a href="#176">unload_map()</a><br/>
<a href="#170">unload_pcm()</a><br/>
<a href="#176">unload_pcx()</a><br/>
<a href="#215">unload_song()</a><br/>
<a href="#170">unload_wav()</a><br/>
<a href="#1097">until</a><br/>
<a href="#209">upper()</a><br/>
<a href="#1415">video_modes (struct)</a><br/>
<a href="#1417">vsync</a><br/>
<a href="#1022">while</a><br/>
<a href="#1403">word</a><br/>
<a href="#171">write()</a><br/>
<a href="#253">write_in_map()</a><br/>
<a href="#172">write_int()</a><br/>
<a href="#183">xadvance()</a><br/>
<a href="#1132">xgraph</a><br/>
<a href="#1082">xor</a><br/>
<a href="#173">xput()</a><br/>
<a href="#1123">x</a><br/>
<a href="#1124">y</a><br/>
<a href="#1125">z</a><br/>
<br/><br/>
<hr/>
<h1>Funciones <hr/></h1>
<br/><br/>
<h2 id="100">abs()</h2><br/><br/>
<strong>abs(</strong>&lt;expresi&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>valor absoluto</strong> de la expresi&#243;n.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula el valor absoluto de la expresi&#243;n pasada como par&#225;metro, es decir, si el resultado de la expresi&#243;n es negativo lo cambiar&#225; de signo, si es positivo lo dejar&#225; igual.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_abs;

GLOBAL
    INT valores[15];
    INT n;

BEGIN
    FROM n=0 TO 15;
        valores[n]=rand(-1000, 1000);
        write_int(0, 0, n*10,0, offset valores[n]);
    END
    write(0, 0, 192, 0, &quot;Pulse [ESPACIO] para ejecutar la funci&#243;n abs()&quot;);
    LOOP
        IF (key(_space))
            FROM n=0 TO 15;

                valores[n] = abs(valores[n]); // Hallamos el valor absoluto

            END
        END
        FRAME;
    END
END
</pre>
Este programa imprimir&#225; en pantalla una lista de valores que pueden ser positivos o negativos, cuando se pulse la barra espaciadora le aplicar&#225; la funci&#243;n <strong>abs()</strong> a todos estos valores, dej&#225;ndolos todos positivos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="101">advance()</h2><br/><br/>
<strong>advance(</strong>&lt;distancia&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Avanza el proceso en su &#225;ngulo (el que indique la variable local <a href="#1129">angle</a>) tantos puntos como indique la <strong>expresi&#243;n</strong> (distancia) pasada como par&#225;metro.<br/><br/>
Para avanzar en un &#225;ngulo distinto al contenido en esta variable se puede utilizar la funci&#243;n <a href="#183">xadvance()</a>.<br/><br/>
La distancia puede ser tambi&#233;n un n&#250;mero negativo, con lo cual el gr&#225;fico del proceso avanzar&#225; (sus coordenadas <a href="#1123">x</a> e <a href="#1124">y</a>) en la direcci&#243;n contraria a su &#225;ngulo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_advance;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    graph=101;
    x=160;
    y=100;
    write(0, 0, 0, 0, &quot;Use los cursores para cambiar la direcci&#243;n.&quot;);
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END

        advance(2); // Avanzamos dos puntos el proceso

        FRAME;
    END
END
</pre>
Este ejemplo dibujar&#225; un tri&#225;ngulo en pantalla que avanzar&#225; en la direcci&#243;n especificada en la variable local predefinida <a href="#1129">angle</a> utilizando esta funci&#243;n.<br/><br/>
Se recuerda que el &#225;ngulo se especifica en mil&#233;simas de grado.<br/><br/>
Se podr&#225; modificar la variable <a href="#1129">angle</a> usando las teclas de los cursores (sumando y restando 10000, es decir, 10 grados).<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n equivale siempre a las dos siguientes sentencias:<br/><br/>
<strong>x+=get_distx(angle,</strong> &lt;distancia&gt;<strong>);</strong><br/>
<strong>y+=get_disty(angle,</strong> &lt;distancia&gt;<strong>);</strong><br/>
<br/><br/>
Es decir, esta funci&#243;n &#250;nicamente modifica las coordenadas del proceso. Cabe la posibilidad de utilizar las dos sentencias anteriores cuando se quiera que el proceso avance en un &#225;ngulo diferente al que indica su variable <a href="#1129">angle</a>; esto resultar&#225; &#250;til cuando se quiera que el gr&#225;fico del proceso avance en una direcci&#243;n sin rotarse.<br/><br/>
Por ejemplo, para conseguir que un proceso avance 8 puntos en una direcci&#243;n (que se podr&#237;a tener en una variable privada como <strong>angle2</strong>) pero rotado hacia otra direcci&#243;n, (la indicada en <a href="#1129">angle</a>), se utilizar&#237;an las sentencias:<br/><br/>
<strong>x+=get_distx(angle2, 8);</strong><br/>
<strong>y+=get_disty(angle2, 8);</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#183">xadvance()</a> - <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#118">get_distx()</a> - <a href="#119">get_disty()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="102">change_sound()</h2><br/><br/>
<strong>change_sound(</strong>&lt;canal&gt;<strong>,</strong> &lt;volumen&gt;<strong>,</strong> &lt;frecuencia&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Para utilizar esta funci&#243;n es imprescindible tener una tarjeta de sonido instalada en el ordenador compatible 100% con las tarjetas de la familia <strong>Sound Blaster</strong> (tm) o <strong>Gravis Ultrasound</strong> (tm).<br/><br/>
Esta funci&#243;n tiene sentido utilizarla s&#243;lo tras la funci&#243;n <a href="#159">sound()</a> que es la utilizada para emitir sonidos.<br/><br/>
<strong>Change_sound()</strong> modifica un sonido que est&#225; sonando por uno de los <strong>canales</strong>, estableciendo nuevamente su <strong>volumen</strong> y su <strong>frecuencia</strong>.<br/><br/>
El <strong>canal</strong> es el <strong>c&#243;digo de canal</strong> que devuelve la funci&#243;n <a href="#159">sound()</a> cuando es llamada; pueden sonar hasta 16 canales a la vez, con el mismo sonido o con diferentes sonidos, por lo tanto, cada vez que se emite un sonido se har&#225;, posiblemente, por un canal diferente.<br/><br/>
Cada <strong>canal</strong> tiene establecidos en todo momento su nivel de volumen y de frecuencia.<br/><br/>
El <strong>volumen</strong> es un valor entre <strong>0</strong> (volumen m&#237;nimo) y <strong>512</strong> (volumen m&#225;ximo) que determina la potencia con la que se escuchar&#225; el sonido de dicho canal.<br/><br/>
La <strong>frecuencia</strong> es un valor que afecta a la velocidad a la que se oye el sonido por el canal, es decir, controla lo grave o agudo que se emite el sonido. Este valor oscila entre <strong>0</strong> (grave) y <strong>512</strong> (agudo).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_change_sound;

PRIVATE
    frecuencia=256;     // Valor medio (0..512)
    volumen=256;        // Valor medio (0..512)

    id_sonido;
    canal;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);

    id_sonido = load_pcm(&quot;help\help.pcm&quot;, 1);
    canal = sound(id_sonido, volumen, frecuencia);

    write(0, 0, 0, 0, &quot;Presione derecha o izquierda para cambiar la frecuencia.&quot;);
    write_int(0, 0, 10, 0, offset frecuencia);
    write(0, 0, 20, 0, &quot;Presione arriba o abajo para cambiar el volumen.&quot;);
    write_int(0, 0, 30, 0, offset volumen);
    LOOP

        // Cambia el sonido
        change_sound(canal, volumen, frecuencia);

        IF (key(_right)) frecuencia++; END
        IF (key(_left)) frecuencia--; END
        IF (key(_up)) volumen++; END
        IF (key(_down)) volumen--; END
        FRAME;
    END

END
</pre>
En el ejemplo se carga y se emite un sonido (contenido en el archivo <strong>help.pcm</strong>). Dentro del bucle principal del programa se cambia la frecuencia y el volumen de este sonido con la funci&#243;n <strong>change_sound()</strong>; para modificar estos valores se utilizan las teclas de los cursores.<br/><br/>
<hr/>
Ver: <a href="#134">load_pcm/wav()</a> - <a href="#159">sound()</a> - <a href="#170">unload_pcm/wav()</a> - <a href="#1104">STRUCT setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="103">clear_screen()</h2><br/><br/>
<strong>clear_screen()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Borra el fondo de la pantalla, es decir, los gr&#225;ficos que se hubieran puesto en ella con las funciones <a href="#146">put()</a>, <a href="#173">xput()</a>, <a href="#147">put_pixel()</a> y <a href="#148">put_screen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_clear_screen;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write(0, 0, 0, 0, &quot;Presione [ESPACIO] para que se borre la pantalla.&quot;);
    write(0, 0, 10, 0, &quot;Presione [ENTER] para volver a visualizarla.&quot;);
    graph=100;
    x=160;
    y=100;
    LOOP
        IF (key (_space))

            clear_screen(); // Borra el gr&#225;fico de fondo de la pantalla

        END
        IF (key (_enter)) put_screen(0, 1); END
        FRAME;
    END
END
</pre>
En el ejemplo se visualiza una pantalla de fondo con la funci&#243;n <a href="#148">put_screen()</a>. Al pulsar la barra espaciadora, se borra dicha pantalla.<br/><br/>
Pulsando la tecla <strong>Enter</strong>, se vuelve a visualizar la pantalla de fondo.<br/><br/>
Se puede observar c&#243;mo el gr&#225;fico del proceso (una bola que aparece en el centro) no desaparece al utilizar la funci&#243;n <strong>clear_screen()</strong>, ya que &#233;sta &#250;nicamente borra el fondo de pantalla.<br/><br/>
<hr/>
Ver: <a href="#146">put()</a> - <a href="#173">xput()</a> - <a href="#147">put_pixel()</a> - <a href="#148">put_screen()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="104">collision()</h2><br/><br/>
<strong>collision(</strong>&lt;tipo de proceso&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <a href="#1039">c&#243;digo identificador</a> de un proceso o <strong>0</strong>.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
&#201;sta es la funci&#243;n del lenguaje <strong>para detectar choques</strong> entre gr&#225;ficos.<br/><br/>
Comprueba si el proceso actual (el que ejecut&#243; esta funci&#243;n) colisiona con uno del tipo indicado como par&#225;metro. Es decir, comprueba si los gr&#225;ficos de ambos procesos est&#225;n, al menos, parcialmente superpuestos.<br/><br/>
En caso de producirse una colisi&#243;n devolver&#225; el <a href="#1039">c&#243;digo identificador</a> del proceso con el que est&#225; chocando el proceso actual. En caso contrario la funci&#243;n devolver&#225; siempre <strong>0</strong>.<br/><br/>
Si el proceso actual colisiona con varios procesos del tipo que se ha especificado, la funci&#243;n <strong>collision()</strong> devolver&#225; el resto de los identificadores en las sucesivas llamadas que se realicen a la misma.<br/><br/>
Para obtener, de esta forma, todos los <a href="#1039">c&#243;digos identificadores</a> de los procesos que colisionan con el actual no se debe utilizar la sentencia <a href="#1029">FRAME</a> entre dos llamadas consecutivas a la sentencia <strong>collision()</strong>. En el caso de ejecutar un proceso una sentencia <a href="#1029">FRAME</a>, esta funci&#243;n volver&#225; a retornar todos los <a href="#1039">c&#243;digos identificadores</a> de procesos colisionantes desde el primero.<br/><br/>
Algo similar sucede si se ejecuta una llamada a la funci&#243;n especificando un tipo de proceso diferente; si tras esto se vuelven a detectar las colisiones con el tipo anterior, esta funci&#243;n tambi&#233;n volver&#225; a retornar todos los c&#243;digos desde el primero.<br/><br/>
Cuando se quieren obtener los <a href="#1039">c&#243;digos identificadores</a> de los procesos de un tipo determinado aunque no se produzca ninguna colisi&#243;n con ellos, se debe llamar a la funci&#243;n <a href="#120">get_id()</a>.<br/><br/>
Si lo que se pretende es comprobar la cercan&#237;a entre dos procesos sin que necesariamente colisionen sus gr&#225;ficos, entonces se deber&#225; emplear la funci&#243;n <a href="#117">get_dist()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_collision;

PRIVATE
    id2;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;
    proceso_m&#243;vil(80, 50, 101);
    LOOP
        delete_text(all_text);
        write(0, 160, 0, 1, &quot;Use los cursores para mover el tri&#225;ngulo&quot;);

        id2 = collision(TYPE proceso_m&#243;vil); // Se detecta la colisi&#243;n

        IF (id2&lt;&gt;0)
            write(0, 160, 200, 7, &quot;&#161; DETECTADA COLISION !&quot;);
        END
        FRAME;
    END
END

PROCESS proceso_m&#243;vil(x, y, graph);

BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
</pre>
En este ejemplo se visualiza una pelota en el centro de la pantalla como gr&#225;fico del programa principal. Luego se crea un proceso de nombre <strong>proceso_m&#243;vil</strong> con el dibujo de un tri&#225;ngulo controlable con las teclas de los cursores.<br/><br/>
El programa principal llamar&#225; a la funci&#243;n <strong>collision()</strong> para comprobar si su gr&#225;fico (el c&#237;rculo) colisiona con el gr&#225;fico del proceso de tipo <strong>proceso_m&#243;vil</strong> (el tri&#225;ngulo). El resultado de la funci&#243;n se guarda en la variable privada <strong>id2</strong> del programa principal; este valor ser&#225; <strong>0</strong> cuando no se produzca la colisi&#243;n y el <a href="#1039">c&#243;digo identificador</a> de <strong>proceso_m&#243;vil</strong> cuando s&#237;.<br/><br/>
Los c&#243;digos identificadores de los procesos son siempre n&#250;meros impares, que en el lenguaje se eval&#250;an como condiciones verdaderas (y los n&#250;meros pares se corresponden con condiciones que resultan falsas), luego en el programa anterior se podr&#237;a haber cambiado la sentencia:<br/><br/>
<strong>IF (id2&lt;&gt;0)</strong> ... <strong>END</strong><br/><br/>
Por la siguiente:<br/><br/>
<strong>IF (id2)</strong> ... <strong>END</strong><br/><br/>
Para m&#225;s informaci&#243;n al respecto ver: <a href="#1037">Definici&#243;n de una condici&#243;n.</a><br/><br/>
<hr/>
<br/><br/>
Cuando en el programa se est&#233; visualizando el puntero del rat&#243;n (asignando el c&#243;digo del gr&#225;fico correspondiente en la <a href="#1100">estructura mouse</a>), es posible ver si &#233;ste choca con el proceso actual utilizando esta funci&#243;n, por ejemplo, de la siguiente forma:<br/><br/>
<strong>IF (collision(TYPE mouse))</strong><br/>
// El proceso colisiona con el puntero del rat&#243;n<br/>
<strong>END</strong><br/>
<br/><br/>
Al detectarse la colisi&#243;n con el puntero del rat&#243;n no se har&#225; con la totalidad del gr&#225;fico utilizado como puntero, sino &#250;nicamente con el <a href="#1136">punto de control</a> principal (el n&#250;mero 0) del mismo, denominado usualmente como el &quot;punto caliente&quot; (<strong>hotspot</strong>) del rat&#243;n.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n sirve para detectar colisiones entre gr&#225;ficos de pantalla o de una ventana de scroll.<br/><br/>
No es posible utilizar esta funci&#243;n para detectar colisiones con procesos que no tengan gr&#225;fico (un c&#243;digo v&#225;lido asignado a su variable <a href="#1126">graph</a>) o entre gr&#225;ficos de una ventana de modo 7 o modo 8 (con su variable <a href="#1122">ctype</a> asignada al valor <a href="#1169">c_m7</a> o <a href="#1412">c_m8</a>).<br/><br/>
Es, por tanto, <strong>imprescindible</strong> que tanto el proceso actual como el del tipo que se especifica tengan definido un gr&#225;fico.<br/><br/>
Para detectar colisiones entre gr&#225;ficos de una ventana de modo 7 o modo 8 se debe utilizar la funci&#243;n <a href="#117">get_dist()</a> para detectar de esta forma cu&#225;ndo la distancia entre los dos procesos es menor a la que se estipule como <strong>distancia de choque</strong>.<br/><br/>
<hr/>
Ver: <a href="#120">get_id()</a> - <a href="#117">get_dist()</a> - <a href="#1042">Tipos de procesos</a> - <a href="#1038">Formas de obtener el c&#243;digo identificador</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="105">convert_palette()</h2><br/><br/>
<strong>convert_palette(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;OFFSET nueva_paleta&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Transforma el mapa de color del <strong>&lt;gr&#225;fico&gt;</strong> del <strong>&lt;fichero&gt;</strong> indicado.<br/><br/>
El <strong>&lt;</strong><a href="#1085">offset</a><strong> nueva_paleta&gt;</strong> es la direcci&#243;n dentro de la memoria del ordenador de una tabla de 256 valores donde se indicar&#225; el nuevo orden de los colores del gr&#225;fico.<br/><br/>
<strong>Nota:</strong> Esta tabla debe ser de datos simples (de tipo <a href="#1402">INT</a>, enteros de 32 bit con signo).<br/><br/>
Si la tabla con la nueva paleta fuera como se muestra a continuaci&#243;n:<br/><br/>
nueva_paleta[255]=0, 1, 2, 3, 4, ... , 254, 255;<br/><br/>
el gr&#225;fico no sufrir&#237;a ninguna transformaci&#243;n. Si, por ejemplo, en la posici&#243;n 3 de la tabla anterior (nueva_paleta[3]) se pusiera un 16 (en lugar de un 3), al llamar a esta funci&#243;n con el <a href="#1085">offset</a> de dicha tabla, se sustituir&#237;a en el gr&#225;fico el color 3 por el color 16.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
Si un proceso quisiera cambiar los colores de su propio gr&#225;fico, se deber&#237;a construir igualmente una tabla con el nuevo orden de los colores y, despu&#233;s, llamar a la funci&#243;n con los par&#225;metros:<br/><br/>
<strong>convert_palette(file, graph, </strong>&lt;OFFSET nueva_paleta&gt;<strong>)</strong><br/><br/>
A continuaci&#243;n se muestra un programa que cambia los colores de su gr&#225;fico de esta forma utilizando sus variables locales predefinidas <a href="#1131">file</a> y <a href="#1126">graph</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_convert_palette;

PRIVATE
    nueva_paleta[255];
    contador;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);

    FROM contador=1 TO 255;
        nueva_paleta[contador]=(contador+16) MOD 256;
    END

    graph=100;
    x=160;
    y=100;

    write (0, 160, 0, 1, &quot;Pulse [ESPACIO] para cambiar los colores de la bola&quot;);
    LOOP
        IF (scan_code==_space)

            // Convertimos la paleta del gr&#225;fico n&#250;mero 100 (bola)
            convert_palette(file, graph, offset nueva_paleta);

        END
        FRAME;
    END
END
</pre>
En primer lugar, <strong>se crea una tabla con el nuevo orden de los colores</strong> de la paleta. El color n&#250;mero 0 (transparente) no se sustituir&#225; por ninguno (nueva_paleta[0] valdr&#225; siempre 0) y el resto de los colores (del 1 al 255) se sustituir&#225;n por el color que est&#225; 16 posiciones m&#225;s arriba en la paleta (el 1 por el 17, el 2 por el 18, etc.). Los &#250;ltimos 16 colores se sustituir&#225;n por los 16 primeros (al realizar la operaci&#243;n <strong>MOD 256</strong> se truncan los valores, es decir, 256 pasar&#225; a 0, 257 a 1, etc.).<br/><br/>
Despu&#233;s, dentro del bucle principal del programa se ejecutar&#225; la funci&#243;n <strong>convert_palette()</strong> de modo que cambie los colores del gr&#225;fico del programa (una bola) cada vez que se pulse la barra espaciadora.<br/><br/>
<hr/>
Ver: <a href="#133">load_pal()</a> - <a href="#154">roll_palette()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="106">define_region()</h2><br/><br/>
<strong>define_region(</strong>&lt;n&#250;mero de regi&#243;n&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong>&lt;ancho&gt; <strong>,</strong>&lt;alto&gt; <strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Define una nueva regi&#243;n de visualizaci&#243;n dentro de la pantalla (algo as&#237; como una ventana). Las regiones son zonas rectangulares de la pantalla dentro de las cuales se visualizar&#225;n unos determinados procesos, ventanas de scroll o de modo 7.<br/><br/>
El <strong>n&#250;mero de regi&#243;n</strong> debe ser entre 1 y 31. Se pueden definir hasta 31 regiones diferentes de pantalla que despu&#233;s podr&#225;n asignarse a diferentes procesos (fijando su variable local <a href="#1130">region</a> al nuevo n&#250;mero) como su ventana de visualizaci&#243;n, o bien utilizarse como marco para una ventana de scroll o de modo 7 indic&#225;ndolo en el par&#225;metro correspondiente de las funciones <a href="#163">start_scroll()</a> o <a href="#162">start_mode7()</a>.<br/><br/>
La <strong>regi&#243;n n&#250;mero 0</strong> no se debe redefinir, pues ser&#225; siempre la pantalla completa, una ventana en las coordenadas (0, 0) y del ancho y alto de la pantalla. &#201;sta es la regi&#243;n en la que se visualizar&#225;n por defecto todos los procesos, ya que su variable local <a href="#1130">region</a> siempre vale 0 por defecto.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_define_region;

PRIVATE
    contador;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);

    define_region(1, 0, 0, 160, 200);   // Definimos la regi&#243;n 1
    define_region(2, 160, 0, 160, 200); // Definimos la regi&#243;n 2

    write(0, 0, 0, 0, &quot;Regi&#243;n 1&quot;);
    write(0, 320, 0, 2, &quot;Regi&#243;n 2&quot;);

    FROM contador=1 TO 20;
        proceso_m&#243;vil(rand(0, 319), rand(0, 159), rand(-8, 8), rand(-8, 8), rand(1, 2));
    END
END

PROCESS proceso_m&#243;vil(x, y, incremento_x, incremento_y, region);

BEGIN
    graph=100;
    LOOP
        IF (x&lt;0 OR x&gt;320) incremento_x=-incremento_x; END
        IF (y&lt;0 OR y&gt;200) incremento_y=-incremento_y; END
        x+=incremento_x;
        y+=incremento_y;
        FRAME;
    END
END
</pre>
Primero se definen dos regiones como divisiones laterales de la pantalla. Luego, se crean con un bucle 20 procesos de tipo <strong>proceso_m&#243;vil</strong> en coordenadas y desplazamiento aleatorios, en una de las dos regiones.<br/><br/>
Se puede observar en su ejecuci&#243;n c&#243;mo cada proceso se ve &#250;nicamente en una de las dos mitades de la pantalla (s&#243;lo en su regi&#243;n).<br/><br/>
<hr/>
Ver: <a href="#143">out_region()</a> - <a href="#163">start_scroll()</a> - <a href="#162">start_mode7()</a> - <a href="#1130">Variable region</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="107">delete_text()</h2><br/><br/>
<strong>delete_text(</strong>&lt;identificador del texto&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Borra un texto definitivamente de la pantalla si se especifica como par&#225;metro el <strong>identificador del texto</strong>, que es un c&#243;digo num&#233;rico que devuelven las funciones <a href="#171">write()</a> y <a href="#172">write_int()</a> cuando se les pide que escriban un texto.<br/><br/>
Si se especifica como par&#225;metro <a href="#1161">all_text</a> se borrar&#225;n todos los textos de pantalla.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_delete_text;

PRIVATE
    identificador_texto;

BEGIN
    write(0, 160, 10, 1, &quot;Pulse [ENTER] para hacer aparecer el texto superior.&quot;);
    LOOP
        identificador_texto=write(0, 160, 0, 1, &quot;Pulse [ESPACIO] para hacer desaparecer este texto.&quot;);
        WHILE (NOT key(_space))
            FRAME;
        END

        delete_text(identificador_texto); // Borramos el texto

        WHILE (NOT key(_enter))
            FRAME;
        END
    END
END
</pre>
En el ejemplo anterior, se imprimen dos textos en pantalla. Cuando se pulsa la barra espaciadora se borra uno de ellos con la funci&#243;n <strong>delete_text()</strong>, y cuando se pulsa la tecla Enter hacemos que vuelva a aparecer, imprimi&#233;ndolo otra vez con la funci&#243;n <a href="#171">write()</a>, la cual nos devuelve el identificador del texto.<br/><br/>
<hr/>
Ver: <a href="#171">write()</a> - <a href="#172">write_int()</a> - <a href="#141">move_text()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="108">end_fli()</h2><br/><br/>
<strong>end_fli()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Finaliza una animaci&#243;n <strong>FLI/FLC</strong> visualizada en pantalla y libera la memoria del ordenador que estaba ocupando.<br/><br/>
Las animaciones <strong>FLI/FLC</strong> se inician con la funci&#243;n <a href="#161">start_fli()</a>.<br/><br/>
S&#243;lamente es posible tener una animaci&#243;n cargada en la memoria del ordenador.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_end_fli;
BEGIN
    LOOP
        start_fli(&quot;help\help.fli&quot;, 0, 0);
        WHILE (frame_fli()&lt;&gt;0)
            FRAME;
        END

        end_fli(); // Descargamos la animacion de la memoria

    END
END
</pre>
En primer lugar, en el ejemplo, se carga la animaci&#243;n con la funci&#243;n <a href="#161">start_fli()</a> y entonces se muestra la misma con <a href="#115">frame_fli()</a> hasta que acaba (cuando esta &#250;ltima funci&#243;n devuelve un 0). En ese momento se descarga de memoria utilizando <strong>end_fli()</strong>.<br/><br/>
El programa contin&#250;a repitiendo esta operaci&#243;n (de carga y descarga de la animaci&#243;n <strong>FLI/FLC</strong>) indefinidamente.<br/><br/>
No es necesario que la animaci&#243;n haya finalizado para poder descargarla de memoria.<br/><br/>
<hr/>
Ver: <a href="#161">start_fli()</a> - <a href="#115">frame_fli()</a> - <a href="#153">reset_fli()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="109">exit()</h2><br/><br/>
<strong>exit(</strong>&lt;mensaje&gt;<strong>,</strong> &lt;c&#243;digo de retorno&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Termina el juego matando todos los procesos de forma inmediata y regresando al sistema operativo (o al entorno DIV) con un <strong>mensaje</strong> y un <strong>c&#243;digo num&#233;rico</strong> (el indicado en la expresi&#243;n del segundo par&#225;metro).<br/><br/>
El mensaje es un texto entre comillas que aparecer&#225; cuando finalice el juego como mensaje de despedida para el jugador.<br/><br/>
El <strong>c&#243;digo de retorno</strong> es v&#225;lido para el uso de programas externos a DIV Games Studio (como ficheros de proceso por lotes BAT), para determinar la acci&#243;n que se debe realizar tras ejecutarse el juego.<br/><br/>
Cuando se utiliza la funci&#243;n <strong>exit()</strong> no es necesario haber descargado previamente ning&#250;n recurso, como ficheros, mapas, sonidos, etc., ya que el sistema finaliza de forma autom&#225;tica todos los recursos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_exit;
BEGIN
    write(0, 160, 0, 1, &quot;Pulsa [ESPACIO] para acabar el programa.&quot;);
    LOOP
        IF (key (_space))
            fade_off();

            exit(&quot;Gracias por usarme!&quot;, 0); // Salimos del programa

        END
        FRAME;
    END
END
</pre>
En el ejemplo se imprime un mensaje y luego se espera a que se pulse la barra espaciadora para salir del programa con la funci&#243;n <strong>exit()</strong>.<br/><br/>
El uso de la funci&#243;n <a href="#111">fade_off()</a> para apagar la pantalla no resulta necesario.<br/><br/>
<hr/>
<br/><br/>
Todos los programas terminar&#225;n su ejecuci&#243;n si se pulsa la combinaci&#243;n de teclas <strong>[ALT]+[X]</strong> en cualquier momento; esto resulta similar a forzar la ejecuci&#243;n de la funci&#243;n <strong>exit()</strong>, s&#243;lo que sin mensaje y con el c&#243;digo de retorno 0.<br/><br/>
<hr/>
Ver: <a href="#129">let_me_alone()</a> - <a href="#111">fade_off()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="110">fade()</h2><br/><br/>
<strong>fade(</strong>&lt;% red&gt;<strong>,</strong> &lt;% green&gt;<strong>,</strong> &lt;% blue&gt;<strong>,</strong> &lt;velocidad&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Inicia un fundido de los colores de la paleta del juego hasta que se alcancen los porcentajes de visualizaci&#243;n (desde 0% hasta 200%) de las componentes <strong>red</strong> (rojo), <strong>green</strong> (verde) y <strong>blue</strong> (azul) que se indican como par&#225;metros.<br/><br/>
El &#250;ltimo par&#225;metro indica la velocidad a la que se va a realizar el fundido de colores, normalmente se define un n&#250;mero desde 1 (muy lentamente) hasta 10 (muy r&#225;pidamente).<br/><br/>
Si se indica como velocidad un n&#250;mero mayor o igual que 64, el fundido se realizar&#225; de forma instant&#225;nea.<br/><br/>
El fundido se ir&#225; realizando gradualmente en las sucesivas visualizaciones del juego (en los siguientes fotogramas).<br/><br/>
Si se ponen las tres componentes a 0 se har&#225; un fundido a negro, si se ponen a 200 se har&#225; un fundido a blanco, y si se ponen a 100 se recuperar&#225;n los colores originales de la paleta del juego.<br/><br/>
Un valor inferior a 100 en una componente apagar&#225; su color, mientras que un valor superior a 100, saturar&#225; el color.<br/><br/>
Se recuerda que el fundido no se realiza al ejecutarse la funci&#243;n <strong>fade()</strong>, sino en las siguientes sentencias <a href="#1029">FRAME</a>. Mientras se est&#225; realizando un fundido la variable global predefinida <a href="#1107">fading</a> valdr&#225; <strong>cierto</strong> (un n&#250;mero impar que en este caso ser&#225; 1) y cuando se termine el fundido (se alcancen finalmente los valores de visualizaci&#243;n de color establecidos), esta variable pasar&#225; a valer <strong>falso</strong> (un numero par, el n&#250;mero 0).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fade;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write (0, 0, 0, 0, &quot;Pulsa [ESPACIO] para ir realizando los efectos.&quot;);
    LOOP
        IF (NOT fading AND key(_space))

            fade(rand(0, 200), rand(0, 200), rand(0, 200), 5);

        END
        FRAME;
    END
END
</pre>
En el ejemplo se carga una pantalla como fondo y se imprime un mensaje; despu&#233;s, cada vez que se pulse la barra espaciadora, si no se est&#225; realizando un fundido (<strong>IF (NOT fading ...)</strong>), se iniciar&#225; uno con la funci&#243;n <strong>fade()</strong> con las tres componentes de color elegidas al azar entre 0% y 200% (con la funci&#243;n <a href="#149">rand()</a>) y a velocidad 5.<br/><br/>
<hr/>
Ver: <a href="#1107">fading</a> - <a href="#111">fade_off()</a> - <a href="#112">fade_on()</a> - <a href="#133">load_pal()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="111">fade_off()</h2><br/><br/>
<strong>fade_off()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Realiza un fundido de los colores de la pantalla a negro. Se detiene el juego tal y como est&#225; hasta que la pantalla quede negra por completo. Realizar un fundido a negro se denomina <strong>apagar la pantalla</strong>.<br/><br/>
Para volver a encender la pantalla (deshacer el fundido a negro) se utiliza la funci&#243;n <a href="#112">fade_on()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fade_off;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write (0, 0, 0, 0, &quot;Pulsa [ESPACIO] para apagar y encender la pantalla.&quot;);
    LOOP
        WHILE (NOT key(_space))
            FRAME;
        END

        fade_off(); // Apagamos la pantalla

        fade_on();
    END
END
</pre>
En el ejemplo se pone una pantalla de fondo y despu&#233;s se espera a que se pulse la barra espaciadora para apagar y encender la pantalla.<br/><br/>
La funci&#243;n <a href="#110">fade()</a> puede realizar esta misma funci&#243;n sin detener el programa o a distintas velocidades, adem&#225;s de poder realizar otros efectos de paleta m&#225;s avanzados.<br/><br/>
<hr/>
Ver: <a href="#110">fade()</a> - <a href="#112">fade_on()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="112">fade_on()</h2><br/><br/>
<strong>fade_on()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Realiza un fundido de los colores de pantalla hasta su situaci&#243;n natural. En las sucesivas visualizaciones del juego (al llegar la sentencia <a href="#1029">FRAME</a>) los colores ir&#225;n recuperando su visibilidad hasta verse perfectamente. A esta acci&#243;n se la denomina <strong>encender la pantalla</strong>.<br/><br/>
Para apagar la pantalla (hacer un fundido a negro) se utiliza la funci&#243;n <a href="#111">fade_off()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fade_off;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write (0, 0, 0, 0, &quot;Pulsa [ESPACIO] para apagar y encender la pantalla.&quot;);
    LOOP
        WHILE (NOT key(_space))
            FRAME;
        END
        fade_off();

        fade_on(); // Se enciende la pantalla

    END
END
</pre>
En el primer ejemplo se pone una pantalla de fondo y despu&#233;s se espera a que se pulse la barra espaciadora para apagar y encender la pantalla.<br/><br/>
La funci&#243;n <a href="#110">fade()</a> puede realizar esta misma funci&#243;n a distintas velocidades, adem&#225;s de poder realizar otros efectos de paleta m&#225;s avanzados.<br/><br/>
<hr/>
<br/><br/>
Todos los juegos realizan de forma autom&#225;tica un <strong>fade_on()</strong> al comienzo de la ejecuci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#110">fade()</a> - <a href="#111">fade_off()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="113">fget_angle()</h2><br/><br/>
<strong>fget_angle(</strong>&lt;x0&gt;<strong>,</strong> &lt;y0&gt;<strong>,</strong> &lt;x1&gt;<strong>,</strong> &lt;y1&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El &#225;ngulo entre dos puntos.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve el &#225;ngulo que hay desde el <strong>punto 0</strong> (x0, y0) hasta el <strong>punto 1</strong> (x1, y1).<br/><br/>
Se recuerda que el &#225;ngulo se especifica en mil&#233;simas de grado. La funci&#243;n devuelve siempre un valor entre<strong> -180000</strong> y <strong>180000</strong> (un &#225;ngulo entre -180 y 180 grados).<br/><br/>
Como coordenadas de ambos puntos (x0, y0, x1, y1) se puede especificar cualquier expresi&#243;n num&#233;rica v&#225;lida.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fget_angle;

PRIVATE
    coordenada_x0, coordenada_y0;
    coordenada_x1, coordenada_y1;
    resultado;
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    write(0, 0, 0, 0, &quot;Coordenadas punto 1&quot;);
    write(0, 0, 10, 0, &quot;X:&quot;);
    write_int(0, 20, 10, 0, offset coordenada_x0);
    write(0, 0, 20, 0, &quot;Y:&quot;);
    write_int(0, 20, 20, 0, offset coordenada_y0);
    write(0, 0, 40, 0, &quot;Coordenadas punto 2&quot;);
    write(0, 0, 50, 0, &quot;X:&quot;);
    write_int(0, 20, 50, 0, offset coordenada_x1);
    write(0, 0, 60, 0, &quot;Y:&quot;);
    write_int(0, 20, 60, 0, offset coordenada_y1);
    write(0, 0, 80, 0, &quot;Angulo del punto 1 al punto 2:&quot;);
    write_int(0, 0, 90, 0, offset resultado);
    write(0, 0, 200, 6, &quot;Pulsa [ESPACIO] para hallar otros dos puntos.&quot;);
    LOOP
        clear_screen();
        coordenada_x0=rand(0, 319);
        coordenada_y0=rand(0, 199);
        coordenada_x1=rand(0, 319);
        coordenada_y1=rand(0, 199);
        put(fichero1,200,coordenada_x0, coordenada_y0);
        put(fichero1,200,coordenada_x1, coordenada_y1);

        //Hallamos el &#225;ngulo entre los dos puntos
        resultado = fget_angle(coordenada_x0, coordenada_y0, coordenada_x1, coordenada_y1);

        scan_code=0;
        WHILE (scan_code&lt;&gt;_space)
            FRAME;
        END
    END
END
</pre>
En el ejemplo, despu&#233;s de poner los mensajes necesarios, se hallan las coordenadas <strong>x</strong> e <strong>y</strong> de dos puntos hallados al azar y se guardan en las variables destinadas para ello, calculando con la funci&#243;n <strong>fget_angle()</strong> el &#225;ngulo entre dichos puntos. Cada vez que se pulse la barra espaciadora se repetir&#225; el proceso.<br/><br/>
La funci&#243;n <a href="#116">get_angle()</a> se utiliza para obtener el <strong>&#225;ngulo de un proceso a otro</strong>, en lugar de entre dos puntos.<br/><br/>
La funci&#243;n <a href="#114">fget_dist()</a> se utiliza para obtener la <strong>distancia entre dos puntos</strong>, en lugar del &#225;ngulo.<br/><br/>
<hr/>
Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#116">get_angle()</a> - <a href="#114">fget_dist()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="114">fget_dist()</h2><br/><br/>
<strong>fget_dist(</strong>&lt;x0&gt;<strong>,</strong> &lt;y0&gt;<strong>,</strong> &lt;x1&gt;<strong>,</strong> &lt;y1&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La distancia entre dos puntos.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve la distancia que hay desde el <strong>punto 0</strong> (x0, y0) hasta el <strong>punto 1</strong> (x1, y1).<br/><br/>
Como coordenadas de ambos puntos (x0, y0, x1, y1) se puede especificar cualquier expresi&#243;n num&#233;rica v&#225;lida.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fget_dist;

PRIVATE
    coordenada_x0, coordenada_y0;
    coordenada_x1, coordenada_y1;
    resultado;
    fichero1;

BEGIN

    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    write(0, 0, 0, 0, &quot;Coordenadas punto 1&quot;);
    write(0, 0, 10, 0, &quot;X:&quot;);
    write_int(0, 20, 10, 0, offset coordenada_x0);
    write(0, 0, 20, 0, &quot;Y:&quot;);
    write_int(0, 20, 20, 0, offset coordenada_y0);
    write(0, 0, 40, 0, &quot;Coordenadas punto 2&quot;);
    write(0, 0, 50, 0, &quot;X:&quot;);
    write_int(0, 20, 50, 0, offset coordenada_x1);
    write(0, 0, 60, 0, &quot;Y:&quot;);
    write_int(0, 20, 60, 0, offset coordenada_y1);
    write(0, 0, 80, 0, &quot;Distancia entre el punto 1 y el punto 2&quot;);
    write_int(0, 0, 90, 0, offset resultado);
    write(0, 0, 200, 6, &quot;Pulsa [ESPACIO] para hallar otra distancia.&quot;);
    LOOP
        clear_screen();
        coordenada_x0=rand(0, 319);
        coordenada_y0=rand(0, 199);
        coordenada_x1=rand(0, 319);
        coordenada_y1=rand(0, 199);
        put(fichero1,200,coordenada_x0, coordenada_y0);
        put(fichero1,200,coordenada_x1, coordenada_y1);

        //Hallamos la distancia que hay entre los dos puntos
        resultado = fget_dist(coordenada_x0, coordenada_y0, coordenada_x1, coordenada_y1);

        scan_code=0;
        WHILE (scan_code&lt;&gt;_space)
            FRAME;
        END
    END
END
</pre>
En el ejemplo, despu&#233;s de poner los mensajes necesarios se guardan las coordenadas de dos puntos hallados aleatoriamente en las variables definidas para tal efecto, obteniendo la distancia entre ellos con la funci&#243;n <strong>fget_dist()</strong>. Cada vez que se pulse la barra espaciadora se repetir&#225; el proceso.<br/><br/>
La funci&#243;n <a href="#116">get_dist()</a> se utiliza para obtener la <strong>distancia de un proceso a otro</strong>, en lugar de entre dos puntos.<br/><br/>
La funci&#243;n <a href="#114">fget_angle()</a> se utiliza para obtener el <strong>&#225;ngulo entre dos puntos</strong>, en lugar de la distancia.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n se puede utilizar para detectar choques entre procesos por proximidad entre ellos, si bien suele utilizarse para ello la funci&#243;n <a href="#104">collision()</a> que detecta cuando dos procesos tienen sus gr&#225;ficos superpuestos.<br/><br/>
Por ejemplo, con los procesos visualizados dentro de una ventana de modo 7 (ver <a href="#162">start_mode7()</a>) no se puede utilizar la funci&#243;n <a href="#104">collision()</a> debi&#233;ndose obtener la distancia entre los procesos (normalmente con <a href="#116">get_dist()</a>) para comprobar si chocan (si su distancia es menor que una determinada).<br/><br/>
<hr/>
Ver: <a href="#117">get_dist</a> - <a href="#113">fget_angle</a> - <a href="#104">collision()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="115">frame_fli()</h2><br/><br/>
<strong>frame_fli()</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>Cierto</strong> si la animaci&#243;n contin&#250;a y <strong>falso</strong> si ha terminado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Muestra la siguiente imagen de una animaci&#243;n <strong>FLI/FLC</strong> iniciada con la funci&#243;n <a href="#161">start_fli()</a>. Esta funci&#243;n devuelve <strong>0</strong> si termin&#243; ya la animaci&#243;n.<br/><br/>
Durante la ejecuci&#243;n del programa, &#250;nicamente se podr&#225; ejecutar una animaci&#243;n <strong>FLI/FLC</strong> a la vez, es decir, no se podr&#225;n tener dos animaciones ejecut&#225;ndose al mismo tiempo.<br/><br/>
La imagen de la animaci&#243;n se ver&#225; s&#243;lo en la siguiente imagen del juego (cuando llegue la sentencia <a href="#1029">FRAME</a>), por lo que si se realiza un bucle, dentro del cual se llama a la funci&#243;n <strong>frame_fli()</strong> pero no a la sentencia <a href="#1029">FRAME</a>, no se visualizar&#225; la animaci&#243;n en pantalla.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_frame_fli;
BEGIN
    start_fli(&quot;help\help.fli&quot;, 0, 0);
    LOOP

        frame_fli(); // Mostramos la siguiente imagen

        FRAME;
    END
END
</pre>
En el ejemplo, se carga la animaci&#243;n <strong>FLI/FLC</strong> y luego se ejecuta indefinidamente con la funci&#243;n <strong>frame_fli()</strong>.<br/><br/>
<hr/>
Ver: <a href="#161">start_fli()</a> - <a href="#153">reset_fli()</a> - <a href="#108">end_fli()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="116">get_angle()</h2><br/><br/>
<strong>get_angle(</strong>&lt;c&#243;digo identificador&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El &#225;ngulo hacia otro proceso.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve el &#225;ngulo desde el proceso actual (el que llam&#243; a esta funci&#243;n) hasta el proceso cuyo <a href="#1039">c&#243;digo identificador</a> se le pasa como par&#225;metro.<br/><br/>
Ver <a href="#1038">formas de obtener el c&#243;digo identificador</a>, para m&#225;s informaci&#243;n.<br/><br/>
Se recuerda que el &#225;ngulo se especifica en mil&#233;simas de grado. La funci&#243;n devuelve siempre un valor entre<strong> -180000</strong> y <strong>180000</strong> (un &#225;ngulo entre -180 y 180 grados).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_angle;

PRIVATE
    &#225;ngulo_resultante;
    identificador_proceso;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;

    identificador_proceso = proceso_m&#243;vil(80, 50, 101);

    write(0, 160, 200, 7, &quot;Use los cursores para mover el tri&#225;ngulo.&quot;);
    write(0, 0, 0, 0, &quot;Angulo desde la bola hacia el tri&#225;ngulo:&quot;);
    write_int(0, 0, 10, 0, offset &#225;ngulo_resultante);
    LOOP

        // Hallamos el &#225;ngulo entre los dos procesos
        &#225;ngulo_resultante = get_angle(identificador_proceso);

        FRAME;
    END
END

PROCESS proceso_m&#243;vil(x, y, graph);
BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
</pre>
Al inicio se pone el fondo de pantalla y el programa principal define su gr&#225;fico como una bola situada en el centro de la pantalla.<br/><br/>
Desp&#250;es, se crea un proceso del tipo <strong>proceso_m&#243;vil</strong> del cual se coge el <a href="#1039">c&#243;digo identificador</a>, que se puede controlar con los cursores.<br/><br/>
Dentro del bucle principal se calcula y muestra continuamente en pantalla el &#225;ngulo entre los dos procesos.<br/><br/>
La funci&#243;n <a href="#113">fget_angle()</a> se utiliza para obtener el <strong>&#225;ngulo entre dos puntos</strong>, en lugar de entre dos procesos. Si el <a href="#1039">c&#243;digo identificador</a> del proceso se tiene, por ejemplo, en una variable denominada <strong>id2</strong>, entonces la llamada a la funci&#243;n:<br/><br/>
<strong>get_angle(id2)</strong><br/><br/>
Ser&#237;a equivalente a:<br/><br/>
<strong>fget_angle(x, y, id2.x, id2.y)</strong><br/><br/>
Obtener el &#225;ngulo desde las coordenadas (x, y) del proceso actual, hasta las coordenadas (x, y) del proceso cuyo <a href="#1039">c&#243;digo identificador</a> es <strong>id2</strong>.<br/><br/>
La funci&#243;n <a href="#117">get_dist()</a> se utiliza para obtener la <strong>distancia hasta otro proceso</strong>, en lugar del &#225;ngulo.<br/><br/>
<hr/>
Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#113">fget_angle()</a> - <a href="#117">get_dist()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="117">get_dist()</h2><br/><br/>
<strong>get_dist(</strong>&lt;c&#243;digo identificador&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La distancia hasta otro proceso.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve la distancia desde el proceso actual (el que llam&#243; a esta funci&#243;n) hasta el proceso cuyo <a href="#1039">c&#243;digo identificador</a> se le pasa como par&#225;metro.<br/><br/>
Ver <a href="#1038">formas de obtener el c&#243;digo identificador</a>, para m&#225;s informaci&#243;n.<br/><br/>
Si el proceso ha definido su variable local <a href="#1135">resolution</a> es importante que el proceso hasta el que se quiere obtener la distancia la tenga definida al mismo valor. Es decir, si ambos procesos manejan las coordenadas en cent&#233;simas en lugar de unidades (con <a href="#1135">resolution</a>=100), la distancia entre ambos tambi&#233;n se obtendr&#225; en cent&#233;simas, pero si el valor de dicha variable difiere en ambos procesos, el resultado de la funci&#243;n <strong>get_dist()</strong> carecer&#225; de sentido.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_dist;

PRIVATE
    distancia_resultante;
    identificador_proceso;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    graph=100;
    x=160;
    y=100;

    identificador_proceso = proceso_m&#243;vil(80, 50, 101);

    write(0, 160, 200, 7, &quot;Use los cursores para mover el tri&#225;ngulo.&quot;);
    write(0, 0, 0, 0, &quot;Distancia desde la bola hasta el tri&#225;ngulo:&quot;);
    write_int(0, 0, 10, 0, offset distancia_resultante);
    LOOP

        // Hallamos la distancia entre los dos procesos
        distancia_resultante = get_dist(identificador_proceso);

        FRAME;
    END
END

PROCESS proceso_m&#243;vil(x, y, graph)
BEGIN
    LOOP
        IF (key(_right)) angle-=10000; END
        IF (key(_left)) angle+=10000; END
        IF (key(_up)) advance(4); END
        FRAME;
    END
END
</pre>
Al inicio se pone el fondo de pantalla y el programa principal define su gr&#225;fico como una bola situada en el centro de la pantalla.<br/><br/>
Desp&#250;es se crea un proceso del tipo <strong>proceso_m&#243;vil</strong> del cual se coge el <a href="#1039">c&#243;digo identificador</a>, que se puede controlar con los cursores.<br/><br/>
Dentro del bucle principal se calcula y muestra continuamente en pantalla la distancia entre los dos procesos.<br/><br/>
La funci&#243;n <a href="#114">fget_dist()</a> se utiliza para obtener la <strong>distancia entre dos puntos</strong>, en lugar de entre dos procesos. Si el <a href="#1039">c&#243;digo identificador</a> del proceso se tiene, por ejemplo, en una variable denominada <strong>id2</strong>, entonces la llamada a la funci&#243;n:<br/><br/>
<strong>get_dist(id2)</strong><br/><br/>
Ser&#237;a equivalente a:<br/><br/>
<strong>fget_dist(x, y, id2.x, id2.y)</strong><br/><br/>
Obtener la distancia desde las coordenadas (x, y) del proceso actual hasta las coordenadas (x, y) del proceso cuyo <a href="#1039">c&#243;digo identificador</a> es <strong>id2</strong>.<br/><br/>
La funci&#243;n <a href="#116">get_angle()</a> se utiliza para obtener el <strong>&#225;ngulo hasta otro proceso</strong>, en lugar de la distancia.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n se puede utilizar para detectar choques entre procesos por proximidad entre ellos, aunque se suele utilizar para ello la funci&#243;n <a href="#104">collision()</a> que detecta cu&#225;ndo dos procesos tienen sus gr&#225;ficos superpuestos.<br/><br/>
Por ejemplo, con los procesos visualizados dentro de una ventana de modo 7 (ver <a href="#162">start_mode7()</a>) no se puede utilizar la funci&#243;n <a href="#104">collision()</a> debi&#233;ndose obtener la distancia entre los procesos para comprobar si chocan (si su distancia es menor que una determinada).<br/><br/>
<hr/>
Ver: <a href="#114">fget_dist()</a> - <a href="#116">get_angle()</a> - <a href="#118">get_distx()</a> - <a href="#119">get_disty()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="118">get_distx()</h2><br/><br/>
<strong>get_distx(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El desplazamiento horizontal del vector (&#225;ngulo, distancia).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve distancia horizontal (en el eje de la coordenada <strong>x</strong>) a partir del &#225;ngulo y <strong>distancia</strong> (sobre ese &#225;ngulo) pasados como par&#225;metros. Es decir, devuelve la distancia que recorre en horizontal el vector formado por el &#225;ngulo y <strong>longitud</strong> (distancia o m&#243;dulo del vector) indicados.<br/><br/>
Se recuerda que el &#225;ngulo se especifica en mil&#233;simas de grado y como distancia se puede especificar cualquier expresi&#243;n num&#233;rica v&#225;lida.<br/><br/>
La funci&#243;n utilizada para calcular la distancia vertical, en lugar de la horizontal, es <a href="#119">get_disty()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_distx;

GLOBAL
    distancia;
    distancia_horizontal;
    distancia_vertical;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 3);
    write(0, 160, 200, 7, &quot;Utilice los cursores para mover el tri&#225;ngulo.&quot;);
    write(0, 0, 0, 0, &quot;Distancia horizontal:&quot;);
    write_int(0, 0, 10, 0, offset distancia_horizontal);
    graph=101;
    LOOP
        IF (key(_up)) distancia+=2; END
        IF (key(_down)) distancia-=2; END
        IF (key(_right)) angle-=2000; END
        IF (key(_left)) angle+=2000; END

        // Calculamos la distancia horizontal
        distancia_horizontal = get_distx(angle, distancia);

        distancia_vertical = get_disty(angle, distancia);
        x=160+distancia_horizontal;
        y=100+distancia_vertical;
        FRAME;
    END
END
</pre>
En el ejemplo se pone como fondo de la pantalla una gr&#225;fica circular, sobre la que se manejar&#225; con los cursores un tri&#225;ngulo, modificando su distancia y &#225;ngulo al centro de la gr&#225;fica.<br/><br/>
El programa calcula la distancia horizontal y vertical para emplazar el tri&#225;ngulo a partir de las coordenadas del centro de pantalla (160, 100), mostr&#225;ndose en todo momento la distancia horizontal en la esquina superior izquierda.<br/><br/>
<hr/>
<br/><br/>
Si se quiere avanzar las coordenadas del proceso una <strong>distancia</strong> en un &#225;ngulo determinado, se pueden utilizar las siguientes sentencias:<br/><br/>
<strong>x+=get_distx(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>);</strong><br/>
<strong>y+=get_disty(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>);</strong><br/>
<br/><br/>
Esto ser&#237;a equivalente a la siguiente sentencia (utilizando la funci&#243;n <a href="#183">xadvance()</a>).<br/><br/>
<strong>xadvance(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>);</strong><br/><br/>
Si el &#225;ngulo en el que se quiere mover el proceso es el que tiene en su variable local <a href="#1129">angle</a>, entonces esta misma operaci&#243;n se podr&#237;a realizar con la funci&#243;n <a href="#101">advance()</a> de la siguiente forma:<br/><br/>
<strong>advance(</strong>&lt;distancia&gt;<strong>);</strong><br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <strong>get_distx()</strong> equivale a calcular el <strong>coseno</strong> del &#225;ngulo y multiplicarlo por la <strong>distancia</strong>.<br/><br/>
<hr/>
Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#119">get_disty()</a> - <a href="#183">xadvance()</a> - <a href="#101">advance()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="119">get_disty()</h2><br/><br/>
<strong>get_disty(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El desplazamiento vertical del vector (&#225;ngulo, distancia).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve distancia vertical (eje de la coordenada <strong>y</strong>) a partir del &#225;ngulo y <strong>distancia</strong> (sobre ese &#225;ngulo) pasados como par&#225;metros. Es decir, devuelve la distancia que recorre en vertical el vector formado por el &#225;ngulo y <strong>longitud</strong> (distancia) indicados.<br/><br/>
Se recuerda que el &#225;ngulo se especifica en mil&#233;simas de grado y como distancia se puede especificar cualquier expresi&#243;n num&#233;rica v&#225;lida.<br/><br/>
La funci&#243;n utilizada para calcular la distancia horizontal, en lugar de la vertical, es <a href="#119">get_distx()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_disty;

GLOBAL
    distancia;
    distancia_horizontal;
    distancia_vertical;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 3);
    write(0, 160, 200, 7, &quot;Utilice los cursores para mover el tri&#225;ngulo.&quot;);
    write(0, 0, 0, 0, &quot;Distancia vertical:&quot;);
    write_int(0, 0, 10, 0, offset distancia_vertical);
    graph=101;
    LOOP
        IF (key(_up)) distancia+=2; END
        IF (key(_down)) distancia-=2; END
        IF (key(_right)) angle-=2000; END
        IF (key(_left)) angle+=2000; END

        // Calculamos la distancia vertical
        distancia_vertical = get_disty(angle, distancia);

        distancia_horizontal = get_distx(angle, distancia);
        x=160+distancia_horizontal;
        y=100+distancia_vertical;
        FRAME;
    END
END
</pre>
En el ejemplo se pone como fondo de la pantalla una gr&#225;fica circular, sobre la que se manejar&#225; con los cursores un tri&#225;ngulo, modificando su distancia y &#225;ngulo al centro de la gr&#225;fica.<br/><br/>
El programa calcula la distancia horizontal y vertical para emplazar el tri&#225;ngulo a partir de las coordenadas del centro de pantalla (160, 100), mostr&#225;ndose en todo momento la distancia vertical en la esquina superior izquierda.<br/><br/>
<hr/>
<br/><br/>
Si se quiere avanzar las coordenadas del proceso una <strong>distancia</strong> en un &#225;ngulo determinado, se pueden utilizar las siguientes sentencias:<br/><br/>
<strong>x+=get_distx(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>);</strong><br/>
<strong>y+=get_disty(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>);</strong><br/>
<br/><br/>
Esto ser&#237;a equivalente a la siguiente sentencia (utilizando la funci&#243;n <a href="#183">xadvance()</a>).<br/><br/>
<strong>xadvance(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>);</strong><br/><br/>
Si el &#225;ngulo en el que se quiere mover el proceso es el que tiene en su variable local <a href="#1129">angle</a>, entonces esta misma operaci&#243;n se podr&#237;a realizar con la funci&#243;n <a href="#101">advance()</a> de la siguiente forma:<br/><br/>
<strong>advance(</strong>&lt;distancia&gt;<strong>);</strong><br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <strong>get_disty()</strong> equivale a calcular el <strong>seno</strong> del &#225;ngulo y multiplicarlo por la <strong>distancia</strong>, cambiando este resultado de signo, debido a que el eje <strong>Y</strong> de pantalla avanza hacia abajo (de manera contraria a la funci&#243;n seno).<br/><br/>
<hr/>
Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#118">get_distx()</a> - <a href="#183">xadvance()</a> - <a href="#101">advance()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="120">get_id()</h2><br/><br/>
<strong>get_id(</strong>&lt;tipo de proceso&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <a href="#1039">c&#243;digo identificador</a> de un proceso o <strong>0</strong>.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Comprueba si hay procesos del tipo especificado activos. En caso afirmativo, esta funci&#243;n devolver&#225; el <a href="#1039">c&#243;digo identificador</a> de uno de ellos y, en el caso contrario, devolver&#225; un 0.<br/><br/>
Si existen varios procesos del tipo que se ha especificado, la funci&#243;n <strong>get_id()</strong> devolver&#225; el resto de los identificadores en las sucesivas llamadas que se realicen a la misma.<br/><br/>
Una vez se hayan devuelto todos los <a href="#1039">c&#243;digos identificadores</a>, la funci&#243;n devolver&#225; 0, hasta que se vuelva a ejecutar una sentencia <a href="#1029">FRAME</a>, momento a partir del cual esta funci&#243;n devolver&#225;, de nuevo, todos los c&#243;digos identificadores de los procesos del tipo indicado.<br/><br/>
Para obtener de esta forma todos los <a href="#1039">c&#243;digos identificadores</a> de los procesos no se debe utilizar la sentencia <a href="#1029">FRAME</a> entre dos llamadas consecutivas a la sentencia <strong>get_id()</strong>. En el caso de ejecutar una sentencia <a href="#1029">FRAME</a>, esta funci&#243;n volver&#225; a retornar todos los <a href="#1039">c&#243;digos identificadores</a> de procesos desde el primero.<br/><br/>
Algo similar sucede si se ejecuta una llamada a la funci&#243;n especificando un tipo de proceso diferente; si tras esto se vuelven a pedir identificadores del tipo de proceso anterior, esta funci&#243;n tambi&#233;n los volver&#225; a retornar todos desde el primero.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_id;

PRIVATE
    identificador_proceso;
    contador;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    FROM contador=1 TO 20;
        proceso_m&#243;vil(rand(0, 319), rand(0, 199), 101);
    END
    LOOP
        FROM contador=1 TO 20;

            // Cogemos los identificadores de los procesos
            identificador_proceso = get_id(TYPE proceso_m&#243;vil);

            identificador_proceso.angle+=rand(-5000, 5000);
        END
        FRAME;
    END
END

PROCESS proceso_m&#243;vil(x, y, graph);
BEGIN
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo, despu&#233;s de cargar el fichero de gr&#225;ficos y poner la pantalla de fondo, se crean 20 procesos tipo <strong>proceso_m&#243;vil</strong> con sus posiciones elegidas aleatoriamente y un tri&#225;ngulo como su gr&#225;fico.<br/><br/>
Estos procesos &#250;nicamente ejecutar&#225;n sentencias <a href="#1029">FRAME</a> dentro de un bucle, para visualizarse.<br/><br/>
Desde el programa principal se van cogiendo los identificadores de los procesos tipo <strong>proceso_m&#243;vil</strong> con la funci&#243;n <strong>get_id()</strong> (guard&#225;ndolos en la variable <strong>identificador_proceso</strong>) y utiliz&#225;ndolos para modificarles el &#225;ngulo (su variable local <a href="#1129">angle</a>).<br/><br/>
Al disponer del <a href="#1039">c&#243;digo identificador</a> de un proceso se pueden consultar o modificar sus variables locales (como <a href="#1129">angle</a> en este ejemplo) o bien enviar se&#241;ales al proceso con la funci&#243;n <a href="#158">signal()</a>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#104">collision()</a> sirve para obtener los <a href="#1039">c&#243;digos identificadores</a> de procesos de un tipo determinado que, adem&#225;s, colisionen (choquen) con el proceso actual.<br/><br/>
<hr/>
Ver: <a href="#1038">Formas de obtener el c&#243;digo identificador</a> - <a href="#1042">Tipos de procesos</a> - <a href="#1039">C&#243;digos identificadores</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="121">get_joy_button()</h2><br/><br/>
<strong>get_joy_button(</strong>&lt;n&#250;mero de bot&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>Cierto</strong> (1) si el bot&#243;n est&#225; pulsado, <strong>Falso</strong> (0) si no lo est&#225;.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n requiere como par&#225;metro el n&#250;mero de bot&#243;n del joystick (de 0 a 3), y devuelve <strong>cierto</strong> (un valor num&#233;rico impar) si est&#225; pulsado en ese momento.<br/><br/>
Si el bot&#243;n no est&#225; pulsado, la funci&#243;n devuelve <strong>falso</strong> (un valor num&#233;rico par).<br/><br/>
Algunos joystick &#250;nicamente tienen 2 botones; en este caso ser&#225;n los botones n&#250;mero 0 y 1. En ordenadores con dos joystick conectados, el segundo joystick tendr&#225; los botones n&#250;mero 2 y 3.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_joy_button;

PRIVATE
    contador;
    botones[3];

BEGIN
    write(0, 160, 200, 7,&quot; Pulse los botones del joystick.&quot;);
    write(0, 0, 0, 0, &quot;Botones (0..3):&quot;);
    write_int(0, 100, 0, 0, offset botones[0]);
    write_int(0, 120, 0, 0, offset botones[1]);
    write_int(0, 140, 0, 0, offset botones[2]);
    write_int(0, 160, 0, 0, offset botones[3]);
    LOOP
        FROM contador=0 TO 3;

            // Cogemos el valor del bot&#243;n del joystick
            botones[contador] = get_joy_button(contador);

        END
        FRAME;
    END
END
</pre>
Se imprime un mensaje explicativo en la parte inferior y el estado de los cuatro posibles botones en la parte superior; despu&#233;s, el programa se queda dentro de un bucle actualizando continuamente el estado de los cuatro botones con la funci&#243;n <strong>get_joy_button()</strong>.<br/><br/>
<hr/>
<br/><br/>
Hay otras formas de utilizar el joystick. La m&#225;s sencilla es utilizar la estructura <a href="#1103">joy</a>, ya que en &#233;sta hay cuatro registros que indican continuamente el estado de los botones del joystick.<br/><br/>
<hr/>
Ver: <a href="#122">get_joy_position()</a> - <a href="#1103">Estructura joy</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="122">get_joy_position()</h2><br/><br/>
<strong>get_joy_position(</strong>&lt;n&#250;mero de eje&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La posici&#243;n del eje del joystick.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n devuelve la coordenada en la que se encuentra el eje indicado (con un n&#250;mero del <strong>0</strong> al <strong>3</strong>) del joystick anal&#243;gico.<br/><br/>
Eje <strong>0</strong> - Eje <strong>X</strong> principal.<br/>
Eje <strong>1</strong> - Eje <strong>Y</strong> principal.<br/>
Eje <strong>2</strong> - Eje <strong>X</strong> secundario.<br/>
Eje <strong>3</strong> - Eje <strong>Y</strong> secundario.<br/>
<br/><br/>
La coordenada del joystick puede variar en funci&#243;n del tipo de joystick y del ordenador en el que se ejecute, a&#250;n as&#237; es un n&#250;mero que suele variar entre <strong>4</strong> y <strong>200</strong>, aproximadamente.<br/><br/>
Los ejes <strong>principal</strong> y <strong>secundario</strong> pueden estar integrados en un s&#243;lo joystick, en algunos casos (mandos de vuelo con un <strong>hat</strong>, <strong>pedales</strong>, etc.). En ordenadores que tengan dos joystick conectados, el eje principal ser&#225; el joystick 1 y el secundario el 2.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_joy_position;

PRIVATE
    eje_joystick[3];
    contador;

BEGIN
    write (0, 160, 200, 7, &quot;Mueva el joystick&quot;);
    write (0, 0, 0, 0, &quot;Coordenada X principal.&quot;);
    write_int(0, 0, 10, 0, offset eje_joystick[0]);
    write (0, 0, 40, 0, &quot;Coordenada Y principal.&quot;);
    write_int(0, 0, 50, 0, offset eje_joystick[1]);
    write (0, 0, 80, 0, &quot;Coordenada X secundaria.&quot;);
    write_int(0, 0, 90, 0, offset eje_joystick[2]);
    write (0, 0, 120, 0, &quot;Coordenada Y secundaria.&quot;);
    write_int(0, 0, 130, 0, offset eje_joystick[3]);
    LOOP
        FROM contador=0 TO 3;

            // Cogemos el valor de los ejes del joystick
            eje_joystick[contador] = get_joy_position(contador);

        END
        FRAME;
    END
END
</pre>
Primero se imprimen los mensajes y, despu&#233;s, el programa se queda dentro de un bucle actualizando de forma continua el estado de los cuatro ejes con la funci&#243;n <strong>get_joy_button()</strong> (que, en este caso, se guardan en la tabla privada <strong>eje_joystick</strong>).<br/><br/>
<hr/>
<br/><br/>
Hay otras formas de utilizar el joystick. La m&#225;s sencilla es utilizar la estructura <a href="#1103">joy</a> cuando no se requiera una lectura anal&#243;gica del joystick (sus coordenadas), es decir, cuando baste con saber si el joystick est&#225; en el centro, a la derecha, abajo, etc.<br/><br/>
<hr/>
Ver: <a href="#121">get_joy_button()</a> - <a href="#1103">Estructura joy</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="123">get_pixel()</h2><br/><br/>
<strong>get_pixel(</strong>&lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El color del punto (0..255).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve el color que tiene el punto del <strong>fondo de la pantalla</strong> que est&#225; en las coordenadas indicadas como par&#225;metros.<br/><br/>
El n&#250;mero devuelto es el orden dentro de la paleta de colores activa en el programa, entre 0 y 255, ya que las paletas tienen 256 colores.<br/><br/>
El punto se toma &#250;nicamente del dibujo de fondo de la pantalla, sin tener en cuenta los gr&#225;ficos de los procesos, textos, regiones de scroll, etc., es decir, s&#243;lo se leer&#225;n los colores puestos por las funciones <a href="#146">put()</a>, <a href="#173">xput()</a>, <a href="#147">put_pixel()</a> y <a href="#148">put_screen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_pixel;

PRIVATE
    color_punto;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 2);
    mouse.graph=200;
    write (0, 0, 190, 0, &quot;Color del punto del fondo de pantalla:&quot;);
    write_int(0, 256, 190, 0, offset color_punto);
    LOOP

        // Cogemos el color del punto del fondo de la pantalla
        color_punto = get_pixel(mouse.x, mouse.y);

        FRAME;
    END
END
</pre>
En el ejemplo, se pone el fondo de pantalla con la funci&#243;n <a href="#148">put_screen</a>, como una serie de cuadr&#237;culas de distintos colores y se asigna una cruz como puntero del rat&#243;n.<br/><br/>
Despu&#233;s se mostrar&#225; en la parte inferior de la pantalla el color que est&#225; en la posici&#243;n se&#241;alada con el rat&#243;n, leyendo &#233;ste con la funci&#243;n <strong>get_pixel()</strong> en cada iteraci&#243;n del bucle principal del programa.<br/><br/>
<hr/>
Ver: <a href="#147">put_pixel()</a> - <a href="#136">map_get_pixel()</a> - <a href="#138">map_put_pixel()</a> - <a href="#124">get_point()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="124">get_point()</h2><br/><br/>
<strong>get_point(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;n&#250;mero&gt;<strong>,</strong> &lt;OFFSET x&gt;<strong>,</strong> &lt;OFFSET y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La posici&#243;n del punto de control (en las variables cuyo <a href="#1085">offset</a> se indica como los dos &#250;ltimos par&#225;metros).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n devuelve donde se situ&#243; en un <strong>gr&#225;fico</strong> (del <strong>fichero</strong> indicado) el punto de control cuyo <strong>n&#250;mero</strong> se indica como tercer par&#225;metro.<br/><br/>
Un <a href="#1136">punto de control</a> es un punto que se puede definir en el editor de gr&#225;ficos (herramienta de dibujo), en la opci&#243;n habilitada para dicha funci&#243;n.<br/><br/>
La funci&#243;n necesita la <strong>direcci&#243;n</strong> (que se obtiene con el operador <a href="#1085">offset</a>) en la memoria del ordenador <strong>de dos variables</strong> en las que devolver&#225; la posici&#243;n <strong>x</strong> e <strong>y</strong> del punto de control.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_point;

GLOBAL
    fichero1;
    punto=1;
    x_punto;
    y_punto;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 4);
    graph=101;
    LOOP
        IF (fget_dist(x, y, x_punto, y_punto)&lt;6)
            IF (punto++==50) punto=1; END
        END

        // Cogemos el punto de control
        get_point(fichero1, 4,punto, offset x_punto, offset y_punto);

        angle=fget_angle(x, y, x_punto, y_punto);
        advance(6);
        FRAME;
    END
END
</pre>
En el ejemplo se pone como fondo un dibujo con un circuito que recorre la pantalla; este dibujo (el gr&#225;fico <strong>4</strong> del fichero) tiene definidos 50 <a href="#1136">puntos de control</a> (del 1 al 50) a lo largo del recorrido del circuito.<br/><br/>
El proceso principal aparece como un tri&#225;ngulo que va recorriendo el circuito.<br/><br/>
Esto se consigue teniendo en la variable <strong>punto</strong> el n&#250;mero del punto de control al que se debe dirigir el tri&#225;ngulo, en un principio el punto n&#250;mero 1.<br/><br/>
Las coordenadas de cada punto de control, obtenidas con la funci&#243;n <strong>get_point()</strong>, se guardan en las variables <strong>x_punto</strong> e <strong>y_punto</strong> y sirven para que el proceso se dirija hacia esa posici&#243;n con las funciones <a href="#113">fget_angle()</a> (para obtener en la variable <strong>angle</strong> el &#225;ngulo hacia el punto) y <a href="#101">advance()</a> (para avanzar 6 puntos en esa direcci&#243;n).<br/><br/>
Cuando se est&#225; cerca del punto de control, lo que se comprueba con la funci&#243;n <a href="#114">fget_dist()</a>, es si se incrementa el n&#250;mero de punto, para dirigir el tri&#225;ngulo hacia el siguiente (cuando se haya alcanzado el punto n&#250;mero 50, se volver&#225; al 1).<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n devuelve las coordenadas exactas en las que fue colocado ese punto de control dentro del gr&#225;fico, sin importar c&#243;mo est&#233; dicho gr&#225;fico ahora (escalado, rotado, etc.). Para poder obtener la posici&#243;n de un punto de control en un gr&#225;fico escalado, rotado, etc. y relativa a las coordenadas de pantalla (y no del gr&#225;fico original) se debe emplear la funci&#243;n <a href="#125">get_real_point()</a>.<br/><br/>
Es decir, esta &#250;ltima funci&#243;n devuelve d&#243;nde est&#225; en un momento determinado un punto de control, y <strong>get_point()</strong> devuelve d&#243;nde fue emplazado originalmente.<br/><br/>
<hr/>
Ver: <a href="#1136">Puntos de control</a> - <a href="#125">get_real_point()</a> - <a href="#123">get_pixel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="125">get_real_point()</h2><br/><br/>
<strong>get_real_point(</strong>&lt;n&#250;mero&gt;<strong>,</strong> &lt;OFFSET x&gt;<strong>,</strong> &lt;OFFSET y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Las coordenadas actuales del punto de control (en las variables cuyo <a href="#1085">offset</a> se indica como los dos &#250;ltimos par&#225;metros).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n devuelve donde est&#225; en ese instante un punto de control del gr&#225;fico del proceso actual en el sistema de coordenadas utilizado por el propio proceso (ver variable local <a href="#1122">ctype</a>), evaluando la ubicaci&#243;n original del punto, las coordenadas actuales del proceso, su tama&#241;o, &#225;ngulo, etc.<br/><br/>
Un <a href="#1136">punto de control</a> es un punto que se puede definir en el editor de gr&#225;ficos (herramienta de dibujo), en la opci&#243;n habilitada para dicha funci&#243;n.<br/><br/>
La funci&#243;n necesita la <strong>direcci&#243;n</strong> (que se obtiene con el operador <a href="#1085">offset</a>) en la memoria del ordenador <strong>de dos variables</strong> en las que devolver&#225; la posici&#243;n <strong>x</strong> e <strong>y</strong> del punto de control.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_real_point;

PRIVATE
    punto;
    x_punto;
    y_punto;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    graph=4;
    x=160;
    y=100;
    LOOP
        FROM punto=1 TO 50;

            // Cogemos las coordenadas de donde est&#225; ahora el punto de control
            get_real_point(punto, offset x_punto, offset y_punto);

            proceso_marcador(x_punto, y_punto, 200);
        END
        angle+=1000;
        FRAME;
    END
END

PROCESS proceso_marcador(x, y, graph);
BEGIN
    FRAME;
END
</pre>
En el ejemplo se define c&#243;mo gr&#225;fico del proceso principal un circuito que recorre la pantalla. Este gr&#225;fico tiene definidos 50 <a href="#1136">puntos de control</a> (del 1 al 50).<br/><br/>
El programa se queda en un bucle dentro del cual va rotando este gr&#225;fico (sum&#225;ndole un grado con la sentencia <strong>angle+=1000;</strong>) y creando 50 procesos en forma de cruz, una en cada uno de los puntos de control del gr&#225;fico.<br/><br/>
Se puede comprobar c&#243;mo la posici&#243;n relativa de los puntos de control no var&#237;a aunque el gr&#225;fico del circuito rote.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n se suele utilizar para tener localizados algunos puntos importantes de un gr&#225;fico. Por ejemplo, si se ha definido un proceso cuyo gr&#225;fico es un hombre con una pistola que pueda escalarse, rotarse o realizar diversas animaciones, podr&#237;a definirse un punto de control en la punta del ca&#241;&#243;n de la pistola para saber en cada momento de d&#243;nde deben salir las balas en caso de que dispare.<br/><br/>
Si el gr&#225;fico original estaba dentro de una regi&#243;n de scroll (ver <a href="#163">start_scroll()</a>) las coordenadas devueltas tambi&#233;n ser&#225;n relativas a dicha regi&#243;n de scroll.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#124">get_point()</a> devuelve d&#243;nde fue emplazado originalmente un punto de control en el gr&#225;fico, en lugar de su posici&#243;n actual, como <strong>get_real_point()</strong>.<br/><br/>
<hr/>
Ver: <a href="#1136">Puntos de control</a> - <a href="#124">get_point()</a> - <a href="#123">get_pixel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="126">graphic_info()</h2><br/><br/>
<strong>graphic_info(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;informaci&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La informaci&#243;n solicitada sobre el gr&#225;fico.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve la informaci&#243;n que se le solicita de un <strong>gr&#225;fico</strong> de un <strong>fichero</strong>.<br/><br/>
Informaci&#243;n:<br/><br/>
<strong>g_wide</strong> - La funci&#243;n devolver&#225; el <strong>ancho original</strong> de dicho gr&#225;fico si se pone g_wide como tercer par&#225;metro.<br/><br/>
<strong>g_height</strong> - La funci&#243;n devolver&#225; el <strong>alto original</strong> del gr&#225;fico.<br/><br/>
<strong>g_x_center</strong> - La funci&#243;n devolver&#225; la <strong>coordenada x</strong> del centro del gr&#225;fico.<br/><br/>
<strong>g_y_center</strong> - La funci&#243;n devolver&#225; la <strong>coordenada y</strong> del centro del gr&#225;fico.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_graphic_info;

PRIVATE
    fichero1;
    alto;
    ancho;
    x_centro;
    y_centro;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    put_screen(fichero1, 1);
    graph=100;
    x=160;
    y=100;

    // Cogemos la informaci&#243;n sobre el alto del gr&#225;fico
    alto = graphic_info(fichero1, 100, g_height);

    // Cogemos la informaci&#243;n sobre el ancho del gr&#225;fico
    ancho = graphic_info(fichero1, 100, g_wide);

    // Cogemos la informaci&#243;n sobre la coordenada x del centro del gr&#225;fico
    x_centro = graphic_info(fichero1, 100, g_x_center);

    // Cogemos la informaci&#243;n sobre la coordenada y del centro del gr&#225;fico
    y_centro = graphic_info(fichero1, 100, g_y_center);

    write(0, 0, 0, 0, &quot;Altura del gr&#225;fico:&quot;);
    write_int(0, 0, 10, 0, offset alto);
    write(0, 0, 20, 0, &quot;Ancho del gr&#225;fico:&quot;);
    write_int(0, 0, 30, 0, offset ancho);
    write(0, 0, 40, 0, &quot;Centro horizontal del gr&#225;fico:&quot;);
    write_int(0, 0, 50, 0, offset x_centro);
    write(0, 0, 60, 0, &quot;Centro vertical del gr&#225;fico:&quot;);
    write_int(0, 0, 70, 0, offset y_centro);
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo se solicita informaci&#243;n sobre el gr&#225;fico n&#250;mero 100 del fichero <strong>help.fpg</strong>, que es una bola de 32 puntos por 32 puntos y con el centro en (16, 16).<br/><br/>
Para obtener esta informaci&#243;n ser&#225; necesario llamar 4 veces a la funci&#243;n <strong>graphic_info()</strong>, ya que cada vez devuelve un s&#243;lo valor, en funci&#243;n del tercer par&#225;metro de llamada (&lt;informaci&#243;n&gt;).<br/><br/>
<hr/>
Ver: <a href="#1163">g_wide</a> - <a href="#1164">g_height</a> - <a href="#1165">g_x_center</a> - <a href="#1166">g_y_center</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="127">is_playing_cd()</h2><br/><br/>
<strong>is_playing_cd()</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>Cierto</strong> (1) si est&#225; sonando el CD, o <strong>falso</strong> (0) si no est&#225; sonando.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n sirve para poder determinar si el CD est&#225; tocando una canci&#243;n.<br/><br/>
Devuelve <strong>Cierto</strong> (un n&#250;mero impar) si el CD est&#225; tocando una canci&#243;n, en caso contrario devuelve <strong>Falso</strong> (un n&#250;mero par).<br/><br/>
Su uso m&#225;s generalizado es para poder tocar una canci&#243;n indefinidamente como se muestra en el siguiente ejemplo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_is_playing_cd;
BEGIN
    play_cd(1, 0);
    LOOP

        IF (NOT is_playing_cd()) // Comprueba si ya ha finalizado la canci&#243;n

            play_cd(1, 0);
        END
        FRAME;
    END
END
</pre>
El ejemplo anterior (para el cual se necesita tener un <strong>Compact disc</strong> de m&#250;sica en el cargador de <strong>CD-ROM</strong>) utiliza la funci&#243;n <a href="#144">play_cd()</a> para hacer sonar la primera canci&#243;n del disco.<br/><br/>
Despu&#233;s, en un bucle, se comprueba si dicha canci&#243;n ha terminado de sonar para volver a lanzarla.<br/><br/>
<hr/>
<br/><br/>
El volumen de reproducci&#243;n de cd-audio se puede controlar con la estructura <a href="#1104">setup</a> y la funci&#243;n <a href="#178">set_volume()</a>.<br/><br/>
<hr/>
Ver: <a href="#144">play_cd()</a> - <a href="#164">stop_cd()</a> - <a href="#178">set_volume()</a> - <a href="#1104">Estructura setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="128">key()</h2><br/><br/>
<strong>key(</strong>&lt;c&#243;digo de tecla&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>Cierto</strong> (1) si la tecla est&#225; pulsada y <strong>falso</strong> (0) si no lo est&#225;.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve <strong>cierto</strong> (un n&#250;mero impar) si la tecla, indicada como par&#225;metro, est&#225; pulsada en ese momento; en caso contrario devuelve <strong>falso</strong> (un n&#250;mero par).<br/><br/>
Normalmente el par&#225;metro de entrada ser&#225; el nombre de la tecla con el s&#237;mbolo <strong>_</strong> (subrayado) delante; por ejemplo, para leer la tecla [<strong>A</strong>] se debe llamar a la funci&#243;n como <strong>key(_a)</strong>.<br/><br/>
Acceda a los <a href="#1176">c&#243;digos de las teclas</a> para ver la lista completa de c&#243;digos de teclado que pueden utilizarse como par&#225;metro de la funci&#243;n <strong>key()</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_key;
BEGIN
    LOOP
        delete_text(all_text);

        IF (key(_space)) // Comprobamos si est&#225; pulsada la barra espaciadora

            write(0, 0, 0, 0, &quot;Est&#225; pulsando la tecla [ESPACIO].&quot;);
        ELSE
            write(0, 0, 0, 0, &quot;No est&#225; pulsando la tecla [ESPACIO].&quot;);
        END
        FRAME;
    END
END
</pre>
En el ejemplo se imprime un mensaje u otro dependiendo de que la barra espaciadora est&#233; o no pulsada.<br/><br/>
<hr/>
<br/><br/>
Hay tres variables globales predefinidas que tambi&#233;n pueden utilizarse para el control del teclado; &#233;stas son:<br/><br/>
<a href="#1110">scan_code</a> - C&#243;digo de la &#250;ltima tecla que se ha pulsado; &#233;ste es un valor num&#233;rico que se corresponde directamente con las constantes de <a href="#1176">c&#243;digos de teclas</a> utilizadas como par&#225;metros de la funci&#243;n <strong>key()</strong>.<br/><br/>
<a href="#1109">ascii</a> - C&#243;digo ASCII de la &#250;ltima tecla pulsada.<br/><br/>
<a href="#1108">shift_status</a> - variable que indica un n&#250;mero en funci&#243;n de las teclas especiales o de bloqueo (shift, alt, control, ...) que est&#233;n pulsadas en dicho momento.<br/><br/>
<hr/>
Ver: <a href="#1176">C&#243;digos de teclas</a> - <a href="#1110">scan_code</a> - <a href="#1109">ascii</a> - <a href="#1108">shift_status</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="129">let_me_alone()</h2><br/><br/>
<strong>let_me_alone()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Env&#237;a una se&#241;al <a href="#1153">s_kill</a> a todos los procesos, excepto el que ejecut&#243; esta funci&#243;n, lo que eliminar&#225; a todos los procesos menos el actual.<br/><br/>
Esta funci&#243;n se utiliza, generalmente, desde el proceso principal, cuando ha finalizado una partida, para eliminar todos los procesos (disparos, enemigos, etc.) que quedar&#225;n activos, y recuperar el control del programa.<br/><br/>
Una llamada a <strong>let_me_alone()</strong> se podr&#237;a sustituir siempre por una serie de llamadas a la funci&#243;n <a href="#158">signal()</a> con la se&#241;al <a href="#1153">s_kill</a>, pero para ello se deber&#237;an conocer los tipos de los procesos que se quieren eliminar, o bien, sus <a href="#1039">c&#243;digos identificadores</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_let_me_alone;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    proceso_nulo(160, 100, 100);
    write (0, 160, 0, 1, &quot;Pulse [ESPACIO] para eliminar el proceso&quot;);
    WHILE (NOT key (_space))
        FRAME;
    END

    let_me_alone(); // Se elimina el resto de los procesos

    LOOP
        FRAME;
    END
END

PROCESS proceso_nulo(x, y, graph)
BEGIN
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo, despu&#233;s de crear un proceso de tipo <strong>proceso_nulo</strong>, se espera a la pulsaci&#243;n de la barra espaciadora para utilizar la funci&#243;n <strong>let_me_alone()</strong> la cual elimina todos los procesos que hubiera (menos el principal, que es el que llam&#243; a la funci&#243;n); en este caso se eliminar&#225; el proceso de tipo <strong>proceso_nulo</strong>.<br/><br/>
<hr/>
<br/><br/>
Para poder comprobar los procesos que hay activos en un programa en un determinado momento se debe acceder al trazador (o debugger) pulsando la tecla [<strong>F12</strong>].<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#109">exit()</a> sirve para terminar un programa de forma inmediata, retornando al sistema.<br/><br/>
<hr/>
Ver: <a href="#109">exit()</a> - <a href="#158">signal()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="130">load()</h2><br/><br/>
<strong>load(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;OFFSET dato&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga un bloque de datos de un archivo en el disco a la memoria del programa.<br/><br/>
Para ello la funci&#243;n requiere el <strong>nombre del archivo</strong> y el desplazamiento dentro de la memoria del ordenador de la variable, tabla o estructura guardada en el disco (el desplazamiento del dato se puede obtener con operador <a href="#1085">OFFSET</a>).<br/><br/>
Se debe especificar el desplazamiento del mismo dato que se especific&#243; al guardar el archivo con la funci&#243;n <a href="#155">save()</a>.<br/><br/>
Los nombres de archivo se pueden dar especificando una ruta de acceso, <strong>que debe ser la misma que la utilizada con la funci&#243;n</strong> <a href="#155">save()</a> para guardar el archivo. No obstante <strong>no es necesario</strong> especificar una ruta.<br/><br/>
Es importante que el archivo que se pretende cargar se haya creado anteriormente, pues se producir&#225; un error si se intenta cargar un archivo que no existe (si bien &#233;ste puede ser ignorado y continuar la ejecuci&#243;n del programa).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load;

PRIVATE
    tabla[9];
    contador;

BEGIN
    write (0, 0, 0, 0, &quot;Pulse [ENTER] para borrar los datos.&quot;);
    write (0, 0, 10, 0, &quot;Pulse [ESPACIO] para cargar los datos del disco&quot;);
    write (0, 0, 30, 0, &quot;Valores actuales de los datos:&quot;);
    FROM contador=0 TO 9;
        tabla[contador]=rand(0, 100);
        write_int(0, 0, 40+(contador*10), 0, offset tabla[contador]);
    END
    save(&quot;help\help.dat&quot;, offset tabla, sizeof(tabla));
    LOOP
        IF (key(_enter))
            FROM contador=0 TO 9;
                tabla[contador]=0;
            END
        END
        IF (key(_space))

            load(&quot;help\help.dat&quot;, offset tabla); // Se cargan los datos del disco

        END
        FRAME;
    END
END
</pre>
Al inicio del ejemplo se crea una tabla de 10 posiciones (del 0 al 9) con valores aleatorios. Esta tabla se graba en el disco con la funci&#243;n <a href="#155">save()</a>.<br/><br/>
Cuando se pulsa la tecla ENTER se borran los valores de la tabla (se ponen a 0 las 10 posiciones).<br/><br/>
Cuando se pulsa la barra espaciadora se cargan los valores de la tabla del disco con la funci&#243;n <strong>load()</strong>.<br/><br/>
<hr/>
Ver: <a href="#155">save()</a> - <a href="#1094">sizeof()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="131">load_fnt()</h2><br/><br/>
<strong>load_fnt(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>c&#243;digo de la fuente</strong> cargada.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga un archivo con una nueva fuente de car&#225;cteres (*.FNT) del disco (un &quot;font&quot; con un nuevo juego de car&#225;cteres gr&#225;ficos).<br/><br/>
La funci&#243;n devuelve el <strong>c&#243;digo de fuente</strong> que puede ser utilizado por las funciones <a href="#171">write()</a> y <a href="#172">write_int()</a> para escribir un texto.<br/><br/>
Se puede especificar la ruta de acceso al archivo con la fuente, no obstante, si el archivo con la fuente de letra se ha generado en el directorio por defecto (\FNT) no ser&#225; necesario.<br/><br/>
El archivo con la nueva fuente se tiene que haber creado con la paleta de color del juego para que se visualice correctamente; en caso contrario aparecer&#225;n los colores cambiados.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_fnt;

PRIVATE
    fuente1;

BEGIN

    fuente1=load_fnt(&quot;help\help.fnt&quot;); // Se carga la fuente para el texto

    write(0, 160, 0, 1, &quot;Texto escrito con la fuente del sistema.&quot;);
    write(fuente1, 160, 10, 1, &quot;FUENTE DEL ARCHIVO EN DISCO&quot;);
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo se carga una fuente con la funci&#243;n <strong>load_fnt()</strong>, y despu&#233;s se escriben dos textos con fuentes diferentes. El primero con la fuente del sistema y el segundo, con la fuente cargada del archivo <strong>help.fnt</strong>.<br/><br/>
<hr/>
<br/><br/>
Para descargar de la memoria del ordenador la fuente cargada (liberando el espacio ocupado en memoria por &#233;sta) se debe utilizar la funci&#243;n <a href="#177">unload_fnt()</a>, pasando como par&#225;metro el <strong>c&#243;digo de fuente</strong>.<br/><br/>
<strong>No es necesario</strong> descargar la fuente con esta &#250;ltima funci&#243;n a no ser que se necesite el espacio ocupado para cargar m&#225;s gr&#225;ficos o fuentes, ya que el sistema liberar&#225; la fuente autom&#225;ticamente al finalizar el programa.<br/><br/>
<hr/>
Ver: <a href="#177">unload_fnt()</a> - <a href="#171">write()</a> - <a href="#171">write_int()</a> - <a href="#133">load_pal()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="132">load_fpg()</h2><br/><br/>
<strong>load_fpg(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Retorna el <strong>c&#243;digo del fichero</strong> cargado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga un archivo con un fichero (*.FPG) del disco. Se entiende por un fichero, una librer&#237;a (o colecci&#243;n) de gr&#225;ficos.<br/><br/>
Un archivo FPG con una librer&#237;a de gr&#225;ficos puede contener desde ning&#250;n gr&#225;fico hasta 999 gr&#225;ficos. Cada uno ellos incluidos en la librer&#237;a tendr&#225; un c&#243;digo num&#233;rico, el <strong>c&#243;digo de gr&#225;fico</strong>, que es un n&#250;mero entre <strong>1</strong> y <strong>999</strong> que se utiliza para identificar el gr&#225;fico dentro del fichero.<br/><br/>
Es posible cargar tantos ficheros de gr&#225;ficos como sea necesario, siempre que quede memoria disponible (para cargar varios ficheros se debe llamar varias veces a esta funci&#243;n).<br/><br/>
La funci&#243;n devuelve el <strong>c&#243;digo de fichero</strong>, que puede ser utilizado por m&#250;ltiples funciones que requieren un gr&#225;fico, para lo cual se les debe indicar el <strong>c&#243;digo de fichero</strong> en el que est&#225; el gr&#225;fico y el <strong>c&#243;digo de gr&#225;fico</strong> dentro del fichero.<br/><br/>
Se puede especificar la ruta de acceso al archivo con el fichero de gr&#225;ficos, no obstante, si el fichero est&#225; en el directorio por defecto (\FPG) no ser&#225; necesario.<br/><br/>
<hr/>
<br/><br/>
Cuando se han cargado diferentes ficheros se debe tener en cuenta que si estos tienen paletas diferentes, se debe activar cada una de ellas previamente con la funci&#243;n <a href="#133">load_pal()</a>, indicando el nombre del fichero (FPG) como par&#225;metro, antes de utilizar los gr&#225;ficos del mismo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_fpg;

PRIVATE
    fichero1;

BEGIN

    fichero1 = load_fpg(&quot;help\help.fpg&quot;); // Se  carga el fichero de gr&#225;ficos

    put_screen(fichero1, 1); // Utilizamos el gr&#225;fico 1 del fichero
    write(0, 160, 0, 1, &quot;Fichero de gr&#225;ficos cargado con &#233;xito&quot;);
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo, se carga el fichero de gr&#225;ficos que se va usar en el programa con la funci&#243;n <strong>load_fpg()</strong> y, despu&#233;s, se utiliza el gr&#225;fico n&#250;mero 1 del mismo para ponerlo como fondo en la pantalla (con la funci&#243;n <a href="#148">put_screen()</a>).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#169">unload_fpg()</a> permite liberar la memoria del ordenador utilizada por el fichero de gr&#225;ficos cuando ya no se va a utilizar m&#225;s, y para ello requiere tambi&#233;n el <strong>codigo de fichero</strong> para saber qu&#233; fichero es el que se quiere descargar de memoria.<br/><br/>
<strong>No es necesario descargar el fichero de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
<hr/>
Ver: <a href="#169">unload_fpg()</a> - <a href="#174">load_map/pcx()</a> - <a href="#133">load_pal()</a> - <a href="#1131">file</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="133">load_pal()</h2><br/><br/>
<strong>load_pal(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga una paleta de color de disco (de un archivo PAL, FPG, MAP, PCX o FNT) con la definici&#243;n de los <strong>256 colores</strong> que se visualizan en pantalla.<br/><br/>
A partir de ese momento el juego se ver&#225; con la correspondencia de colores que indica dicha paleta.<br/><br/>
Si en el momento de cargar la paleta el programa ten&#237;a asignada ya otra diferente, entonces se realizar&#225; un fundido de los colores de la pantalla a negro para despu&#233;s ir introduciendo, en los siguientes fotogramas del juego, la nueva paleta de color de forma gradual.<br/><br/>
Se puede especificar la ruta de acceso al archivo con la paleta; no obstante, si el fichero est&#225; en el directorio por defecto (que dependiendo del tipo de archivo &#233;ste ser&#225;: \PAL, \FPG, \MAP, \PCX o \FNT) no ser&#225; necesario.<br/><br/>
El programa leer&#225; la paleta autom&#225;ticamente del primero de estos tipos de archivos que se carguen en el programa, aunque no se utilice la funci&#243;n <strong>load_pal()</strong>. Luego, esta funci&#243;n se utiliza cuando el programa usa varias paletas diferentes para cambiar de una a otra.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_pal;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write(0, 160, 0, 1, &quot;Pulse [ESPACIO] para cargar una paleta diferente.&quot;);
    write(0, 160, 10, 1, &quot;Pulse [ENTER] para cargar la paleta original.&quot;);
    LOOP
        IF (key(_space))

            load_pal(&quot;help\help.pal&quot;); // Se carga una paleta de un fichero .pal

        END
        IF (key(_enter))

            load_pal(&quot;help\help.fpg&quot;);  // Se carga una paleta de un fichero .fpg

        END
        FRAME;
    END
END
</pre>
En el ejemplo, al inicio se carga un fichero de gr&#225;ficos, se pone un fondo de pantalla y se imprimen los mensajes necesarios.<br/><br/>
En el bucle principal del programa se carga una paleta diferente (de <strong>help.pal</strong>) cuando se pulsa la barra espaciadora y la paleta original (de <strong>help.fpg</strong>) al pulsar la tecla ENTER.<br/><br/>
<hr/>
<br/><br/>
Una paleta no se puede descargar de la memoria del ordenador, ya que &#233;sta no ocupa espacio en la memoria.<br/><br/>
<hr/>
Ver: <a href="#174">load_map/pcx()</a> - <a href="#132">load_fpg()</a> - <a href="#131">load_fnt()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="134">load_pcm() / load_wav()</h2><br/><br/>
<strong>load_pcm(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;c&#237;clico&gt;<strong>)</strong><br/><br/>
<strong>load_wav(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;c&#237;clico&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>c&#243;digo del sonido</strong> cargado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga un efecto de sonido de un archivo PCM o WAV del disco. Se debe indicar el nombre del archivo con el efecto de sonido como primer par&#225;metro y en &lt;c&#237;clico&gt;, como segundo par&#225;metro, <strong>1</strong> si es un sonido que se debe tocar repiti&#233;ndose indefinidamente, o <strong>0</strong> si debe sonar s&#243;lo una vez (cuando se solicite con la funci&#243;n <a href="#159">sound()</a>).<br/><br/>
La funci&#243;n devuelve el <strong>c&#243;digo del sonido</strong> que debe ser utilizado por la funci&#243;n <a href="#159">sound()</a> para hacer que suene por un canal dicho sonido.<br/><br/>
Se puede especificar la ruta de acceso al archivo con el sonido, no obstante, si el sonido est&#225; en el directorio por defecto (\PCM o \WAV) no ser&#225; necesario.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_pcm;

PRIVATE
    id_sonido;

BEGIN

    id_sonido = load_pcm(&quot;help\help.pcm&quot;, 0); // Carga un sonido del disco duro

    write(0, 160, 0, 1, &quot;Presione [ESPACIO] para ejecutar el sonido.&quot;);
    LOOP
        IF (scan_code==_space)
            sound(id_sonido, 100, 256);
        END
        FRAME;
    END
END
</pre>
En el ejemplo primeramente se carga un sonido con la funci&#243;n <strong>load_pcm()</strong>. Luego, en el bucle principal, cada vez que se pulsa la barra espaciadora se ejecuta dicho sonido con la funci&#243;n <a href="#159">sound()</a>.<br/><br/>
<hr/>
<br/><br/>
La funciones <a href="#170">unload_pcm()</a> y <a href="#170">unload_wav()</a> permiten liberar la memoria del ordenador utilizada por el sonido cuando ya no se va a utilizar m&#225;s y, para ello, requiere tambi&#233;n el <strong>codigo del sonido</strong> para saber qu&#233; sonido es el que se quiere descargar de memoria.<br/><br/>
<strong>No es necesario descargar el sonido de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
<hr/>
Ver: <a href="#170">unload_pcm/wav()</a> - <a href="#159">sound()</a> - <a href="#102">change_sound()</a> - <a href="#1104">Estructura setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="135">map_block_copy()</h2><br/><br/>
<strong>map_block_copy(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico destino&gt;<strong>,</strong> &lt;x destino&gt;<strong>,</strong> &lt;y destino&gt;<strong>,</strong>                  &lt;gr&#225;fico origen&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;ancho&gt;<strong>,</strong> &lt;alto&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
La funci&#243;n <strong>map_block_copy()</strong> permite transferir un bloque rectangular de un gr&#225;fico a otro.<br/><br/>
El gr&#225;fico del cual se toma la regi&#243;n rectangular se denomina &lt;gr&#225;fico origen&gt; y el <strong>gr&#225;fico destino</strong> es en el que se copiar&#225; dicho bloque, es decir, esta funci&#243;n permite copiar un trozo de un gr&#225;fico (origen) a otro (destino). Los par&#225;metros son, por orden, los siguientes:<br/><br/>
<strong>&lt;fichero&gt;</strong> - Ambos gr&#225;ficos deben provenir del mismo fichero de gr&#225;ficos. Como primer par&#225;metro se debe especificar el <strong>c&#243;digo del fichero</strong> (ver <a href="#132">load_fpg()</a>). Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>&lt;gr&#225;fico destino&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> en el que se va a poner el bloque.<br/><br/>
<strong>&lt;x destino&gt;, &lt;y destino&gt;</strong> - coordenadas (<strong>x</strong>, <strong>y</strong>) en las que se quiere poner el bloque dentro del gr&#225;fico destino.<br/><br/>
<strong>&lt;gr&#225;fico origen&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> del que se va a tomar el bloque.<br/><br/>
<strong>&lt;x&gt;, &lt;y&gt;</strong> - coordenadas de <strong>inicio</strong> del bloque dentro del gr&#225;fico origen.<br/><br/>
<strong>&lt;ancho&gt;, &lt;alto&gt;</strong> - <strong>dimensiones</strong> del bloque que se va a transferir.<br/><br/>
Esta funci&#243;n modificar&#225; el gr&#225;fico indicado, pero s&#243;lo la copia del mismo que se ha cargado en la memoria del ordenador. El gr&#225;fico original, que est&#225; en el archivo <strong>FPG</strong>, <strong>MAP</strong> o <strong>PCX</strong> del disco, <strong>permanecer&#225; inalterado</strong>. Por ello si se quiere en un momento del juego recuperar el estado original del gr&#225;fico se tiene que descargar de memoria (con <a href="#169">unload_fpg()</a>, <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>) y despu&#233;s volverlo a cargar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_map_block_copy;

PRIVATE
    x_destino, y_destino;
    x_origen, y_origen;
    ancho, alto;
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 320);
        y_destino=rand(0, 200);
        ancho=rand(1, 32);
        alto=rand(1, 32);
        x_origen=rand(0, 32-ancho);
        y_origen=rand(0, 32-alto);

        map_block_copy(fichero1, 1, x_destino, y_destino, 100, x_origen, y_origen, ancho, alto);

        FRAME;
        angle+=1000;
    END
END
</pre>
En el ejemplo, despu&#233;s de cargar el fichero de gr&#225;ficos y poner uno ( el gr&#225;fico n&#250;mero 1) el centro de pantalla va rotando cont&#237;nuamente. En el bucle principal, se va copiando el gr&#225;fico de una bola (el gr&#225;fico n&#250;mero 100) dentro del gr&#225;fico destino (el n&#250;mero 1) en unas coordenadas elegidas aleatoriamente.<br/><br/>
<hr/>
<br/><br/>
Cuando se ponga un gr&#225;fico en otro que se est&#233; utilizando como fondo para una regi&#243;n de scroll, &#233;ste no aparecer&#225; autom&#225;ticamente en pantalla a no ser que se utilice la funci&#243;n <a href="#152">refresh_scroll()</a>.<br/><br/>
<hr/>
Ver: <a href="#139">map_xput()</a> - <a href="#137">map_put()</a> - <a href="#138">map_put_pixel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="136">map_get_pixel()</h2><br/><br/>
<strong>map_get_pixel(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El color del punto (0..255).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Permite obtener, como valor de retorno de la funci&#243;n, el color de un punto determinado de un gr&#225;fico. Para ello requiere el &lt;c&#243;digo del fichero&gt; en el que se encuentra el gr&#225;fico, el &lt;c&#243;digo del gr&#225;fico&gt; dentro del fichero y las coordenadas (<strong>x</strong>, <strong>y</strong>) del punto del gr&#225;fico cuyo color se quiere obtener.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_map_get_pixel;

PRIVATE
    fichero1;
    figura;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 7);
    mouse.graph=200;
    write(0, 0, 0, 0, &quot;FIGURA:&quot;);
    write_int(0, 42, 0, 0, offset figura);
    LOOP

        // Cogemos el color del punto del mapa del bits
        figura = map_get_pixel(fichero1, 8, mouse.x, mouse.y);

        FRAME;
    END
END
</pre>
En el ejemplo se pone como fondo de pantalla una imagen con 6 figuras geom&#233;tricas diferentes, todas ellas del mismo color, y el gr&#225;fico del rat&#243;n se define como una peque&#241;a cruz.<br/><br/>
La imagen de fondo se corresponde directamente con otro gr&#225;fico, el n&#250;mero 8 del fichero, el cual tiene las mismas figuras aunque cada una de un color diferente (la primera de color 1, la segunda de color 2, etc.).<br/><br/>
En el bucle principal se tomar&#225; un color de este segundo gr&#225;fico con la funci&#243;n <strong>map_get_pixel()</strong>, de las coordenadas que indique el cursor del rat&#243;n.<br/><br/>
En la esquina superior izquierda de la pantalla el valor obtenido con la funci&#243;n, que es un n&#250;mero del 1 al 6 que indica el n&#250;mero de figura.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n se suele utilizar para la detecci&#243;n de zonas dentro de gr&#225;ficos. Esta t&#233;cnica se denomina <strong>mapas de durezas</strong> y consiste en utilizar dos gr&#225;ficos diferentes, uno con el dibujo en s&#237; y otro con las zonas a detectar pintadas de diferentes colores.<br/><br/>
Por ejemplo, en un juego de naves se podr&#237;an pintar en este <strong>mapa de durezas</strong> las zonas que le quitan energ&#237;a a la nave cuando pasa por ellas con un color (por ejemplo, el color 32); despu&#233;s se obtendr&#237;a el color del <strong>mapa de durezas</strong> sobre el que est&#225; la nave, y si es 32, se le restar&#237;a energ&#237;a.<br/><br/>
Es decir, habr&#237;a dos dibujos diferentes: uno en colores, que es el dibujo de fondo por el que se mueve la nave en el juego (el visible), y otro, el <strong>mapa de durezas</strong> que se utilizar&#237;a &#250;nicamente para obtener colores de &#233;l con la funci&#243;n <strong>map_get_pixel()</strong> y, de esta forma, identificar la zona del dibujo original sobre el que est&#225; la nave.<br/><br/>
<hr/>
Ver: <a href="#123">get_pixel()</a> - <a href="#138">map_put_pixel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="137">map_put()</h2><br/><br/>
<strong>map_put(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico destino&gt;<strong>,</strong> &lt;gr&#225;fico origen&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Pone un gr&#225;fico en otro. El gr&#225;fico que se va a copiar se denomina &lt;gr&#225;fico origen&gt; y el <strong>gr&#225;fico destino</strong> es en el que se copiar&#225; el origen, es decir, esta funci&#243;n permite copiar un gr&#225;fico (origen) a otro (destino).<br/><br/>
Ambos gr&#225;ficos deben estar en el mismo fichero. Los par&#225;metros son, por orden, los siguientes:<br/><br/>
<strong>&lt;fichero&gt;</strong> - <strong>c&#243;digo del fichero</strong> con la librer&#237;a de gr&#225;ficos que contiene a ambos. Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>&lt;gr&#225;fico destino&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> en el que se va a poner el otro.<br/><br/>
<strong>&lt;gr&#225;fico origen&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> que va a ser copiado en el destino.<br/><br/>
<strong>&lt;x&gt;, &lt;y&gt;</strong> - <strong>coordenadas dentro del gr&#225;fico destino</strong> donde se desea poner el gr&#225;fico origen. En estas coordenadas es donde se situar&#225; el centro (o <a href="#1136">punto de control</a> n&#250;mero 0) del gr&#225;fico origen.<br/><br/>
Esta funci&#243;n modificar&#225; el gr&#225;fico indicado, pero s&#243;lo la copia del mismo que se ha cargado en la memoria del ordenador. El gr&#225;fico original, que est&#225; en el archivo <strong>FPG</strong>, <strong>MAP</strong> o <strong>PCX</strong> del disco, <strong>permanecer&#225; inalterado</strong>. Por ello si se quiere en un momento del juego recuperar el estado original del gr&#225;fico se tiene que descargar de memoria (con <a href="#169">unload_fpg()</a>, <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>) y despu&#233;s volverlo a cargar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_map_put;

PRIVATE
    x_destino;
    y_destino;
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 320);
        y_destino=rand(0, 200);

        map_put(fichero1, 1, 100, x_destino, y_destino);

        angle+=1000;
        FRAME;
    END
END
</pre>
En el ejemplo se pone el gr&#225;fico n&#250;mero 1 en el centro de la pantalla.<br/><br/>
En cada paso del bucle principal se gira este gr&#225;fico y se pone, con la funci&#243;n <strong>map_put()</strong>, un gr&#225;fico n&#250;mero 100 (una bola) dentro del gr&#225;fico 1 (el gr&#225;fico central).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#139">map_xput()</a> es una versi&#243;n un poco m&#225;s compleja de la funci&#243;n <strong>map_put()</strong>, pero con muchas m&#225;s posibilidades, pues permite, adem&#225;s, poner gr&#225;ficos rotados, escalados, espejados y transparentes.<br/><br/>
Para poner una parte de un gr&#225;fico en otro (en lugar de poner el gr&#225;fico completo) se debe utilizar la funci&#243;n <a href="#135">map_block_copy()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Cuando se utilice la funci&#243;n <strong>map_put()</strong> (o cualquier otra similar) para modificar un gr&#225;fico que se est&#225; utilizando como fondo de una ventana de <strong>scroll</strong>, puede que el gr&#225;fico puesto no aparezca de forma inmediata en pantalla; para solventar este problema se debe utilizar la funci&#243;n <a href="#152">refresh_scroll()</a>.<br/><br/>
<hr/>
Ver: <a href="#139">map_xput()</a> - <a href="#138">map_put_pixel()</a> - <a href="#152">refresh_scroll()</a> - <a href="#135">map_block_copy()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="138">map_put_pixel()</h2><br/><br/>
<strong>map_put_pixel(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;color&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Permite modificar el color de un punto determinado de un gr&#225;fico. Para ello requiere el &lt;c&#243;digo del fichero&gt; en el que se encuentra el gr&#225;fico, el &lt;c&#243;digo del gr&#225;fico&gt; dentro del fichero y las coordenadas (<strong>x</strong>, <strong>y</strong>) del punto cuyo &lt;color&gt; se quiere establecer.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
Esta funci&#243;n modificar&#225; el gr&#225;fico indicado, pero s&#243;lo la copia del mismo que se ha cargado en la memoria del ordenador. El gr&#225;fico original, que est&#225; en el archivo <strong>FPG</strong>, <strong>MAP</strong> o <strong>PCX</strong> del disco, <strong>permanecer&#225; inalterado</strong>. Por ello si se quiere en un momento del juego recuperar el estado original del gr&#225;fico se tiene que descargar de memoria (con <a href="#169">unload_fpg()</a>, <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>) y despu&#233;s volverlo a cargar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_map_put_pixel;
PRIVATE
    fichero1;
    coord_x;
    coord_y;
    color;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    graph=5;
    x=160;
    y=100;
    size=180;
    LOOP
        coord_x=rand(0, 199);
        coord_y=rand(0, 199);
        color=rand(0, 15);

        // Se ponen puntos en el gr&#225;fico n&#250;mero 5 del fichero1
        map_put_pixel(fichero1, 5, coord_x, coord_y, color);

        angle+=2000;
        FRAME;
    END
END
</pre>
En el ejemplo, se pone el gr&#225;fico n&#250;mero 5 en el centro de la pantalla rotando cont&#237;nuamente; este gr&#225;fico es un fondo completamente negro, por ello inicialmente no se ver&#225; nada en pantalla.<br/><br/>
Pero despu&#233;s, en cada paso del bucle se ponen en &#233;l puntos de un color elegido al azar entre el 0 y el 15 (grises) en unas coordenadas tambi&#233;n elegidas al azar.<br/><br/>
Estos puntos se ponen usando la funci&#243;n <strong>map_put_pixel()</strong>.<br/><br/>
Se puede observar c&#243;mo parece que hay cada vez m&#225;s puntos girando en pantalla cuando, en realidad, lo &#250;nico que gira es el gr&#225;fico n&#250;mero 5.<br/><br/>
<hr/>
<br/><br/>
Para poner un gr&#225;fico completo en otro, y no s&#243;lo en un punto, se pueden utilizar las funciones <a href="#137">map_put()</a> o <a href="#139">map_xput()</a>, y para poner s&#243;lo una parte de un gr&#225;fico en otro se puede utilizar la funci&#243;n <a href="#135">map_block_copy()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Cuando se utilice la funci&#243;n <strong>map_put_pixel()</strong> para poner un punto en un gr&#225;fico que se est&#225; utilizando como fondo de una ventana de <strong>scroll</strong>, puede que el punto puesto no aparezca de forma inmediata en pantalla; para solventar este problema se debe utilizar la funci&#243;n <a href="#152">refresh_scroll()</a>.<br/><br/>
<hr/>
Ver: <a href="#137">map_put()</a> - <a href="#139">map_xput()</a> - <a href="#152">refresh_scroll()</a> - <a href="#135">map_block_copy()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="139">map_xput()</h2><br/><br/>
<strong>map_xput(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico destino&gt;<strong>,</strong> &lt;gr&#225;fico origen&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong>            &lt;angle&gt;<strong>,</strong> &lt;size&gt;<strong>,</strong> &lt;flags&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Versi&#243;n extendida de la funci&#243;n <a href="#137">map_put()</a>.<br/><br/>
Pone un gr&#225;fico en otro. El gr&#225;fico que se va a copiar se denomina &lt;gr&#225;fico origen&gt; y el <strong>gr&#225;fico destino</strong> es en el que se copiar&#225; el origen, es decir, esta funci&#243;n permite copiar un gr&#225;fico (origen) a otro (destino).<br/><br/>
Ambos gr&#225;ficos deben estar en el mismo fichero. Los par&#225;metros son, por orden, los siguientes:<br/><br/>
<strong>&lt;fichero&gt;</strong> - <strong>c&#243;digo del fichero</strong> con la librer&#237;a de gr&#225;ficos que contiene a ambos. Los gr&#225;ficos cargados con la funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>&lt;gr&#225;fico destino&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> en el que se va a poner el otro.<br/><br/>
<strong>&lt;gr&#225;fico origen&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> que va a ser copiado en el destino.<br/><br/>
<strong>&lt;x&gt;, &lt;y&gt;</strong> - coordenadas dentro del gr&#225;fico destino donde se desea poner el gr&#225;fico origen. En estas coordenadas es donde se copiar&#225; el gr&#225;fico origen a partir de su esquina superior izquierda.<br/><br/>
<strong>&lt;angle&gt;</strong> - &#225;ngulo (en mil&#233;simas de grados) en el que se copiar&#225; el gr&#225;fico origen, el &#225;ngulo normal es <strong>0</strong>.<br/><br/>
<strong>&lt;size&gt;</strong> - tama&#241;o (en porcentaje) en el que se copiar&#225; el gr&#225;fico original, el tama&#241;o normal es <strong>100</strong>.<br/><br/>
<strong>&lt;flags&gt;</strong> - Indica los espejados y transparencias con los que se copiar&#225; el gr&#225;fico original en el destino; los valores son:<br/><br/>
<strong>0</strong>-Gr&#225;fico normal.<br/>
<strong>1</strong>-Espejado horizontal.<br/>
<strong>2</strong>-Espejado vertical.<br/>
<strong>3</strong>-Espejado horizontal y vertical (180&#176;).<br/>
<strong>4</strong>-Gr&#225;fico transparente.<br/>
<strong>5</strong>-Transparente y espejado horizontal.<br/>
<strong>6</strong>-Transparente y espejado vertical.<br/>
<strong>7</strong>-Transparente, espejado horizontal y vertical.<br/>
<br/><br/>
Esta funci&#243;n modificar&#225; el gr&#225;fico indicado, pero s&#243;lo la copia del mismo que se ha cargado en la memoria del ordenador. El gr&#225;fico original, que est&#225; en el archivo <strong>FPG</strong>, <strong>MAP</strong> o <strong>PCX</strong> del disco, <strong>permanecer&#225; inalterado</strong>. Por ello, si se quiere en un momento del juego recuperar el estado original del gr&#225;fico se tiene que descargar de memoria (con <a href="#169">unload_fpg()</a>, <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>) y despu&#233;s volverlo a cargar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_map_xput;
PRIVATE
    x_destino;
    y_destino;
    fichero1;
    &#225;ngulo1;
    tama&#241;o1;
    banderas1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    graph=1;
    x=160;
    y=100;
    LOOP
        x_destino=rand(0, 319);
        y_destino=rand(0, 199);
        &#225;ngulo1=rand(-pi, pi);
        tama&#241;o1=rand(10, 200);
        banderas1=rand(0, 7);

        map_xput(fichero1, 1, 101, x_destino, y_destino, &#225;ngulo1, tama&#241;o1, banderas1);

        angle+=2000;
        FRAME;
    END
END
</pre>
En el ejemplo, se pone el gr&#225;fico 1 en el centro de la pantalla rotando cont&#237;nuamente (este gr&#225;fico es un fondo decorativo en grises).<br/><br/>
En cada paso del bucle se pondr&#225; dentro de &#233;l otro gr&#225;fico con forma de tri&#225;ngulo (con el n&#250;mero 100). Este gr&#225;fico se pondr&#225; con coordenadas, &#225;ngulo, tama&#241;o y banderas (ver variable <a href="#1127">flags</a>) elegidas de forma aleatoria.<br/><br/>
Se puede observar c&#243;mo en el gr&#225;fico de fondo van apareciendo cont&#237;nuamente tri&#225;ngulos de color marr&#243;n con diferentes efectos aplicados.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <strong>map_xput()</strong> es una versi&#243;n un poco m&#225;s compleja de la funci&#243;n <a href="#137">map_put()</a>, siendo &#233;sta m&#225;s f&#225;cil de utilizar cuando no se requiera poner gr&#225;ficos rotados, escalados, espejados y transparentes.<br/><br/>
Para poner una parte de un gr&#225;fico en otro (en lugar de poner el gr&#225;fico completo) se debe utilizar la funci&#243;n <a href="#135">map_block_copy()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Cuando se utilice la funci&#243;n <strong>map_xput()</strong> (o cualquier otra similar) para modificar un gr&#225;fico que se est&#225; utilizando como fondo de una ventana de <strong>scroll</strong>, puede que el gr&#225;fico puesto no aparezca de forma inmediata en pantalla; para solventar este problema se debe utilizar la funci&#243;n <a href="#152">refresh_scroll()</a>.<br/><br/>
<hr/>
Ver: <a href="#137">map_put()</a> - <a href="#138">map_put_pixel()</a> - <a href="#152">refresh_scroll()</a> - <a href="#135">map_block_copy()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="140">move_scroll()</h2><br/><br/>
<strong>move_scroll(</strong>&lt;n&#250;mero de scroll&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Fuerza a mover un scroll autom&#225;tico de forma inmediata. Esta es una funci&#243;n algo avanzada y por ello puede resultar dif&#237;cil de comprender su prop&#243;sito.<br/><br/>
La funci&#243;n requiere como par&#225;metro el &lt;n&#250;mero de scroll&gt; de 0 a 9 que se indic&#243; en la funci&#243;n <a href="#163">start_scroll()</a> como primer par&#225;metro cuando se inici&#243; el scroll.<br/><br/>
Esta funci&#243;n se utiliza cuando una regi&#243;n de scroll se controla autom&#225;ticamente, por haber definido el campo <strong>camera</strong> de la <a href="#1101">estructura scroll</a> correspondiente con el identificador de un proceso.<br/><br/>
El prop&#243;sito es forzar a que se actualicen los valores (<strong>x0</strong>, <strong>y0</strong>, <strong>x1</strong> y <strong>y1</strong>) de dicha estructura; si no se utiliza esta funci&#243;n estos valores no se actualizar&#225;n hasta la pr&#243;xima imagen del juego.<br/><br/>
Es decir, cuando un scroll se controla de forma autom&#225;tica y otro proceso necesita conocer antes de la pr&#243;xima imagen el valor de las coordenadas de dicho scroll (normalmente para colocarse &#233;l en una posici&#243;n acorde al movimiento del fondo) se debe hacer esto:<br/><br/>
<strong>1</strong> - Se inicia el scroll con <a href="#163">start_scroll()</a>.<br/><br/>
<strong>2</strong> - Se crea el proceso que se utilizar&#225; como c&#225;mara y se pone su <a href="#1039">c&#243;digo identificador</a> en el campo <strong>camera</strong> de la <a href="#1101">estructura scroll</a>.<br/><br/>
<strong>3</strong> - A este proceso se le debe poner una prioridad muy alta, para que se ejecute antes que el resto de los procesos (poniendo en su variable local <a href="#1121">priority</a> un valor entero positivo como, por ejemplo, 100).<br/><br/>
<strong>4</strong> - Justo antes de la sentencia <a href="#1029">FRAME</a> del bucle del proceso usado como c&#225;mara se llamar&#225; a la funci&#243;n <strong>move_scroll()</strong>.<br/><br/>
De esta forma se garantizar&#225; que este proceso se ejecute el primero y, justo al finalizar, actualice los valores (<strong>x0</strong>, <strong>y0</strong>, <strong>x1</strong> y <strong>y1</strong>) de la <a href="#1101">estructura scroll</a>, de forma que el resto de los procesos puedan utilizar estas variables ya actualizadas.<br/><br/>
El uso m&#225;s generalizado de esta funci&#243;n es cuando en una ventana de scroll se quieren tener m&#225;s de dos planos de fondo y, para ello, se crean una serie de procesos que simulen un tercer o cuarto plano, situando sus coordenadas en funci&#243;n de la posici&#243;n exacta del scroll en cada imagen. A continuaci&#243;n se muestra un programa que lo hace.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_move_scroll;

PRIVATE
    fichero1;
    contador;

BEGIN
    set_fps(100, 0);
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    start_scroll(0, fichero1, 103, 102, 0, 15);
    scroll.camera=id;
    priority=100;
    FROM contador=-2000 TO 2000 step 100;
        proceso_m&#243;vil(contador);
    END
    write(0, 160, 0, 1, &quot;Utilice cursor derecha e izquierda para moverse&quot;);
    graph=101;
    ctype=c_scroll;
    LOOP
        if (key(_right))
            x+=2;
            flags=0;
        END
        if (key(_left))
            x-=2;
            flags=1;
        END

        move_scroll(0); // Actualiza la estructura scroll[]

        FRAME;
    END
END

PROCESS proceso_m&#243;vil(x_scroll)
BEGIN
    ctype=c_scroll;
    z=100;
    graph=104;
    LOOP
        x=x_scroll-scroll.x0;
        FRAME;
    END
END
</pre>
Este ejemplo inicia un scroll a pantalla completa con dos planos y despu&#233;s mueve un tri&#225;ngulo hacia la derecha e izquierda con los cursores; este proceso ser&#225; la c&#225;mara del scroll, centr&#225;ndose la visi&#243;n en el mismo de forma autom&#225;tica (al poner <strong>scroll.camera=</strong><a href="#1092">id</a><strong>;</strong>).<br/><br/>
Pero, adem&#225;s, crea un total de 40 procesos (de -2000 hasta 2000, cada 100 puntos) con el dibujo de una banda vertical de colores que se mover&#225;n como si fueran un tercer plano de scroll (procesos de tipo <strong>proceso_m&#243;vil</strong>).<br/><br/>
Para ello, es importante que su <strong>z</strong> sea superior al resto de los procesos (<strong>z=100;</strong>) y que la prioridad del proceso que controla la c&#225;mara sea mayor (<strong>priority=100;</strong>) y este &#250;ltimo utilice la funci&#243;n <strong>move_scroll()</strong> antes de cada imagen (<strong>FRAME;</strong>).<br/><br/>
Los procesos que simula el tercer plano (<strong>proceso_m&#243;vil</strong>), sit&#250;an su coordenada <strong>x</strong> en funci&#243;n de la <strong>x del scroll</strong> y su posici&#243;n original.<br/><br/>
La diferencia es que si no se hubiera utilizado <strong>move_scroll()</strong>, al utilizar los procesos la variable <strong>scroll.x0</strong> sin actualizar, se mover&#237;an con un cierto retraso que restar&#237;a verosimilitud al juego.<br/><br/>
<hr/>
Ver: <a href="#163">start_scroll()</a> - <a href="#1101">Estructura scroll</a> - <a href="#1121">priority</a> - <a href="#1125">z</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="141">move_text()</h2><br/><br/>
<strong>move_text(</strong>&lt;identificador del texto&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Mueve un texto a otras coordenadas de pantalla. Se especifica como par&#225;metro el <strong>identificador del texto</strong> que es un c&#243;digo num&#233;rico que devuelve las funciones <a href="#171">write()</a> y <a href="#172">write_int()</a> cuando se les pide que escriban un texto, y las coordenadas (<strong>x</strong>, <strong>y</strong>) de pantalla a las que se debe mover el texto.<br/><br/>
El <strong>c&#243;digo de centrado</strong> especificado en el <a href="#171">write()</a> o <a href="#172">write_int()</a> se mantendr&#225; cuando se utilice esta funci&#243;n.<br/><br/>
Las coordenadas especificadas son siempre relativas a la pantalla y pueden estar dentro o fuera de la misma. Para modificar la <strong>coordenada z de los textos</strong> (el plano de profundidad en el que aparecen) se debe utilizar la variable global <a href="#1106">text_z</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_move_text;

PRIVATE
    id_texto1;
    id_texto2;
    coord_x;
    coord_y;
    &#225;ngulo1;

BEGIN
    id_texto1=write(0, 160, 100, 4, &quot;TEXTO EN MOVIMIENTO&quot;);
    id_texto2=write(0, 160, 100, 4, &quot;MUEVA EL RATON&quot;);
    LOOP
        coord_x=160+get_distx(&#225;ngulo1, 100);
        coord_y=100+get_disty(&#225;ngulo1, 90);

        // Movemos los textos
        move_text(id_texto1, coord_x, coord_y);
        move_text(id_texto2, mouse.x, mouse.y);

        &#225;ngulo1+=1000;
        FRAME;
    END
END
</pre>
En el ejemplo se imprimen dos texto con la funci&#243;n <a href="#171">write()</a> en el centro de la pantalla. Esta funci&#243;n nos devuelve los identificadores de dichos textos, que se guardan en las variables <strong>id_texto1</strong> e <strong>id_texto2</strong>.<br/><br/>
En cada paso de bucle, se mueve el primer el texto por una trayectoria circular que se consigue incrementando un &#225;ngulo (<strong>&#225;ngulo1</strong>) y utilizando las funciones <a href="#118">get_distx()</a> y <a href="#119">get_disty()</a>. El segundo texto se situar&#225; en las coordenadas del puntero del rat&#243;n.<br/><br/>
Ambos textos se mueven en cada imagen mediante la funci&#243;n <strong>move_text()</strong>.<br/><br/>
<hr/>
<br/><br/>
Para borrar un texto definitivamente tambi&#233;n se requiere el <strong>identificador del texto</strong>, y se debe utilizar para ello la funci&#243;n <a href="#107">delete_text()</a>.<br/><br/>
<hr/>
Ver: <a href="#171">write()</a> - <a href="#172">write_int()</a> - <a href="#107">delete_text()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="142">near_angle()</h2><br/><br/>
<strong>near_angle(</strong>&lt;&#225;ngulo&gt;<strong>,</strong> &lt;&#225;ngulo final&gt;<strong>,</strong> &lt;incremento&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Un nuevo &#225;ngulo m&#225;s pr&#243;ximo al &#225;ngulo final.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Acerca un &#225;ngulo a otro en el incremento dado. La funci&#243;n devuelve el nuevo &#225;ngulo.<br/><br/>
Se utiliza cuando se quiere que un &#225;ngulo (&lt;&#225;ngulo&gt;) var&#237;e gradualmente hasta convertirse en otro (&lt;&#225;ngulo final&gt;); para ello, la funci&#243;n necesita el &#225;ngulo original, el <strong>&#225;ngulo final</strong> y el <strong>incremento</strong> angular que se le va a ir sumando o restando al &#225;ngulo original.<br/><br/>
Se recuerda que todos los &#225;ngulos se especifican en mil&#233;simas de grado. El <strong>incremento</strong> angular no es m&#225;s que un &#225;ngulo peque&#241;o, como pudiera ser un grado (<strong>1000</strong>) o cinco (<strong>5000</strong>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_near_angle;

PRIVATE
    &#225;ngulo2;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    mouse.graph=200;
    graph=101;
    write(0, 160, 200, 7, &quot;Mueva el cursor del rat&#243;n&quot;);
    LOOP
        &#225;ngulo2=fget_angle(x, y, mouse.x, mouse.y);

        // Acerca el &#225;ngulo actual al final en 10 grados como m&#225;ximo
        angle = near_angle(angle, &#225;ngulo2, 10000);

        advance(6);
        FRAME;
    END
END
</pre>
En el ejemplo se define el cursor del rat&#243;n como una peque&#241;a cruz que el usuario puede mover.<br/><br/>
El programa principal define su gr&#225;fico como un tri&#225;ngulo (<strong>graph=101;</strong>) que, en cada iteraci&#243;n del bucle, obtiene el &#225;ngulo hacia el cursor del rat&#243;n con la funci&#243;n <a href="#113">fget_angle()</a>; despu&#233;s modifica su &#225;ngulo para que se acerque un m&#225;ximo de 10 grados (10000) hacia el &#225;ngulo del cursor, utilizando la funci&#243;n <strong>near_angle()</strong> y, por &#250;ltimo, avanza 6 puntos en esa direcci&#243;n utilizando la funci&#243;n <a href="#101">advance()</a>.<br/><br/>
Se puede observar c&#243;mo el tri&#225;ngulo persigue cont&#237;nuamente al cursor del rat&#243;n sin realizar ning&#250;n giro brusco (de m&#225;s de 10 grados).<br/><br/>
<hr/>
Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#1129">angle</a> - <a href="#116">get_angle()</a> - <a href="#113">fget_angle()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="143">out_region()</h2><br/><br/>
<strong>out_region(</strong>&lt;c&#243;digo identificador&gt;<strong>,</strong> &lt;n&#250;mero de regi&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>Cierto</strong> si el proceso est&#225; fuera de la regi&#243;n o <strong>Falso</strong> en caso contrario.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n determina si un proceso est&#225; fuera de una regi&#243;n de pantalla, para ello la funci&#243;n requiere el <a href="#1039">c&#243;digo identificador</a> del proceso y un n&#250;mero de regi&#243;n.<br/><br/>
Las regiones de pantalla se pueden definir con la funci&#243;n <a href="#106">define_region()</a> y son, simplemente, zonas rectangulares de pantalla.<br/><br/>
La regi&#243;n n&#250;mero <strong>0</strong> no se puede definir ya que ser&#225; siempre la pantalla completa, por lo tanto, si se especifica un <strong>0</strong> como segundo par&#225;metro esta funci&#243;n determina si un proceso est&#225; fuera de la pantalla (si no se ve).<br/><br/>
En el caso de que el gr&#225;fico del proceso est&#233; fuera de la regi&#243;n especificada la funci&#243;n devuelve <strong>Cierto</strong> (un n&#250;mero impar); en cambio si el gr&#225;fico se ve, aunque sea parcialmente, en dicha regi&#243;n, la funci&#243;n devuelve <strong>Falso</strong> (cualquier n&#250;mero par).<br/><br/>
El proceso cuyo <a href="#1039">c&#243;digo identificador</a> se indica debe tener definido correctamente su gr&#225;fico (normalmente en su variable <a href="#1026">graph</a>) pues, de lo contrario, el sistema advertir&#225; un error ya que si el proceso no tiene un gr&#225;fico, no se pueden calcular las dimensiones del mismo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_out_region;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    y=100;
    x=160;
    graph=101;
    LOOP
        advance(8);

        IF (out_region(id, 0)) // Se comprueba si se sale de pantalla

            x=160;
            y=100;
            angle=rand(-pi, pi);
        END
        FRAME;
    END
END
</pre>
En el ejemplo se pone un gr&#225;fico de fondo y el programa principal crea un gr&#225;fico en el centro de la pantalla con un &#225;ngulo aleatorio y en forma de tri&#225;ngulo.<br/><br/>
En cada paso del bucle el tri&#225;ngulo avanza y se comprueba si ha salido de la pantalla (region 0) con la funci&#243;n <strong>out_region()</strong>. Si ha salido de pantalla se pone otra vez en el centro con otro &#225;ngulo elegido nuevamente al azar.<br/><br/>
<hr/>
Ver: <a href="#106">define_region()</a> - <a href="#1130">region</a> - <a href="#1039">Codigos identificadores</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="144">play_cd()</h2><br/><br/>
<strong>play_cd(</strong>&lt;n&#250;mero de pista&gt;<strong>,</strong> &lt;modo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Comienza a tocar una pista de cd-audio. Se debe indicar el n&#250;mero de pista (de 1 al n&#250;mero de canciones que tenga el cd) y el modo es como sigue:<br/><br/>
<strong>Modo:</strong><br/><br/>
<strong>0</strong> - Tocar la canci&#243;n y pararse despu&#233;s.<br/>
<strong>1</strong> - Tocar esa canci&#243;n y despu&#233;s las siguientes.<br/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_play_cd;
BEGIN
    write(0, 160, 0, 1, &quot;Pulse [ESPACIO] para poner el CD en marcha.&quot;);
    LOOP
        IF (scan_code==_space)

            play_cd(1, 1); // Se pone la 1&#170; canci&#243;n y despu&#233;s las dem&#225;s.

        END
        FRAME;
    END
END
</pre>
El ejemplo anterior (para el cual se necesita tener un <strong>Compact disc</strong> de m&#250;sica en el cargador de <strong>CD-ROM</strong>) se pone un mensaje informativo y en cada iteraci&#243;n del bucle se comprueba si se puls&#243; la barra espaciadora para poner la primera canci&#243;n con la funci&#243;n <strong>play_cd()</strong><br/><br/>
<hr/>
<br/><br/>
Para conseguir que una canci&#243;n suene indefinidamente, se debe implementar un bucle utilizando la funci&#243;n <a href="#127">is_playing_cd()</a> para determinar cu&#225;ndo ha acabado la canci&#243;n.<br/><br/>
El volumen de reproducci&#243;n del cd-audio se puede controlar con la estructura <a href="#1104">setup</a> y la funci&#243;n <a href="#178">set_volume()</a>.<br/><br/>
<hr/>
Ver: <a href="#127">is_playing_cd()</a> - <a href="#164">stop_cd()</a> - <a href="#178">set_volume()</a> - <a href="#1104">Estructura setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="145">pow()</h2><br/><br/>
<strong>pow(</strong>&lt;expresi&#243;n&gt;<strong>,</strong> &lt;expresi&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La primera expresi&#243;n <strong>elevada</strong> a la segunda.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula el resultado de elevar la primera expresi&#243;n a la segunda.<br/><br/>
Por ejemplo, <strong>pow(3, 2)</strong> devolver&#225; <strong>9</strong>, que es <strong>3</strong> elevado al cuadrado, es decir, <strong>3&#178;</strong>, o <strong>3*3</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_pow;
GLOBAL
    valores[15];
    n;
BEGIN
    FROM n=0 TO 15;
        valores[n]=rand(-100, 100);
        write_int(0, 0, n*10, 0, offset valores[n]);
    END
    write(0, 0, 192, 0, &quot;Pulse [ESPACIO] para elevar estos n&#250;meros al cuadrado&quot;);
    LOOP
        IF (scan_code==_space)
            FROM n=0 TO 15;

                valores[n] = pow(valores[n], 2); // Se eleva al cuadrado.

            END
        END
        FRAME;
    END
END
</pre>
Este programa imprimir&#225; en pantalla una lista de n&#250;meros aleatoriamente escogidos entre -100 y 100. Cuando se pulse la barra espaciadora se elevar&#225;n dichos n&#250;mero al cuadrado.<br/><br/>
Se debe tener en cuenta que en el lenguaje <strong>s&#243;lo se pueden manejar n&#250;meros enteros dentro del rango</strong> (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>) por lo que, cuando el resultado de la funci&#243;n deba exceder dicho rango, <strong>se mostrar&#225;n resultados incorrectos</strong>. En este caso, el sistema no advertir&#225; de ning&#250;n error, por lo que se deben extremar las precauciones.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="146">put()</h2><br/><br/>
<strong>put(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Pone un gr&#225;fico en el fondo de la pantalla. La funci&#243;n requiere el <strong>c&#243;digo de fichero</strong> en el que est&#225; el gr&#225;fico, el <strong>c&#243;digo del gr&#225;fico</strong> dentro del mismo fichero y las coordenadas (<strong>x</strong>, <strong>y</strong>) en las que se desea poner el gr&#225;fico.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
Si no se especific&#243; el centro del gr&#225;fico (estableciendo su <a href="#1136">punto de control</a> n&#250;mero 0 desde la herramienta de dibujo), las coordenadas se referir&#225;n a la posici&#243;n de pantalla en la que se situar&#225; <strong>el centro</strong> del gr&#225;fico.<br/><br/>
Los gr&#225;ficos impresos de esta forma en el fondo de la pantalla estar&#225;n en la visualizaci&#243;n del juego <strong>por debajo de todos los procesos, regiones de scroll, textos, etc.</strong><br/><br/>
Si se desea que un gr&#225;fico est&#233; por encima de otros se debe <strong>crear como un nuevo proceso</strong> y fijar su variable <a href="#1125">z</a> con la prioridad de impresi&#243;n del mismo.<br/><br/>
Para borrar el fondo de la pantalla se debe utilizar la funci&#243;n <a href="#103">clear_screen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_put;

PRIVATE
    fichero1;
    coord_x;
    coord_y;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    LOOP
        coord_x=rand(0, 319);
        coord_y=rand(0, 199);

        put(fichero1, 100, coord_x, coord_y); // Se pone el gr&#225;fico 100.

        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero con los gr&#225;ficos y en cada iteraci&#243;n de bucle se pone el gr&#225;fico n&#250;mero 100 (una bola) con la funci&#243;n <strong>put()</strong> en coordenadas aleatorias (elegidas al azar con la funci&#243;n <a href="#149">rand()</a>).<br/><br/>
<hr/>
<br/><br/>
Si el gr&#225;fico que se quiere poner es simplemente una pantalla de fondo, resulta m&#225;s sencillo utilizar la funci&#243;n <a href="#148">put_screen()</a>, ya que &#233;sta no requiere las coordenadas de pantalla pues centrar&#225; el gr&#225;fico en la misma de forma autom&#225;tica.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#173">xput()</a> es una versi&#243;n un poco m&#225;s compleja de la funci&#243;n <strong>put()</strong> pero con muchas m&#225;s posibilidades, ya que permite, adem&#225;s, poner gr&#225;ficos rotados, escalados, espejados y transparentes.<br/><br/>
Para poner un gr&#225;fico en otro (en lugar del fondo de la pantalla) se deben utilizar las funciones <a href="#137">map_put()</a> o <a href="#139">map_xput()</a>.<br/><br/>
<hr/>
Ver: <a href="#148">put_screen()</a> - <a href="#173">xput()</a> - <a href="#137">map_put()</a> - <a href="#139">map_xput()</a> - <a href="#147">put_pixel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="147">put_pixel()</h2><br/><br/>
<strong>put_pixel(</strong>&lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;color&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Establece el <strong>color</strong> del punto situado en las coordenadas (<strong>x</strong>, <strong>y</strong>) del fondo de la pantalla. Es decir, pone un punto del color indicado en las coordenadas indicadas.<br/><br/>
Los puntos impresos con esta funci&#243;n en el fondo de la pantalla estar&#225;n en la visualizaci&#243;n del juego <strong>por debajo de todos los procesos, regiones de scroll, textos, etc.</strong><br/><br/>
Si se desea visualizar un punto que est&#233; por encima de otros gr&#225;ficos se debe crear un nuevo proceso y asignarle como gr&#225;fico el dibujo de un punto (en su variable <a href="#1126">graph</a>) y fijar su variable <strong>z</strong> con la prioridad de impresi&#243;n del mismo.<br/><br/>
Para borrar el fondo de la pantalla se debe utilizar la funci&#243;n <a href="#103">clear_screen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_put_pixel;

PRIVATE
    x_punto;
    y_punto;
    color;

BEGIN
    LOOP
        x_punto=rand(0, 319);
        y_punto=rand(0, 199);
        color=rand(0, 15);

        // Se ponen puntos en el fondo de la pantalla aleatoriamente
        put_pixel(x_punto, y_punto, color);

        FRAME;
    END
END
</pre>
En el ejemplo, en cada paso del bucle se ponen puntos con la funci&#243;n <strong>put_pixel()</strong> con coordenadas y color elegidos al azar con la funci&#243;n <a href="#149">rand()</a>.<br/><br/>
<hr/>
<br/><br/>
Para leer el color que tiene un determinado punto del fondo de la pantalla se debe utilizar la funci&#243;n <a href="#123">get_pixel()</a>, que devolver&#225; un n&#250;mero entre 0 y 255 correspondiente al orden del color dentro de la paleta.<br/><br/>
Para poner un gr&#225;fico en pantalla, en lugar de un simple punto se debe utilizar la funci&#243;n <a href="#146">put()</a>.<br/><br/>
Tambi&#233;n es posible establecer el color de un punto en un determinado gr&#225;fico en lugar del fondo de la pantalla, lo que se puede hacer con <a href="#138">map_put_pixel()</a>.<br/><br/>
<hr/>
Ver: <a href="#123">get_pixel()</a> - <a href="#146">put()</a> - <a href="#138">map_put_pixel()</a> - <a href="#136">map_get_pixel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="148">put_screen()</h2><br/><br/>
<strong>put_screen(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Establece el fondo de la pantalla. La funci&#243;n requiere el <strong>c&#243;digo de fichero</strong> en el que est&#225; el gr&#225;fico, y el propio <strong>c&#243;digo del gr&#225;fico</strong> que se desea imprimir en el fondo de la pantalla dentro del fichero.<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
La funci&#243;n no requiere ninguna coordenada como par&#225;metro, pues si el gr&#225;fico es de un tama&#241;o (en puntos) diferente al de la pantalla simplemente se imprimir&#225; centrado en la misma.<br/><br/>
Para borrar el fondo de la pantalla se debe utilizar la funci&#243;n <a href="#103">clear_screen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_put_screen;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);

    put_screen(fichero1, 1); // Se pone el gr&#225;fico 1 como fondo.

    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero de gr&#225;ficos y se pone un gr&#225;fico de fondo (que est&#225; metido en el fichero con el c&#243;digo de gr&#225;fico n&#250;mero 1) con la funci&#243;n <strong>put_screen()</strong>.<br/><br/>
<hr/>
<br/><br/>
Si se quiere imprimir un gr&#225;fico en una parte concreta de la pantalla o un gr&#225;fico <strong>que no aparezca centrado</strong>, se puede utilizar para ello la funci&#243;n <a href="#146">put()</a>. La funci&#243;n <a href="#173">xput()</a> permite, adem&#225;s, imprimir gr&#225;ficos rotados, escalados, espejados y/o transparentes en cualquier regi&#243;n de pantalla.<br/><br/>
<hr/>
Ver: <a href="#146">put()</a> - <a href="#173">xput()</a> - <a href="#147">put_pixel()</a> - <a href="#103">clear_screen()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="149">rand()</h2><br/><br/>
<strong>rand(</strong>&lt;valor m&#237;nimo&gt;<strong>,</strong> &lt;valor m&#225;ximo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Un valor num&#233;rico aleatorio.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve un n&#250;mero aleatorio (escogido al azar) entre el <strong>valor m&#237;nimo</strong> y el <strong>valor m&#225;ximo</strong>, ambos incluidos.<br/><br/>
Esta funci&#243;n se suele utilizar para establecer todos los par&#225;metros que se quiere que var&#237;en en un juego de una partida a otra; por ejemplo, se pueden inicializar las coordenadas de un enemigo con n&#250;meros aleatorios, para que en cada partida pueda aparecer en una posici&#243;n diferente.<br/><br/>
Otra utilidad de esta funci&#243;n es cuando se quiere que una acci&#243;n no suceda siempre, sino que tenga una cierta probabilidad de suceder; esto se suele implementar con una sentencia del tipo:<br/><br/>
<strong>IF (rand(0, 100)&lt;25)</strong><br/>
<strong> // Acci&#243;n ...</strong><br/>
<strong>END</strong><br/>
<br/><br/>
En este caso la <strong>acci&#243;n</strong> se realizar&#237;a con un promedio del 25 por ciento de las veces que se ejecutara la sentencia <a href="#1020">IF</a>, ya que, al obtener un n&#250;mero al azar entre 0 y 100, &#233;ste s&#243;lo ser&#237;a un n&#250;mero menor que 25, aproximadamente una cuarta parte de las ocasiones.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_rand;

PRIVATE
    tabla[15];
    contador;

BEGIN
    write (0, 0, 192, 0, &quot;Pulse [ESPACIO] para hallar valores aleatorios.&quot;);
    FROM contador=0 TO 15;
        write_int(0, 0, contador*10, 0, offset tabla[contador]);
    END
    LOOP
        IF (scan_code==_space)
            FROM contador=0 TO 15;

                // Se eligen valores aleatorios entre -100 y 100
                tabla[contador] = rand(-100, 100);

            END
        END
        FRAME;
    END
END
</pre>
En el ejemplo se crea una tabla con 16 datos (del 0 al 15). En cada iteraci&#243;n del bucle principal se comprueba si se ha pulsado la barra espaciadora, en cuyo caso se rellenan los 16 datos de la tabla con valores aleatorios entre -100 y 100, elegidos con la funci&#243;n <strong>rand()</strong>.<br/><br/>
<hr/>
<br/><br/>
Por defecto, en cada ejecuci&#243;n del programa los valores que devuelva la funci&#243;n <strong>rand()</strong> ser&#225;n completamente diferentes. Si se quiere que la serie de n&#250;meros sea siempre una misma, se puede utilizar para ello la funci&#243;n <a href="#150">rand_seed()</a> especificando un n&#250;mero, tras el cual la serie de n&#250;meros que devuelva la funci&#243;n <strong>rand()</strong> estar&#225; siempre predeterminada.<br/><br/>
<hr/>
Ver: <a href="#150">rand_seed()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="150">rand_seed()</h2><br/><br/>
<strong>rand_seed(</strong>&lt;valor num&#233;rico&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n establece una semilla para el generador de n&#250;meros aleatorios (los n&#250;meros que genera la funci&#243;n <a href="#149">rand()</a>).<br/><br/>
Si se establece una semilla, que puede ser cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>), todos los n&#250;meros que genere la funci&#243;n <a href="#149">rand()</a> ser&#225;n los mismos en cada ejecuci&#243;n del programa. Es decir, tras establecerse una semilla de origen, la funci&#243;n <a href="#149">rand()</a> devolver&#225; una serie de n&#250;meros predeterminada para dicha semilla.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_rand_seed;

PRIVATE
    tabla[15];
    contador;

BEGIN
    write (0, 0, 184, 0, &quot;Pulse [ENTER] para introducir 1234 como semilla.&quot;);
    write (0, 0, 192, 0, &quot;Pulse [ESPACIO] para hallar valores aleatorios.&quot;);
    FROM contador=0 TO 15;
        write_int(0, 0, contador*10, 0, offset tabla[contador]);
    END
    LOOP
        IF (scan_code==_space)
            FROM contador=0 TO 15;
                tabla[contador] = rand(-100, 100);
            END
        END
        IF (scan_code==_enter)

            rand_seed(1234); // Se introduce semilla para aleatorios.

        END
        FRAME;
    END
END
</pre>
En el ejemplo se crea una tabla con 16 datos (del 0 al 15). En cada iteraci&#243;n del bucle principal, cada vez que se pulse la barra espaciadora se rellenar&#225;n los datos con valores aleatorios entre -100 y 100 (elegidos con la funci&#243;n <a href="#149">rand()</a>).<br/><br/>
Y cuando se pulse la tecla ENTER, entonces se definir&#225; la semilla de los n&#250;meros aleatorios con la funci&#243;n <strong>rand_seed()</strong> como 1234.<br/><br/>
Se puede observar c&#243;mo cada vez que se pulsa la tecla ENTER, luego, al pulsar la barra espaciadora, siempre se obtiene la misma serie de n&#250;meros aleatorios (17, 94, -38, ...). Para cada semilla posible; &#233;sta serie ser&#225; diferente.<br/><br/>
<hr/>
Ver: <a href="#149">rand()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="152">refresh_scroll()</h2><br/><br/>
<strong>refresh_scroll(</strong>&lt;n&#250;mero de scroll&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n se utiliza cuando se ha modificado un gr&#225;fico con las funciones <a href="#137">map_put()</a>, <a href="#139">map_xput()</a>, <a href="#135">map_block_copy()</a> o <a href="#138">map_put_pixel()</a> que est&#225; siendo utilizado como <strong>fondo de una regi&#243;n de scroll</strong>, para actualizarlo.<br/><br/>
La funci&#243;n requiere como par&#225;metro el &lt;n&#250;mero de scroll&gt; que se especific&#243; al iniciar el scroll con la funci&#243;n <a href="#163">start_scroll()</a>.<br/><br/>
Cuando se modifica un gr&#225;fico que est&#225; siendo utilizado como fondo de un scroll no se actualiza en pantalla autom&#225;ticamente, sino que hay que llamar a esta funci&#243;n para ello.<br/><br/>
Una vez modificado el gr&#225;fico permanecer&#225; as&#237; durante el resto de la ejecuci&#243;n del programa, a no ser que se descargue el gr&#225;fico de memoria (con <a href="#169">unload_fpg()</a>, <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>) y se vuelva a cargar, en cuyo caso se recuperar&#225; el estado original del gr&#225;fico.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_refresh_scroll;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    start_scroll(0, 0, 103, 102, 0, 15);
    scroll.camera=id;
    write(0, 160, 192, 7, &quot;Pulse [ENTER] para poner un gr&#225;fico en el scroll.&quot;);
    write(0, 160, 200, 7, &quot;Pulse [ESPACIO] para actualizar scroll.&quot;);
    LOOP
        IF (scan_code==_enter)
           map_put(0, 103, 100, rand(16, 48), rand(16, 48));
        END
        IF (scan_code==_space)

            refresh_scroll(0); // Refrescamos el scroll 0.

        END
        x+=2;
        y+=1;
        FRAME;
    END
END
</pre>
En el ejemplo se crea el scroll (n&#250;mero 0) como un scroll de dos planos: el primero con el gr&#225;fico n&#250;mero 103 y el plano de fondo con el gr&#225;fico n&#250;mero 102.<br/><br/>
Dentro del bucle principal se imprimir&#225; una bola sobre el gr&#225;fico 103 (primer plano del scroll) cuando se pulse la tecla ENTER. Pero &#233;ste no aparecer&#225; en pantalla a no ser que se espere a que el scroll entre poco a poco en pantalla (con el gr&#225;fico 103 ya modificado), o bien se pulse la barra espaciadora, en cuyo caso la llamada a la funci&#243;n <strong>refresh_scroll()</strong> actualizar&#225; la ventana del scroll con el gr&#225;fico ya modificado.<br/><br/>
Si en el ejemplo anterior se hubiera llamado a la funci&#243;n <strong>refresh_scroll()</strong> justo a continuaci&#243;n de <a href="#137">map_put()</a>, los gr&#225;ficos impresos sobre el primer plano aparecer&#237;an instant&#225;neamente al pulsar la barra espaciadora.<br/><br/>
En el ejemplo, cada vez que se imprime una bola aparecen muchas; esto es debido a que el gr&#225;fico 103 utilizado como primer plano en el scroll es un gr&#225;fico peque&#241;o y se muestra varias veces, en mosaico, para rellenar toda la zona de scroll.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede observar que si el gr&#225;fico que se imprime est&#225; en unas coordenadas fuera de pantalla, no ser&#225; necesario llamar a esta funci&#243;n ya que las partes del scroll que van entrando en pantalla se van refrescando autom&#225;ticamente.<br/><br/>
<hr/>
Ver: <a href="#163">start_scroll()</a> - <a href="#140">move_scroll()</a> - <a href="#1101">Estructura scroll</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="153">reset_fli()</h2><br/><br/>
<strong>reset_fli()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n <strong>rebobina</strong> hasta el principio una animaci&#243;n <strong>FLI/FLC</strong> que se inici&#243; con la funci&#243;n <a href="#161">start_fli()</a>.<br/><br/>
Tras llamar a esta funci&#243;n, la animaci&#243;n se volver&#225; a mostrar completa desde el principio (para visualizar cada fotograma de la animaci&#243;n se debe llamar a la funci&#243;n <a href="#115">frame_fli()</a>).<br/><br/>
La utilidad de esta funci&#243;n reside en poder parar una animaci&#243;n y, sin descargarla (<a href="#108">end_fli()</a>) y volverla a cargar, volver a repetirla desde el principio.<br/><br/>
Si una animaci&#243;n se quiere tocar indefinidamente, volviendo a empezar cuando llegue al final, entonces <strong>no es necesario utilizar esta funci&#243;n</strong>, ya que esto se har&#225; de forma autom&#225;tica con <a href="#115">frame_fli()</a>, si se sigue llamando una vez haya terminado la animaci&#243;n.<br/><br/>
S&#243;lo es posible tener una animaci&#243;n a la vez, por lo que no es necesario especificar ning&#250;n par&#225;metro para esta funci&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_reset_fli;
BEGIN
    start_fli(&quot;help\help.fli&quot;, 0, 0);
    write(0, 160, 0, 1, &quot;Pulse [ESPACIO] para reiniciar la animaci&#243;n.&quot;);
    LOOP
        frame_fli();
        IF (scan_code==_space)

            reset_fli(); // Se inicializa la animaci&#243;n

        END
        FRAME;
    END
END
</pre>
En el ejemplo se carga una animaci&#243;n con la funci&#243;n <a href="#161">start_fli()</a> y despu&#233;s se toca indefinidamente con la funci&#243;n <a href="#115">frame_fli()</a>.<br/><br/>
En el bucle se comprueba si se ha pulsado la barra espaciadora, y si est&#225; pulsada se reinicializa con la funci&#243;n <strong>reset_fli()</strong>.<br/><br/>
<hr/>
Ver: <a href="#161">start_fli()</a> - <a href="#115">frame_fli()</a> - <a href="#108">end_fli()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="154">roll_palette()</h2><br/><br/>
<strong>roll_palette(</strong>&lt;color inicial&gt;<strong>,</strong> &lt;n&#250;mero de colores&gt;<strong>,</strong> &lt;incremento&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Rota una gama de colores de la paleta. Esta funci&#243;n sirve para crear efectos de movimiento en gr&#225;ficos est&#225;ticos, como el efecto del agua corriendo.<br/><br/>
Para utilizar esta funci&#243;n se deben crear primero gr&#225;ficos que utilicen una gama de colores consecutivos de la paleta original, en un ciclo perpetuo, por ejemplo, los colores del <strong>0</strong> al <strong>15</strong>, pintando algo con los colores 0, 1, 2, 3, ... , 14, 15, 0, 1, 2, ...<br/><br/>
Despu&#233;s, hay que tener cuidado de que dichos colores no sean utilizados por otros gr&#225;ficos que vayan a aparecer en pantalla al mismo tiempo, si no se quiere tambi&#233;n el efecto en ellos.<br/><br/>
El <strong>incremento</strong> (tercer par&#225;metro) suele ser <strong>1</strong> para realizar la rotaci&#243;n en un sentido y<strong> -1</strong> para realizarla en el otro, pero se pueden utilizar otros valores para realizar el ciclo de colores a m&#225;s velocidad.<br/><br/>
Para realizar un ciclo de los colores del <strong>0</strong> al <strong>15</strong> se especificar&#237;a <strong>0</strong> como &lt;color inicial&gt; y <strong>16</strong> como &lt;n&#250;mero de colores&gt;.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_roll_palette;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 2);
    write(0, 160, 0, 1, &quot;Pulse [ESPACIO] para rotar la paleta entera.&quot;);
    LOOP
        IF (scan_code==_space)

            roll_palette(0, 256, 1); // Se rotan los 256 colores.

        END
        FRAME;
    END
END
</pre>
En el ejemplo se pone como fondo una pantalla multicolor y dentro del bucle principal del programa se rotar&#225;n los 256 colores de la paleta cada vez que se pulse la barra espaciadora.<br/><br/>
<hr/>
<br/><br/>
Si se quiere determinar la paleta con la que se debe realizar el ciclo de color, se debe cargar &#233;sta de un archivo con la funci&#243;n <a href="#133">load_pal()</a>.<br/><br/>
<hr/>
<br/><br/>
Para realizar otros efectos de paleta, sin sustituir unos colores por otros en ciclos, se debe utilizar la funci&#243;n <a href="#110">fade()</a> que permite realizar m&#250;ltiples fundidos y saturaciones de color a diferentes velocidades.<br/><br/>
Existen dos versiones simplificadas de esta &#250;ltima funci&#243;n que permiten realizar un fundido a negro (<a href="#111">fade_off()</a>) y deshacerlo (<a href="#112">fade_on()</a>).<br/><br/>
<hr/>
Ver: <a href="#179">set_color()</a> - <a href="#133">load_pal()</a> - <a href="#110">fade()</a> - <a href="#111">fade_off()</a> - <a href="#112">fade_on()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="155">save()</h2><br/><br/>
<strong>save(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;OFFSET dato&gt;<strong>,</strong> &lt;sizeof(dato)&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Graba un bloque de datos desde la memoria del programa a un archivo en el disco para recuperarlos despu&#233;s, cuando se requiera, con la funci&#243;n <a href="#130">load()</a>.<br/><br/>
Para ello, la funci&#243;n requiere el <strong>nombre del archivo</strong>, el desplazamiento dentro de la memoria del ordenador de la variable, tabla o estructura guardada en el disco (el desplazamiento del dato se obtiene con <a href="#1085">OFFSET</a> <strong>&lt;nombre del dato&gt;</strong>) y el n&#250;mero de posiciones de memoria que ocupa dicho dato (lo que se puede obtener con <a href="#1094">sizeof</a><strong>(&lt;nombre del dato&gt;)</strong>).<br/><br/>
Es posible guardar varios datos (variables, tablas o estructuras) si estos se han definido dentro de la misma secci&#243;n (<a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a>) y de forma consecutiva; en este caso se debe indicar como <strong>segundo par&#225;metro</strong> el <a href="#1085">OFFSET</a> del primer dato, y como <strong>tercer par&#225;metro</strong> la suma de los <a href="#1094">sizeof()</a> de todos los datos.<br/><br/>
No es necesario especificar una ruta de acceso junto al nombre de archivo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load;

PRIVATE
    tabla[9];
    contador;

BEGIN
    write (0, 0, 0, 0, &quot;Pulse [ENTER] para borrar los datos.&quot;);
    write (0, 0, 10, 0, &quot;Pulse [ESPACIO] para cargar los datos del disco&quot;);
    write (0, 0, 30, 0, &quot;Valores actuales de los datos:&quot;);
    FROM contador=0 TO 9;
        tabla[contador]=rand(0, 100);
        write_int(0, 0, 40+(contador*10), 0, offset tabla[contador]);
    END

    save(&quot;help\help.dat&quot;, offset tabla, sizeof(tabla)); // Se graba el archivo.

    LOOP
        IF (key(_enter))
            FROM contador=0 TO 9;
                tabla[contador]=0;
            END
        END
        IF (key(_space))
            load(&quot;help\help.dat&quot;, offset tabla);
        END
        FRAME;
    END
END
</pre>
Al inicio del ejemplo se crea una tabla de 10 posiciones (del 0 al 9) con valores aleatorios. Esta tabla se graba en el disco con la funci&#243;n <strong>save()</strong>.<br/><br/>
Cuando se pulsa la tecla ENTER se borran los valores de la tabla (se ponen a 0 las 10 posiciones).<br/><br/>
Cuando se pulsa la barra espaciadora se cargan los valores de la tabla del disco con la funci&#243;n <a href="#130">load()</a>.<br/><br/>
<hr/>
<br/><br/>
Para grabar en el mismo archivo <strong>tabla[9]</strong> y la variable <strong>contador</strong> se deber&#237;a haber llamado a la funci&#243;n <strong>save()</strong> de la siguiente forma:<br/><br/>
<strong>save(&quot;help\help.dat&quot;, offset tabla, sizeof(tabla)+sizeof(contador));</strong><br/><br/>
No variando la instrucci&#243;n de carga (<strong>load(&quot;help\help.dat&quot;, offset tabla);</strong>), ya que &#233;sta no requiere el n&#250;mero de datos.<br/><br/>
El valor devuelto por <a href="#1094">sizeof()</a> para cualquier variable (como <strong>contador</strong>) ser&#225; siempre 1, y para una tabla el n&#250;mero de posiciones de la misma, luego la sentencia de grabaci&#243;n podr&#237;a ponerse como (teniendo en cuenta que se van a grabar 11 datos, 10 de la tabla y 1 de la variable):<br/><br/>
{save(&quot;help\help.dat&quot;, offset tabla, 11);<br/><br/>
<hr/>
Ver: <a href="#130">load()</a> - <a href="#1085">OFFSET</a> - <a href="#1094">sizeof()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="156">set_fps()</h2><br/><br/>
<strong>set_fps(</strong>&lt;n&#186; de im&#225;genes por segundo&gt;<strong>,</strong> &lt;n&#186; de saltos permitidos&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n es la que regula la velocidad a la que van los juegos; define el n&#250;mero de im&#225;genes por segundo que se mostrar&#225;n del juego (el n&#250;mero de fotogramas por segundo).<br/><br/>
Por defecto la visualizaci&#243;n se regular&#225; a 18 im&#225;genes por segundo, lo cual quiere decir que si un proceso se mueve un punto por cada imagen (<strong>FRAME</strong>), &#233;ste se mover&#225; en pantalla a una velocidad de 18 puntos por segundo.<br/><br/>
Esta funci&#243;n puede fijar el n&#250;mero de im&#225;genes por segundo (<strong>FPS</strong>, Frames Per Second) desde <strong>4</strong> como m&#237;nimo hasta <strong>200</strong> como m&#225;ximo; en general no son necesarias m&#225;s de 24 im&#225;genes por segundo para conseguir un movimiento fluido y suave.<br/><br/>
El segundo par&#225;metro, <strong>n&#250;mero m&#225;ximo de saltos permitidos</strong>, se refiere a c&#243;mo es preferible que se comporte el programa cuando se ejecute en un ordenador que sea lo suficientemente r&#225;pido como para calcular el n&#250;mero de im&#225;genes por segundo que se solicita. Funciona como se muestra a continuaci&#243;n.<br/><br/>
<strong>N&#250;mero de saltos permitidos:</strong><br/><br/>
<strong>0</strong> - El juego ir&#225; a menos velocidad cuando se ejecute en un ordenador demasiado lento, es decir, se mostrar&#225;n las im&#225;genes por segundo que a ese ordenador le de tiempo a calcular.<br/><br/>
<strong>1</strong> - Si el ordenador no puede calcular todas las im&#225;genes, se le permite que de vez en cuando omita alguna imagen para intentar mantener la velocidad relativa del juego. El juego se ver&#225; un poco m&#225;s brusco, pero m&#225;s r&#225;pido.<br/><br/>
<strong>2 o m&#225;s</strong> - Se permite al juego que salte tantas im&#225;genes consecutivas como se indica en este par&#225;metro con tal de mantener la velocidad relativa original del juego. Por ejemplo, si se fija el n&#250;mero de saltos a <strong>4</strong> y en el juego un proceso se desplazaba de un punto en un punto, en un ordenador muy lento se podr&#237;a llegar a desplazar de hasta 4 puntos en 4 puntos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_fps;

PRIVATE
    im&#225;genes=24;
    saltos=4;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    graph=1;
    x=160;
    y=100;
    write(0, 0, 0, 0, &quot;Im&#225;genes por segundo: Arriba(+) / Abajo(-)&quot;);
    write_int(0, 0, 10, 0, offset im&#225;genes);
    write(0, 0, 20, 0, &quot;Saltos permitidos: Derecha(+) / Izquierda(-)&quot;);
    write_int(0, 0, 30, 0, offset saltos);
    write(0, 160, 200, 7, &quot;Utilice los CURSORES para cambiar los valores.&quot;);
    LOOP

        // Se elige el n&#250;mero imagenes por segundo
        set_fps(im&#225;genes, saltos);

        IF (key(_up) AND im&#225;genes&lt;200) im&#225;genes++; END
        IF (key(_down) AND im&#225;genes&gt;4) im&#225;genes--; END
        IF (key(_right) AND saltos&lt;20) saltos++; END
        IF (key(_left) AND saltos&gt;0) saltos--; END
        angle+=4000;
        FRAME;
    END
END
</pre>
En el ejemplo se imprimen los mensajes necesarios y el proceso principal crea un gr&#225;fico en el centro de la pantalla rotando indefinidamente.<br/><br/>
En cada paso del bucle se detectan las teclas del cursor, se cambia el n&#250;mero de im&#225;genes por segundo (<strong>im&#225;genes</strong>) con <strong>arriba/abajo</strong> y el m&#225;ximo n&#250;mero de saltos permitidos (<strong>saltos</strong>) con <strong>derecha/izquierda</strong>.<br/><br/>
Al comienzo de cada iteraci&#243;n del bucle se establece la velocidad seg&#250;n los valores de ambas variables, con la funci&#243;n <strong>set_fps()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La variable global <a href="#1426">fps</a> mantiene actualizado el n&#250;mero de im&#225;genes por segundo que se est&#225;n consiguiendo realmente en el programa.<br/><br/>
<hr/>
Ver: <a href="#1029">FRAME</a> - <a href="#1115">max_process_time</a> - <a href="#157">set_mode()</a> - <a href="#1426">fps</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="157">set_mode()</h2><br/><br/>
<strong>set_mode(</strong>&lt;nuevo modo de v&#237;deo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Fija un nuevo modo de v&#237;deo para la ejecuci&#243;n del juego. Los modos de v&#237;deo est&#225;ndar que se pueden especificar como par&#225;metro son:<br/><br/>
<strong>m320x200</strong>  - VGA est&#225;ndar<br/>
<strong>m320x240</strong>  - Modo X<br/>
<strong>m320x400</strong>  - Modo X<br/>
<strong>m360x240</strong>  - Modo X<br/>
<strong>m360x360</strong>  - Modo X<br/>
<strong>m376x282</strong>  - Modo X<br/>
<strong>m640x400</strong>  - SVGA VESA<br/>
<strong>m640x480</strong>  - SVGA VESA<br/>
<strong>m800x600</strong>  - SVGA VESA<br/>
<strong>m1024x768</strong> - SVGA VESA<br/>
<br/><br/>
<strong>Nota:</strong> Adem&#225;s de estos modos (que suelen ser est&#225;ndar en la mayor&#237;a de adaptadores), existe una estructura global denominada <a href="#1415">video_modes</a> que contiene la lista de modos VESA detectados en el adaptador de v&#237;deo del sistema. Estos modos tambi&#233;n pueden ser utilizados con la funci&#243;n <strong>set_mode()</strong>.<br/><br/>
Al realizarse un cambio de modo de v&#237;deo en el programa se realizar&#225; autom&#225;ticamente un fundido a negro (de la paleta de colores del programa) y en las siguientes visualizaciones del juego se ir&#225; restaurando gradualmente la paleta de colores, es decir, <strong>set_mode()</strong> realiza siempre un <a href="#111">fade_off()</a> justo antes de cambiar el modo de v&#237;deo y un <a href="#112">fade_on()</a> justo despu&#233;s de haberlo cambiado.<br/><br/>
Por defecto todos los programas comienzan con el modo de 320 por 200 puntos activado (<strong>set_mode(m320x200)</strong>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_mode;

PRIVATE
    modos[]=
        m320x200, m320x240, m320x400, m360x240, m360x360,
        m376x282, m640x400, m640x480, m800x600, m1024x768;
    modovideo=0;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    write (0, 0, 0, 0, &quot;Pulse [ESPACIO] para cambiar el modo de v&#237;deo&quot;);
    LOOP
        IF (scan_code==_space)
            modovideo=modovideo+1;
            IF (modovideo==10) modovideo=0; END

            set_mode(modos[modovideo]);

        END
        FRAME;
    END
END
</pre>
En el ejemplo se pone un fondo de pantalla y un texto explicativo.<br/><br/>
En la iteraci&#243;n del bucle principal, si se pulsa la barra espaciadora, se activar&#225; un nuevo modo de v&#237;deo con la funci&#243;n <strong>set_mode()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Al utilizar la funci&#243;n <strong>set_mode()</strong> se eliminar&#225;n todas las ventanas de scroll y de modo 7 que estuvieran activas en el juego y todos los procesos que se estuvieran visualizando en ellas.<br/><br/>
<hr/>
Ver: <a href="#156">set_fps()</a> - <a href="#1115">max_process_time</a> - <a href="#1150">m320x200 ... m1024x768</a> - <a href="#1415">STRUCT video_modes</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="158">signal()</h2><br/><br/>
<strong>signal(</strong>&lt;id&gt;<strong>,</strong> &lt;se&#241;al&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Manda una se&#241;al a un proceso (un objeto del juego). Esta funci&#243;n se utiliza principalmente (aunque no s&#243;lo) para destruir (matar) a un proceso desde otro, envi&#225;ndole una se&#241;al <a href="#1153">s_kill</a>.<br/><br/>
Si desconoce a qu&#233; se hace referencia cuando se habla del proceso padre, hijo, <strong>hermano</strong>, un proceso <strong>hu&#233;rfano</strong>, etc., entonces vea <a href="#1041">Jerarqu&#237;as de procesos</a>.<br/><br/>
Si desconoce los t&#233;rminos vivo, <strong>muerto</strong>, <strong>dormido</strong>, etc., referidos a procesos, vea <a href="#1040">Estados de un proceso</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE id2;
BEGIN
    id2=mi_proceso();
    // ...
    signal(id2, s_kill);
END
PROCESS mi_proceso()
BEGIN
    // ...
    LOOP
        FRAME;
    END
END
</pre>
Este programa crear&#237;a un proceso de tipo <strong>mi_proceso</strong> y despu&#233;s lo eliminar&#237;a con la sentencia <strong>signal(id2,s_kill)</strong> (id2 es una variable del programa principal que contiene el <a href="#1039">c&#243;digo identificador</a> del proceso que se va a destruir).<br/><br/>
Cualquier proceso puede enviar una se&#241;al a otro, siempre que disponga de su <a href="#1039">c&#243;digo identificador</a>, ver:<br/><br/>
<a href="#1039">C&#243;digos identificadores de procesos</a><br/>
<a href="#1038">Formas de obtener el c&#243;digo identificador de un proceso</a><br/>
<br/><br/>
No obstante, hay otros <strong>tipos de se&#241;ales</strong> que se le pueden enviar a un proceso, y son las siguientes:<br/><br/>
<a href="#1153">s_kill</a> - Orden de <strong>matar</strong> al proceso, el proceso ya no aparecer&#225; en las siguientes im&#225;genes del juego.<br/><br/>
<a href="#1155">s_sleep</a> - Orden de <strong>dormir</strong> al proceso, el proceso quedar&#225; paralizado sin ejecutar su c&#243;digo y sin visualizarse en pantalla (ni poder ser detectado por el resto de los procesos), como si se hubiera matado. Pero el proceso seguir&#225; existiendo en la memoria del ordenador (ver <strong>s_wakeup</strong>).<br/><br/>
<a href="#1156">s_freeze</a> - Orden de <strong>congelar</strong> al proceso, el proceso quedar&#225; inmovilizado sin ejecutar su c&#243;digo, pero seguir&#225; visualiz&#225;ndose en pantalla y pudiendo ser detectado (en las colisiones) por el resto de procesos. El proceso seguir&#225; existiendo en la memoria del ordenador a pesar de no ejecutarse su c&#243;digo (ver <strong>s_wakeup</strong>).<br/><br/>
<a href="#1154">s_wakeup</a> - Orden de <strong>despertar</strong> al proceso, devuelve a su estado normal un proceso que ha sido <strong>dormido</strong> o <strong>congelado</strong>; a partir del momento en que reciba esta se&#241;al el proceso volver&#225; a ejecutarse y visualizarse normalmente. No se puede devolver a su estado normal un proceso que ha sido eliminado (matado) pues ya ha dejado de existir en la memoria del ordenador.<br/><br/>
Un proceso puede enviarse tambi&#233;n estas se&#241;ales a s&#237; mismo, teniendo en cuenta que el <a href="#1039">c&#243;digo identificador</a> de un proceso es siempre <a href="#1092">ID</a> (palabra reservada en el lenguaje para tal fin). La sentencia ser&#237;a como la siguiente:<br/><br/>
<strong>signal(</strong><a href="#1092">id</a><strong>,</strong> &lt;se&#241;al&gt;<strong>)</strong><br/><br/>
Auto-eliminar un proceso de esta forma, envi&#225;ndose una se&#241;al <a href="#1153">s_kill</a>, no destruir&#225; el proceso instant&#225;neamente, sino en la pr&#243;xima visualizaci&#243;n (<a href="#1029">FRAME</a>). Para eliminar un proceso de forma inmediata se puede utilizar la sentencia <a href="#1028">RETURN</a>.<br/><br/>
<strong>Todas las se&#241;ales enviadas a procesos tendr&#225;n efecto justo antes de la pr&#243;xima visualizaci&#243;n del juego</strong>, es decir, en la pr&#243;xima imagen (<a href="#1029">FRAME</a>) del juego (no instant&#225;neamente).<br/><br/>
Adem&#225;s de estas cuatro se&#241;ales existen otras cuatro que se corresponden directamente con las anteriores y son: <a href="#1157">s_kill_tree</a>, <a href="#1158">s_sleep_tree</a>, <a href="#1160">s_freeze_tree</a> y <a href="#1159">s_wakeup_tree</a>.<br/><br/>
Estas se&#241;ales se utilizan cuando se quieren enviar, no s&#243;lo al proceso indicado, sino, adem&#225;s, <strong>a todos los procesos que &#233;ste haya creado</strong>, es decir, si se env&#237;a una se&#241;al <a href="#1157">s_kill_tree</a> a un proceso, se destruir&#225; &#233;l y toda su descendencia (hijos, nietos, ...), todos los procesos que haya creado y los que hayan creado estos.<br/><br/>
Una excepci&#243;n a estas &#250;ltimas cuatro se&#241;ales es cuando existe un <strong>proceso hu&#233;rfano</strong>, esto es, un proceso cuyo padre (el proceso que lo llam&#243;) ya est&#225; muerto. Los procesos hu&#233;rfanos no recibir&#225;n la se&#241;al cuando se les env&#237;e a un proceso del cual son descendencia, pues al haber desaparecido su padre, &#233;ste no podr&#225; transmitir la se&#241;al a los procesos que cre&#243;.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_signal;
PRIVATE
    id_text;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write(0, 0, 0, 0, &quot;1 - crear el proceso&quot;);
    write(0, 0, 10, 0, &quot;2 - matar el proceso&quot;);
    write(0, 0, 20, 0, &quot;3 - dormir el proceso&quot;);
    write(0, 0, 30, 0, &quot;4 - congelar el proceso&quot;);
    write(0, 0, 40, 0, &quot;5 - despertar el proceso&quot;);
    id_text=write(0, 0, 190, 0, &quot;No hay proceso&quot;);
    LOOP
        IF (key(_1) AND NOT son)
            delete_text(id_text);
            mi_proceso();
            id_text=write(0, 0, 190, 0, &quot;Proceso vivo&quot;);
        END
        IF (key(_2) AND son)
            delete_text(id_text);
            signal(son, s_kill);
            id_text=write(0, 0, 190, 0, &quot;No hay proceso&quot;);
        END
        IF (key(_3) AND son)
            delete_text(id_text);
            signal(son, s_sleep);
            id_text=write(0, 0, 190, 0, &quot;Proceso dormido&quot;);
        END
        IF (key(_4) AND son)
            delete_text(id_text);
            signal(son, s_freeze);
            id_text=write(0, 0, 190, 0, &quot;Proceso congelado&quot;);
        END
        IF (key(_5) AND son)
            delete_text(id_text);
            signal(son, s_wakeup);
            id_text=write(0, 0, 190, 0, &quot;Proceso vivo&quot;);
        END
        FRAME;
    END
END

PROCESS mi_proceso()
BEGIN
    graph=100;
    LOOP
        x=160+get_distx(angle, 140);
        y=100+get_disty(angle, 80);
        angle+=5000;
        FRAME;
    END
END
</pre>
Este programa crear&#225; con la tecla <strong>1</strong> un proceso (<strong>mi_proceso</strong>) que va dando vueltas a la pantalla; con las teclas <strong>2</strong> a <strong>5</strong> se le enviar&#225;n a dicho proceso diferentes se&#241;ales utilizando esta funci&#243;n. El <a href="#1039">c&#243;digo identificador</a> de <strong>mi_proceso</strong> est&#225; en la variable local <strong>son</strong> (hijo) del programa principal por defecto.<br/><br/>
Cuando se crea un proceso, el sistema define la variable <a href="#1118">son</a> del padre con el <a href="#1039">c&#243;digo identificador</a> del hijo, y la variable <a href="#1117">father</a> del hijo con el c&#243;digo identificador del padre.<br/><br/>
<hr/>
<br/><br/>
<strong>signal(</strong><a href="#1042">TYPE</a> &lt;nombre de proceso&gt;<strong>,</strong> &lt;se&#241;al&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta segunda acepci&#243;n de la funci&#243;n <strong>signal</strong> es similar a la anterior, con la excepci&#243;n de que, en lugar de enviarle una se&#241;al a un proceso a partir de su <a href="#1039">c&#243;digo identificador</a>, permite enviar una se&#241;al <strong>a todos los procesos de un tipo determinado</strong> o a ellos y su descendencia si se utilizan las se&#241;ales como <strong>s_kill_tree</strong> (ver: <a href="#1042">Tipos de procesos</a>).<br/><br/>
Por ejemplo, si en un juego existen, o pueden existir, varios procesos de tipo <strong>enemigo</strong> y se quiere congelar a dichos procesos (sin congelar a su descendencia) se utilizar&#225; la siguiente sentencia:<br/><br/>
<strong>signal(TYPE enemigo, s_freeze);</strong><br/><br/>
Como se puede observar para enviar una se&#241;al a un proceso en concreto se necesita su <a href="#1039">c&#243;digo identificador</a> y para destruir a un grupo de procesos, que estos sean todos del mismo tipo, que se trate de un proceso y su descendencia, o bien conocer todos sus identificadores (para enviarles la se&#241;al uno a uno).<br/><br/>
Se puede enviar una se&#241;al a un tipo de procesos aun cuando no exista ning&#250;n proceso de ese tipo ejecut&#225;ndose en el juego. Pero si se env&#237;a una se&#241;al a un proceso que ya ha muerto, con su <a href="#1039">c&#243;digo identificador</a> (primera acepci&#243;n de la sentencia <strong>signal</strong>), se corre el riesgo de que dicho <a href="#1039">c&#243;digo identificador</a> ahora sea usado por otro proceso, siendo &#233;ste el que reciba la se&#241;al. Esto es si, por ejemplo, se pretende matar a un proceso que ya est&#225; muerto, cabe la posibilidad de que se est&#233; matando a otro.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Si se quieren eliminar todos los procesos y dejar &#250;nicamente al proceso actual, se puede utilizar la funci&#243;n <a href="#129">let_me_alone()</a>. Esta funci&#243;n env&#237;a una se&#241;al <strong>s_kill</strong> a todos los procesos, excepto al que ejecut&#243; dicha funci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#129">let_me_alone()</a> - <a href="#1039">C&#243;digos identificadores</a> - <a href="#1042">Tipos de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="159">sound()</h2><br/><br/>
<strong>sound(</strong>&lt;c&#243;digo del sonido&gt;<strong>,</strong> &lt;volumen&gt;<strong>,</strong> &lt;frecuencia&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>n&#250;mero de canal</strong> por el que se reproduce el sonido.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Hace sonar el efecto cuyo <strong>c&#243;digo de sonido</strong> se especifica como primer par&#225;metro. Primero, el sonido se debe haber cargado de un archivo PCM o WAV con las funciones <a href="#134">load_pcm()</a> o <a href="#134">load_wav()</a> que son las que devuelven el <strong>c&#243;digo de sonido</strong> correspondiente a dicho efecto.<br/><br/>
Como segundo par&#225;metro se debe especificar el <strong>volumen</strong> al que se desea reproducir el sonido, siendo <strong>0</strong> el volumen m&#237;nimo y <strong>256</strong> el volumen m&#225;ximo.<br/><br/>
Como tercer par&#225;metro se especificar&#225; la <strong>frecuencia</strong> (velocidad) a la que se desea reproducir el sonido, siendo <strong>256</strong> la frecuencia est&#225;ndar que reproducir&#225; el sonido original; a valores menores el sonido se reproducir&#225; m&#225;s grave, mientras qu a valores mayores de frecuencia, m&#225;s agudo.<br/><br/>
La funci&#243;n devuelve el <strong>n&#250;mero de canal</strong> que puede ser utilizado por las funciones <a href="#167">stop_sound()</a> para detener el sonido y <a href="#102">change_sound()</a> para modificar su volumen o su frecuencia.<br/><br/>
Existen un total de 16 canales de sonido, pudiendo sonar hasta 16 sonidos simult&#225;neamente.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_sound;

PRIVATE
    volumen=128;        // Valor medio (0..256)
    frecuencia=256;     // Valor medio (0..512)
    id_sonido, canal;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write(0, 0, 0, 0, &quot;Volumen: Arriba(+) / Abajo(-)&quot;);
    write_int(0, 0, 10, 0, offset volumen);
    write(0, 0, 20, 0, &quot;Frecuencia: Derecha(+) / Izquierda(-)&quot;);
    write_int(0, 0, 30, 0, offset frecuencia);
    write(0, 160, 180, 1, &quot;Pulse [ESPACIO] para emitir el el sonido.&quot;);
    write(0, 160, 190, 1, &quot;Utilice los cursores para cambiar los valores.&quot;);

    id_sonido = load_pcm(&quot;help\help.pcm&quot;, 0);

    LOOP
        IF (scan_code==_space)

            // Hace que suene
            canal = sound(id_sonido, volumen, frecuencia);

        END
        IF (key(_up) AND volumen&lt;256) volumen++; END
        IF (key(_down) AND volumen&gt;0) volumen--; END
        IF (key(_right) AND frecuencia&lt;512) frecuencia++; END
        IF (key(_left) AND frecuencia&gt;0) frecuencia--; END
        FRAME;
    END
END
</pre>
En el ejemplo se pone una pantalla de fondo y un texto explicativo, y se carga un sonido con la funci&#243;n <a href="#134">load_pcm()</a>; &#233;sta devuelve el <strong>identificador del sonido</strong>, que se guarda en la variable <strong>id_sonido</strong>.<br/><br/>
En el bucle principal, a cada pulsaci&#243;n de la barra espaciadora, se emitir&#225; el sonido con la funci&#243;n <strong>sound()</strong> con los par&#225;metros definidos en las variables <strong>volumen</strong> y <strong>frecuencia</strong>.<br/><br/>
Con las teclas de los cursores se podr&#225;n manipular estos valores para comprender as&#237; mejor su funcionamiento.<br/><br/>
El <strong>n&#250;mero de canal</strong> devuelto por <strong>sound()</strong>, que se guarda en la variable <strong>canal</strong>, se podr&#237;a haber utilizado para modificar el sonido con <a href="#102">change_sound()</a> o pararlo con <a href="#167">stop_sound()</a>.<br/><br/>
<hr/>
Ver: <a href="#134">load_pcm/wav()</a> - <a href="#102">change_sound()</a> - <a href="#167">stop_sound()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="160">sqrt()</h2><br/><br/>
<strong>sqrt(</strong>&lt;expresi&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La ra&#237;z cuadrada entera de la expresi&#243;n.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula la ra&#237;z cuadrada de la expresi&#243;n pasada como par&#225;metro, <strong>truncada a un n&#250;mero entero</strong>.<br/><br/>
Por ejemplo, <strong>sqrt(10)</strong> devolver&#225; como resultado <strong>3</strong> y no <strong>3.1623</strong> que es el valor real (aproximado) de la ra&#237;z cuadrada de diez.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_sqrt;

GLOBAL
    valores[15];
    n;

BEGIN
    FROM n=0 to 15;
        valores[n]=rand(0, 100000);
        write_int(0, 0, n*10, 0, offset valores[n]);
    END
    write(0, 0, 192, 0, &quot;Pulse [ESPACIO] para calcular su ra&#237;z cuadrada&quot;);
    LOOP
        IF (scan_code==_space)
            FROM n=0 TO 15;

                valores[n] = sqrt(valores[n]);

            END
        END
        FRAME;
    END
END
</pre>
Este programa imprimir&#225; en pantalla una lista de valores aleatoriamente seleccionados; cuando se pulse la barra espaciadora le aplicar&#225; la funci&#243;n <strong>sqrt()</strong> a todos estos valores, calculando su ra&#237;z cuadrada.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="161">start_fli()</h2><br/><br/>
<strong>start_fli(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
N&#250;mero de im&#225;genes de la animaci&#243;n.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Inicia una animaci&#243;n <strong>FLI/FLC</strong> contenida en el <strong>archivo</strong> especificado, en las coordenadas (<strong>x</strong>, <strong>y</strong>) (se debe especificar la coordenada superior izquierda de la ventana de visualizaci&#243;n).<br/><br/>
En el &lt;nombre de archivo&gt; se puede especificar la ruta de acceso, no siendo &#233;sta necesaria si el archivo se encuentra en el directorio de DIV Games Studio o en un subdirectorio cuyo nombre coincida con la extensi&#243;n del archivo (por ejemplo, &quot;fli\anima.fli&quot;).<br/><br/>
La animaci&#243;n debe coger por completo en pantalla, es decir, si la animaci&#243;n ocupa toda la pantalla, se debe fijar primero el modo de v&#237;deo con la funci&#243;n <a href="#157">set_mode()</a> y despu&#233;s iniciar con <strong>start_fli()</strong> la animaci&#243;n en las coordenadas (0, 0).<br/><br/>
La funci&#243;n devuelve, a t&#237;tulo informativo, el n&#250;mero de fotogramas de los que consta la animaci&#243;n completa.<br/><br/>
El sistema activar&#225; autom&#225;ticamente las paletas de color que pudiera tener la animaci&#243;n <strong>FLI/FLC</strong>, lo que puede presentar problemas en la representanci&#243;n de otros gr&#225;ficos o fuentes del programa, si &#233;stos hubieran sido dibujados con una paleta diferente.<br/><br/>
Si se pretenden combinar otros gr&#225;ficos con la animaci&#243;n en pantalla, &#233;sta debe tener una &#250;nica paleta de color (lo que se suele denominar &quot;<strong>palette low FLI/FLC</strong>&quot;) y los gr&#225;ficos se deben haber dibujado con esa misma paleta.<br/><br/>
Una vez iniciada la animaci&#243;n se ir&#225;n mostrando los fotogramas de la misma con respectivas llamadas a <a href="#115">frame_fli()</a>.<br/><br/>
<strong>S&#243;lo es posible tener una animaci&#243;n activa en cada momento</strong>, por lo que despu&#233;s de haberse iniciado una animaci&#243;n con <strong>start_fli()</strong> y haberse visualizado con <a href="#115">frame_fli()</a>, se debe finalizar &#233;sta con la funci&#243;n <a href="#108">end_fli()</a> antes de iniciar otra animaci&#243;n diferente.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_start_fli;
BEGIN

    start_fli(&quot;help\help.fli&quot;, 0, 0); // Se inicia una animaci&#243;n.

    LOOP
        frame_fli();
        FRAME;
    END
END
</pre>
En el ejemplo se inicia la animaci&#243;n contenida en el archivo <strong>help\help.fli</strong> con la funci&#243;n <strong>start_fli()</strong> en las coordenadas (0, 0) y se ejecuta esta animaci&#243;n indefinidamente.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#115">frame_fli()</a> utilizada para mostrar cada fotograma devolver&#225; 0 cuando la animaci&#243;n haya finalizado, por lo que para mostrar la animaci&#243;n una sola vez se deber&#237;a haber hecho:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_start_fli;

PRIVATE
    valor;

BEGIN
    start_fli(&quot;help\help.fli&quot;, 0, 0);
    REPEAT
        valor=frame_fli();
        FRAME;
    UNTIL (valor==0);
    end_fli();
END
</pre>
La funci&#243;n <a href="#153">reset_fli()</a> permite <strong>rebobinar</strong> la animaci&#243;n, para que la funci&#243;n <a href="#115">frame_fli()</a> contin&#250;e ejecut&#225;ndola desde el principio.<br/><br/>
<hr/>
Ver: <a href="#108">end_fli()</a> - <a href="#153">reset_fli()</a> - <a href="#115">frame_fli()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="162">start_mode7()</h2><br/><br/>
<strong>start_mode7(</strong>&lt;n&#250;mero de m7&gt;<strong>,</strong> &lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;gr&#225;fico exterior&gt;<strong>,</strong>               &lt;n&#250;mero de regi&#243;n&gt;<strong>,</strong> &lt;altura del horizonte&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
&#201;sta es una funci&#243;n avanzada que requiere que el usuario tenga cierta soltura para poder utilizarla.<br/><br/>
Crea una ventana de visualizaci&#243;n de un modo 7, es decir, visualiza un gr&#225;fico <strong>tridimensionalmente</strong> en un plano abatido; para conseguir este efecto se llamar&#225; a esta funci&#243;n con los siguientes par&#225;metros:<br/><br/>
<strong>&lt;n&#250;mero de m7&gt;</strong> - Se pueden crear hasta 10 ventanas de modo 7 en pantalla, con los n&#250;mero del <strong>0</strong> al <strong>9</strong>; si &#250;nicamente se quiere crear una, lo mejor es definir la n&#250;mero <strong>0</strong>. Este n&#250;mero ser&#225; necesario posteriormente para modificar los par&#225;metros de la ventana, pues el sistema necesitar&#225; saber cu&#225;l de las <strong>10</strong> posibles ventanas de modo 7 se quiere alterar.<br/><br/>
<strong>&lt;fichero&gt;</strong> - Los gr&#225;ficos que se pretendan abatir en la ventana deben estar en un fichero cuyo <strong>c&#243;digo de fichero</strong> se debe especificar aqu&#237;, como segundo par&#225;metro de la funci&#243;n. Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>&lt;gr&#225;fico&gt;</strong> - El tercer par&#225;metro debe ser el <strong>c&#243;digo del gr&#225;fico</strong> principal que se va a abatir en la ventana y debe pertenecer al fichero anteriormente indicado.<br/><br/>
<strong>&lt;gr&#225;fico exterior&gt;</strong> - Aqu&#237; se puede indicar un <strong>0</strong> si no se quiere que se vea ning&#250;n gr&#225;fico m&#225;s all&#225; del gr&#225;fico abatido en la perspectiva, o bien un <strong>c&#243;digo de gr&#225;fico</strong> del mismo fichero que se mostrar&#225; en la perspectiva m&#225;s all&#225; del <strong>gr&#225;fico principal</strong>, hasta alcanzar el horizonte. Este gr&#225;fico debe ser de un ancho y alto potencia de dos, no mayor de <strong>8192</strong> (estas potencias de dos son: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 y 8192), por ejemplo, podr&#237;a ser un gr&#225;fico de 64 puntos de ancho por 32 de alto; este gr&#225;fico se mostrar&#225; tambi&#233;n abatido.<br/><br/>
<strong>&lt;n&#250;mero de regi&#243;n&gt;</strong> - Aqu&#237; se indicar&#225; la regi&#243;n rectangular de pantalla en la que se va a mostrar el modo 7. Si se indica <strong>0</strong> como n&#250;mero de regi&#243;n, se mostrar&#225; en toda la pantalla. El resto de regiones se deben definir previamente con la funci&#243;n <a href="#106">define_regi&#243;n()</a> (una <strong>regi&#243;n</strong> no es m&#225;s que una zona rectangular de la pantalla).<br/><br/>
<strong>&lt;altura del horizonte&gt;</strong> - Como &#250;ltimo par&#225;metro se indicar&#225; a cu&#225;ntos puntos desde la parte superior de la ventana se quiere situar la l&#237;nea del horizonte. Si la c&#225;mara se sit&#250;a por encima del plano abatido, entonces no se mostrar&#225; nada por encima de la l&#237;nea del horizonte (ese hueco se suele rellenar con otra ventana de scroll o de modo 7); en cambio si la camara se sit&#250;a por debajo del plano, entonces no se mostrar&#225; nada por debajo de la l&#237;nea del horizonte.<br/><br/>
<hr/>
<br/><br/>
<strong>Adem&#225;s de la llamada a la funci&#243;n se deben inicializar algunos valores de la</strong> <a href="#1102">estructura global m7</a> <strong>para el correcto funcionamiento de la ventana</strong>. &#201;sta es una estructura de 10 registros (uno para cada posible ventana de modo 7) y cada registro tiene los siguientes campos:<br/><br/>
<strong>camera</strong>   - <a href="#1039">C&#243;digo identificador</a> de la c&#225;mara<br/>
<strong>height</strong>   - Altura de la c&#225;mara<br/>
<strong>distance</strong> - Distancia de la c&#225;mara<br/>
<strong>horizon</strong>  - Altura del horizonte<br/>
<strong>focus</strong>    - Focal de visi&#243;n<br/>
<strong>z</strong>        - Plano de profundidad<br/>
<strong>color</strong>    - Color del exterior<br/>
<br/><br/>
<strong>Importante:</strong> El campo <strong>camera</strong> es <strong>imprescindible</strong> inicializarlo para que se active la ventana de modo 7 ya que, sin este campo, la ventana no puede determinar desde d&#243;nde se debe <strong>ver</strong> el plano abatido.<br/><br/>
La c&#225;mara se situar&#225; en el plano abatido a la distancia (<strong>distance</strong>) indicada del proceso cuyo <a href="#1039">c&#243;digo identificador</a> se haya puesto en <strong>camera</strong>, y mirando en su mismo &#225;ngulo (el que indique su variable local <a href="#1129">angle</a>). La altura a la que se sit&#250;a la c&#225;mara respecto al suelo ser&#225; la indicada en el campo <strong>height</strong>.<br/><br/>
Ver la ayuda sobre la <a href="#1102">estructura m7</a> para m&#225;s informaci&#243;n sobre estos campos, o para saber c&#243;mo acceder a ellos.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_start_mode7;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);

    start_mode7(0, fichero1, 4, 0, 0, 64);

    m7.height = 64;
    m7.distance = 32;
    m7.color = 162;
    m7.camera = id;

    write(0, 160, 0, 1, &quot;Utilice los cursores para moverse&quot;);
    LOOP
        IF (key(_right)) angle-=8000; END
        IF (key(_left)) angle+=8000; END
        IF (key(_up)) advance(6); END
        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero de gr&#225;ficos y entonces se crea un modo 7 tridimensional con la funci&#243;n <strong>start_mode7()</strong>. A esta &#250;ltima se le pasan los siguientes par&#225;metros:<br/><br/>
<strong>0</strong> - N&#250;mero de ventana de modo 7 (la primera, puesto que s&#243;lo se crear&#225; una ventana de esta clase).<br/><br/>
<strong>fichero1</strong> - C&#243;digo del fichero del que se deben tomar los gr&#225;ficos; este es el c&#243;digo del archivo <strong>help.fpg</strong> que se carg&#243; con la funci&#243;n <a href="#132">load_fpg()</a>.<br/><br/>
<strong>4</strong> - C&#243;digo del gr&#225;fico principal a abatir dentro del modo 7; para ver este gr&#225;fico se debe cargar el fichero con el <strong>Men&#250; de ficheros</strong> y as&#237; poder observar cu&#225;l es el gr&#225;fico con <strong>c&#243;digo 4</strong>.<br/><br/>
<strong>0</strong> - C&#243;digo de gr&#225;fico secundario, con un 0 se indica que no habr&#225; gr&#225;fico secundario (exterior) en el modo 7, luego el exterior se visualizar&#225; del color que indique la variable <strong>m7[0].color</strong>. Para observar el efecto de poner un <strong>gr&#225;fico exterior</strong> se puede cambiar este par&#225;metro, por ejemplo, por un <strong>100</strong> (que es el c&#243;digo de una bola marr&#243;n de 32 por 32 puntos en el fichero <strong>help.fpg</strong>).<br/><br/>
<strong>0</strong> - N&#250;mero de regi&#243;n de la pantalla en la que se debe <strong>colocar</strong> el modo 7; con 0 se indica que se debe colocar en la pantalla entera.<br/><br/>
<strong>64</strong> - Altura del horizonte, con este &#250;ltimo par&#225;metro se indica que la l&#237;nea del horizonte se situar&#225; a 64 puntos del inicio superior de la ventana.<br/><br/>
Tras llamar a la funci&#243;n <strong>start_mode7()</strong> el programa define los siguientes valores de la <a href="#1102">estructura global m7</a>:<br/><br/>
<strong>m7.height=64;</strong> - Para indicar que la c&#225;mara se debe situar a 64 puntos sobre el suelo.<br/><br/>
<strong>m7.distance=32;</strong> - Para indicar que la c&#225;mara se debe situar 32 puntos por detr&#225;s del proceso c&#225;mara.<br/><br/>
<strong>m7.color=162;</strong> - Para indicar que el exterior se debe visualizar del color n&#250;mero 162 de la paleta.<br/><br/>
<strong>m7.camera=</strong><a href="#1092">id</a><strong>;</strong> - Para indicar que el proceso c&#225;mara ser&#225; el proceso actual.<br/><br/>
La c&#225;mara se situar&#225; 32 puntos por detr&#225;s del proceso principal, a 64 puntos de altura y mirando en el &#225;ngulo que indique la variable <a href="#1129">angle</a> del mismo.<br/><br/>
Tras estas inicializaciones el programa ejemplo se quedar&#225; en un bucle que simplemente controla con los cursores el &#225;ngulo (<a href="#1129">angle</a>) del proceso principal, que ser&#225; el &#225;ngulo de la c&#225;mara y, cuando se pulse la tecla <strong>cursor arriba</strong>, se llamar&#225; a la funci&#243;n <a href="#101">advance()</a> para que el proceso principal avance 6 puntos (y por consiguiente la c&#225;mara del modo 7).<br/><br/>
<hr/>
<strong>C&#243;mo visualizar gr&#225;ficos de procesos sobre el modo 7</strong><hr/>
<br/><br/>
Para crear un proceso cuyo gr&#225;fico se visualice en el modo 7, se debe definir su variable local <a href="#1122">ctype</a> como <a href="#1169">c_m7</a> (<strong>tipo de coordenada</strong> como <strong>coordenada de modo 7</strong>), lo que se har&#225; con la siguiente sentencia:<br/><br/>
<strong>ctype=c_m7;</strong><br/><br/>
Una vez hecho esto el proceso se visualizar&#225; en el modo 7 con su gr&#225;fico (<a href="#1126">graph</a>) escalado acorde a la distancia a la que est&#233;. El proceso &#250;nicamente debe modificar sus variables <a href="#1123">x</a> e <a href="#1124">y</a> para moverse por el plano abatido.<br/><br/>
<hr/>
<br/><br/>
<strong>Cuando un proceso pertenezca al modo 7 (se haya asignado el valor c_m7 a su variable local</strong> <a href="#1122">ctype</a><strong>):</strong><br/><br/>
- Sus variables <a href="#1123">x</a> e <a href="#1124">y</a> estar&#225;n referidas al punto del gr&#225;fico principal abatido sobre el cual se situar&#225; el gr&#225;fico del proceso.<br/><br/>
- Su variable <a href="#1125">z</a> perder&#225; su efecto, ya que los gr&#225;ficos aparecer&#225;n ordenados por estricto orden de profundidad. Esta variable valdr&#225; &#250;nicamente para indicar prioridades de impresi&#243;n en gr&#225;ficos que se sit&#250;en, exactamente, en la misma profundidad del plano.<br/><br/>
- El proceso ser&#225; eliminado autom&#225;ticamente cuando se elimine la ventana de modo 7 a la que pertenece el proceso, con la funci&#243;n <a href="#165">stop_mode7()</a>, o cuando se cambie el modo de v&#237;deo con la funci&#243;n <a href="#157">set_mode()</a>, ya que al hacerlo se eliminar&#225;n tambi&#233;n las ventanas de modo 7.<br/><br/>
<hr/>
<br/><br/>
Si hubiera varias ventanas de <strong>modo 7</strong> el proceso se visualizar&#237;a por defecto en todas, si &#250;nicamente se tuviera que visualizar el algunas de ellas, se deber&#237;a definir su variable local <a href="#1134">cnumber</a>. Por ejemplo, si hubiera 6 ventanas de modo 7 (de la n&#250;mero 0 a la 5) y se quisiera que un proceso se visualizara &#250;nicamente en las ventanas 0 y 2, se deber&#237;a incluir en el mismo la siguiente sentencia:<br/><br/>
<strong>cnumber=c_0+c_2;</strong><br/><br/>
<hr/>
<br/><br/>
Para que un proceso tenga varios gr&#225;ficos (varias vistas), dependiendo del &#225;ngulo desde el que se le mire, se debe definir su gr&#225;fico con la variable local <a href="#1132">xgraph</a> (en lugar de la variable <a href="#1126">graph</a>). Para definir esta variable primero se debe crear una tabla (de cualquier nombre) indicando en primer lugar el <strong>n&#250;mero de vistas</strong> del gr&#225;fico y despu&#233;s los <strong>c&#243;digos de los gr&#225;ficos</strong> para estas vistas, comenzando por el <strong>&#225;ngulo 0</strong> y en sentido contrario a las agujas del reloj. Por ejemplo:<br/><br/>
<strong>GLOBAL</strong><br/>
<strong>vistas_coche[]=4, 100, 101, 102, 103;</strong><br/>
<br/><br/>
La tabla <strong>vistas_coche</strong> definir&#237;a 4 vistas: el gr&#225;fico 100 para &#225;ngulos pr&#243;ximos a 0 grados, el gr&#225;fico 101 para &#225;ngulos pr&#243;ximos a 90 grados, el 102 para &#225;ngulos pr&#243;ximos a 180 grados, etc.<br/><br/>
Y despu&#233;s en el c&#243;digo del proceso se deber&#237;a inicializar la variable <a href="#1132">xgraph</a> con la siguiente sentencia:<br/><br/>
<strong>xgraph=OFFSET vistas_coche;</strong><br/><br/>
Para poder observar un ejemplo de lo aqu&#237; expuesto, lo mejor es examinar alguno de los juegos ejemplo de DIV Games Studio que utilizan esta t&#233;cnica, por lo que se remite al lector directamente a los comentarios de estos programas (por ejemplo v&#233;ase el ejemplo <strong>Speed for dummies</strong>).<br/><br/>
<hr/>
Ver: <a href="#165">stop_mode7()</a> - <a href="#1102">Estructura m7</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="163">start_scroll()</h2><br/><br/>
<strong>start_scroll(</strong>&lt;n&#250;mero de scroll&gt;<strong>,</strong> &lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;gr&#225;fico fondo&gt;<strong>,</strong>                &lt;n&#250;mero de regi&#243;n&gt;<strong>,</strong> &lt;indicador de bloqueo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta es una funci&#243;n de cierta complejidad, que requiere que el usuario tenga cierta soltura (haya realizado alg&#250;n programa antes) para poder utilizarla.<br/><br/>
Crea una ventana de scroll, en la que se realizar&#225; una panor&#225;mica sobre un gr&#225;fico de fondo (el decorado del juego). Es decir, utilizando como fondo del juego un gr&#225;fico m&#225;s grande que la ventana de visualizaci&#243;n, se podr&#225; mostrar una parte del mismo e ir desplaz&#225;ndolo en cualquier direcci&#243;n.<br/><br/>
Para conseguir este efecto se llamar&#225; a esta funci&#243;n con los siguientes par&#225;metros:<br/><br/>
<strong>&lt;n&#250;mero de scroll&gt;</strong> - Se pueden crear hasta 10 ventanas de scroll en pantalla, con los n&#250;meros del <strong>0</strong> al <strong>9</strong>; si s&#243;lo se quiere crear una, lo mejor es definir la n&#250;mero <strong>0</strong>. Este n&#250;mero ser&#225; necesario posteriormente para modificar los par&#225;metros de la ventana, pues el sistema necesitar&#225; saber cu&#225;l de las <strong>10</strong> posibles ventanas de scroll se quiere alterar.<br/><br/>
<strong>&lt;fichero&gt;</strong> - Los gr&#225;ficos que se pretendan mostrar como fondo o decorado en dicha ventana deben estar en un fichero cuyo <strong>c&#243;digo de fichero</strong> se debe especificar aqu&#237;, como segundo par&#225;metro de la funci&#243;n. Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>&lt;gr&#225;fico&gt;</strong> - El tercer par&#225;metro debe ser el <strong>c&#243;digo del gr&#225;fico</strong> principal que se va a mostrar como fondo en la ventana y debe pertenecer al fichero anteriormente indicado. Este gr&#225;fico suele ser el decorado principal del juego sobre el que se va a desarrollar la acci&#243;n, un gr&#225;fico m&#225;s grande que la ventana de visualizaci&#243;n, que se ir&#225; desplazando en una o varias direcciones y sobre el que se situar&#225;n los gr&#225;ficos del juego.<br/><br/>
La ventana de scroll se situar&#225; inicialmente con el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong> de este gr&#225;fico en la esquina superior izquierda, cuando se haya definido este punto en el <strong>editor gr&#225;fico</strong>.<br/><br/>
<strong>&lt;gr&#225;fico fondo&gt;</strong> - Aqu&#237; se indicar&#225; un <strong>0</strong> si se quiere un s&#243;lo plano de scroll (un s&#243;lo gr&#225;fico de fondo), o bien otro <strong>c&#243;digo de gr&#225;fico</strong> si se quiere que &#233;ste aparezca como segundo plano de scroll (a mayor profundidad), detr&#225;s del plano principal. Para que se vea este plano de fondo es imprescindible que el <strong>gr&#225;fico principal</strong> (primer plano) tenga partes dibujadas con el color n&#250;mero 0 de la paleta, pues estas zonas transparentes ser&#225;n las que permitir&#225;n ver a trav&#233;s de ellas el <strong>gr&#225;fico de fondo</strong>.<br/><br/>
<strong>&lt;n&#250;mero de regi&#243;n&gt;</strong> - Aqu&#237; se indicar&#225; la regi&#243;n rectangular de pantalla en la que se va a mostrar el scroll, si se indica <strong>0</strong> como n&#250;mero de regi&#243;n, se mostrar&#225; en toda la pantalla. El resto de regiones se deben definir previamente con la funci&#243;n <a href="#106">define_region()</a> (una <strong>regi&#243;n</strong> no es m&#225;s que una zona rectangular de la pantalla).<br/><br/>
<strong>&lt;indicador de bloqueo&gt;</strong> - Aqu&#237; se indicar&#225; un valor que define si cada uno de los dos planos de scroll es c&#237;clico en horizontal y vertical. Por ejemplo, un plano es c&#237;clico en horizontal cuando al salirse del dibujo por la derecha aparece el dibujo por la izquierda. Para componer este valor se deben sumar las siguientes cantidades:<br/><br/>
<strong> + 1</strong> - Si el primer plano es c&#237;clico horizontalmente.<br/>
<strong> + 2</strong> - Si el primer plano es c&#237;clico verticalmente.<br/>
<strong> + 4</strong> - Si el segundo plano es c&#237;clico horizontalmente.<br/>
<strong> + 8</strong> - Si el segundo plano es c&#237;clico verticalmente.<br/>
<br/><br/>
Es decir, <strong>0</strong> si ninguno de los dos planos debe ser c&#237;clico, <strong>15</strong> (<strong>1</strong>+<strong>2</strong>+<strong>4</strong>+<strong>8</strong>) si ambos planos deben ser c&#237;clicos en ambos ejes, <strong>12</strong> (<strong>4</strong>+<strong>8</strong>) si &#250;nicamente debe ser c&#237;clico el segundo plano, etc.<br/><br/>
Cuando un gr&#225;fico (principal o de fondo) sea m&#225;s peque&#241;o que la ventana de visualizaci&#243;n, el sistema forzar&#225; a que su plano de scroll sea c&#237;clico pues, en caso contrario, no se podr&#237;a rellenar la ventana de scroll por completo, sin repetir <strong>c&#237;clicamente</strong> el gr&#225;fico (en mosaico).<br/><br/>
<hr/>
<br/><br/>
<strong>Adem&#225;s de la llamada a la funci&#243;n se deben inicializar algunos valores de la</strong> <a href="#1101">estructura global scroll</a> <strong>para el correcto funcionamiento de la ventana</strong>. &#201;sta es una estructura de 10 registros (uno para cada posible ventana de scroll) y cada registro tiene los siguientes campos:<br/><br/>
<strong>x0, y0</strong>  - Coordenadas del primer plano<br/>
<strong>x1, y1</strong>  - Coordenadas del segundo plano<br/>
<strong>z</strong>       - Plano de profundidad<br/>
<strong>camera</strong>  - <a href="#1039">C&#243;digo identificador</a> de la c&#225;mara<br/>
<strong>ratio</strong>   - Velocidad relativa del segundo plano<br/>
<strong>speed</strong>   - Velocidad m&#225;xima del primer plano<br/>
<strong>region1</strong> - Primera regi&#243;n de pantalla<br/>
<strong>region2</strong> - Segunda regi&#243;n de pantalla<br/>
<br/><br/>
Hay dos formas de programar el movimiento de las ventanas de scroll:<br/><br/>
- Manualmente, modificando en cada imagen del juego los campos <strong>x0</strong>, <strong>y0</strong>, <strong>x1</strong> e <strong>y1</strong> de esta estructura (las coordenadas de los planos de scroll).<br/><br/>
- Autom&#225;ticamente, para lo que se necesita el <a href="#1038">c&#243;digo identificador</a> de un proceso en el campo <strong>camera</strong> de esta estructura. Siendo a partir de entonces el sistema el encargado de realizar en la ventana de scroll un seguimiento al gr&#225;fico de este proceso.<br/><br/>
Ver la ayuda sobre la <a href="#1101">estructura scroll</a> para m&#225;s informaci&#243;n sobre estos campos, o para saber c&#243;mo acceder a ellos.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_start_scroll;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);

    start_scroll(0, fichero1, 103, 102, 0, 15);

    scroll.camera=id;

    ctype=c_scroll;
    graph=100;
    write(0, 160, 0, 1, &quot;Utilice los cursores para moverse&quot;);
    LOOP
        IF (key(_right)) x+=2; END
        IF (key(_left)) x-=2; END
        IF (key(_down)) y+=2; END
        IF (key(_up)) y-=2; END
        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero de gr&#225;ficos y entonces se crea una ventana de scroll con la funci&#243;n <strong>start_scroll()</strong>. A esta &#250;ltima se le pasan los siguientes par&#225;metros:<br/><br/>
<strong>0</strong> - N&#250;mero de ventana de scroll (la primera, puesto que s&#243;lo se crear&#225; una ventana de esta clase).<br/><br/>
<strong>fichero1</strong> - C&#243;digo del fichero del que se deben tomar los gr&#225;ficos; este es el c&#243;digo del archivo <strong>help.fpg</strong> que se carg&#243; con la funci&#243;n <a href="#132">load_fpg()</a>.<br/><br/>
<strong>103</strong> - C&#243;digo del gr&#225;fico principal (primer plano) del scroll, para ver este gr&#225;fico se debe cargar el fichero con el <strong>Men&#250; de ficheros</strong> y as&#237; poder observar cu&#225;l es el gr&#225;fico con <strong>c&#243;digo 103</strong>.<br/><br/>
<strong>102</strong> - C&#243;digo de gr&#225;fico secundario (segundo plano, de fondo); &#233;ste es el gr&#225;fico que se mostrar&#225; en la ventana de scroll <strong>detr&#225;s</strong> del gr&#225;fico principal.<br/><br/>
<strong>0</strong> - N&#250;mero de regi&#243;n de la pantalla en la que se debe <strong>colocar</strong> el scroll; con 0 se indica que se debe colocar en la pantalla entera.<br/><br/>
<strong>15</strong> - Indicador de bloqueo, con 15 (1+2+4+8) se indica que tanto el primer plano como el segundo ser&#225;n c&#237;clicos en ambos ejes (horizontal y vertical).<br/><br/>
Tras llamar a la funci&#243;n <strong>start_scroll()</strong> el programa define el campo <strong>camera</strong> de la <a href="#1101">estructura scroll</a>, asign&#225;ndole el <a href="#1039">c&#243;digo identificador</a> del proceso principal (con la sentencia <strong>scroll.camera=</strong><a href="#1092">id</a><strong>;</strong>); con esto se convierte el scroll en <strong>autom&#225;tico</strong> siguiendo a partir de ese momento al gr&#225;fico del proceso principal.<br/><br/>
El programa contin&#250;a definiendo su <strong>tipo de coordenada</strong> como <strong>coordenada de scroll</strong> (con la sentencia <strong>ctype=c_scroll;</strong>), definiendo su gr&#225;fico como el n&#250;mero 100, que es una bola marr&#243;n (con <strong>graph=100;</strong>), imprimiendo un mensaje y despu&#233;s permanecer&#225; en un bucle en el que se pueden variar las coordenadas de este proceso (las variables <a href="#1123">x</a> e <a href="#1124">y</a>) con las teclas de los cursores.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_start_scroll;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);

    start_scroll(0, fichero1, 103, 102, 0, 15);

    write(0, 160, 0, 1, &quot;Utilice los cursores desplazar el scroll&quot;);
    LOOP
        IF (key(_right))
            scroll.x0+=2;
            scroll.x1+=1;
        END
        IF (key(_left))
            scroll.x0-=2;
            scroll.x1-=1;
        END
        IF (key(_down))
            scroll.y0+=2;
            scroll.y1+=1;
        END
        IF (key(_up))
            scroll.y0-=2;
            scroll.y1-=1;
        END
        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero de gr&#225;ficos y entonces se crea una ventana de scroll con la funci&#243;n <strong>start_scroll()</strong>. A esta &#250;ltima se le pasan exactamente los mismos par&#225;metros que en el ejemplo anterior.<br/><br/>
Tras esto, el programa permanecer&#225; en un bucle dentro del cual; al detectarse las teclas de los cursores se variar&#225;n los campos <strong>x0</strong>, <strong>y0</strong>, <strong>x1</strong> e <strong>y1</strong> de la <a href="#1101">estructura global scroll</a>, los cuales definen las coordenadas de los dos planos del scroll (<strong>x0</strong>, <strong>y0</strong> son las del primer plano y <strong>x1</strong>, <strong>y1</strong> las del segundo).<br/><br/>
Se puede observar la diferencia entre ambos m&#233;todos; este &#250;ltimo, al no haber inicializado el campo <strong>camera</strong> de la estrucutra, podr&#225; manipular directamente las coordenadas de ambos planos.<br/><br/>
<hr/>
<strong>C&#243;mo visualizar gr&#225;ficos de procesos sobre el scroll</strong><hr/>
<br/><br/>
Para crear un proceso cuyo gr&#225;fico se visualice en la ventana de scroll, se debe definir su variable local <a href="#1122">ctype</a> como <a href="#1168">c_scroll</a> (<strong>tipo de coordenada</strong> como <strong>coordenada de scroll</strong>), lo que se har&#225; con la siguiente sentencia:<br/><br/>
<strong>ctype=c_scroll;</strong><br/><br/>
Una vez hecho esto, el proceso se visualizar&#225; en el scroll con su gr&#225;fico (definido en la variable local <a href="#1126">graph</a>). El proceso &#250;nicamente debe modificar sus variables <a href="#1123">x</a> e <a href="#1124">y</a> para moverse por el scroll.<br/><br/>
<hr/>
<br/><br/>
<strong>Cuando un proceso pertenezca al scroll (se haya asignado el valor c_scroll a su variable local</strong> <a href="#1122">ctype</a><strong>):</strong><br/><br/>
- Sus variables <a href="#1123">x</a> e <a href="#1124">y</a> estar&#225;n referidas al punto del gr&#225;fico del primer plano sobre el cual se situar&#225; el gr&#225;fico del proceso.<br/><br/>
- Su variable <a href="#1125">z</a> ahora ser&#225; relativa a las <strong>variables z</strong> de los procesos que tambi&#233;n pertenezcan a la misma ventana de scroll. Es decir, cada vez que se pinte una ventana de scroll, se pintar&#225;n justo a continuaci&#243;n todos los gr&#225;ficos que pertenecen a la misma (ordenados por su <strong>z</strong>), y despu&#233;s se seguir&#225;n pintando los procesos que <strong>no pertenecen a dicha ventana de scroll</strong>.<br/><br/>
- El proceso ser&#225; eliminado autom&#225;ticamente cuando se elimine la ventana de scroll a la que pertenece el proceso, con la funci&#243;n <a href="#166">stop_scroll()</a>. O cuando se cambie el modo de v&#237;deo con la funci&#243;n <a href="#157">set_mode()</a>, ya que al hacerlo se eliminar&#225;n tambi&#233;n las ventanas de scroll.<br/><br/>
<hr/>
<br/><br/>
Si hubiera varias ventanas de <strong>scroll</strong> el proceso si visualizar&#237;a por defecto en todas; si &#250;nicamente se debiera visualizar el algunas de ellas, se deber&#237;a definir su variable local <a href="#1134">cnumber</a>. Por ejemplo, si hubiera 6 ventanas de scroll (de la n&#250;mero 0 a la 5) y se quisiera que un proceso se visualizara &#250;nicamente en las ventanas 0 y 2, se deber&#237;a incluir en el mismo la siguiente sentencia:<br/><br/>
<strong>cnumber=c_0+c_2;</strong><br/><br/>
Para poder observar un ejemplo de lo aqu&#237; expuesto, lo mejor es examinar alguno de los juegos ejemplo de DIV Games Studio que utilizan esta t&#233;cnica, por lo que se remite al lector directamente a los comentarios de estos programas (por ejemplo v&#233;ase el ejemplo <strong>Helioball</strong>).<br/><br/>
<hr/>
Ver: <a href="#166">stop_scroll()</a> - <a href="#152">refresh_scroll()</a> - <a href="#140">move_scroll()</a> - <a href="#1101">Estructura scroll</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="164">stop_cd()</h2><br/><br/>
<strong>stop_cd()</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Detiene la reproducci&#243;n CD-Audio, parando la canci&#243;n que estuviese sonando. Las canciones se reproducen con la funci&#243;n <a href="#144">play_cd()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_stop_cd;
BEGIN
    write(0, 160, 0, 1, &quot;Pulse [ENTER] para poner en marcha el CD.&quot;);
    write(0, 160, 10, 1, &quot;Pulse [ESPACIO] para parar el CD.&quot;);
    LOOP
        IF (scan_code==_space)

            stop_cd(); // Para el CD

        END
        IF (scan_code==_enter)
            play_cd(2, 0);
        END
        FRAME;
    END
END
</pre>
En el ejemplo se ponen los mensajes necesarios. En cada paso del bucle, si se pulsa la barra espaciadora, se parar&#225; el CD con la funci&#243;n <strong>stop_cd()</strong>.<br/><br/>
Si se pulsa la tecla Enter se pondr&#225; en marcha el CD con la funci&#243;n <a href="#144">play_cd()</a>.<br/><br/>
El volumen de reproducci&#243;n de cd-audio se puede controlar con la estructura <a href="#1104">setup</a> y la funci&#243;n <a href="#178">set_volume()</a>.<br/><br/>
<hr/>
Ver: <a href="#144">play_cd()</a> - <a href="#127">is_play_cd()</a> - <a href="#178">set_volume()</a> - <a href="#1104">Estructura setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="165">stop_mode7()</h2><br/><br/>
<strong>stop_mode7(</strong>&lt;n&#250;mero de m7&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Elimina la ventana de modo 7 cuyo n&#250;mero (del 0 al 9) se pasa como par&#225;metro. Este &lt;n&#250;mero de m7&gt; es el que se indic&#243; como primer par&#225;metro en la funci&#243;n <a href="#162">start_mode7()</a>, es necesario debido a que pueden haber hasta 10 ventanas diferentes de modo 7, y el sistema necesita saber cu&#225;l de ellas se est&#225; finalizando.<br/><br/>
Al eliminar una ventana de modo 7, morir&#225;n autom&#225;ticamente todos los procesos que pertenezcan en exclusiva a dicha ventana, es decir, todos los procesos que tengan su variable <a href="#1122">ctype</a> con el valor <a href="#1169">c_m7</a> y no se est&#233;n visualizando en ninguna otra ventana de modo 7.<br/><br/>
<strong>Importante:</strong> Al cambiar de modo de v&#237;deo con la funci&#243;n <a href="#157">set_mode()</a> todas las ventanas de modo 7 (y sus procesos) ser&#225;n igualmente eliminadas, no siendo en este caso necesario usar esta funci&#243;n (<strong>stop_mode7()</strong>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_stop_mode7;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    write(0, 160, 0, 1, &quot;Pulse [ENTER] para poner modo 7.&quot;);
    write(0, 160, 10, 1, &quot;Pulse [ESPACIO] para quitar modo 7.&quot;);
    write(0, 160, 190, 1, &quot;Utilice el rat&#243;n para moverse por el modo 7.&quot;);
    angle=90000;
    LOOP
        IF (scan_code==_space)

            stop_mode7(0); // Se quita el modo 7

        END
        IF (scan_code==_enter)
            start_mode7(0, 0, 4, 0, 0, 64);
            m7.camera=id;
        END
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero de gr&#225;ficos y se muestran las instrucciones del programa en pantalla, tras lo cual las coordenadas del proceso principal, que servir&#225; de c&#225;mara del modo 7, ser&#225;n controladas con el rat&#243;n (mediante las sentencias <strong>x=mouse.x;</strong> y <strong>y=mouse.y</strong>).<br/><br/>
Cuando se pulse la tecla ENTER se crear&#225; una ventana de modo 7 con un gr&#225;fico de un circuito abatido, controlada por el proceso principal.<br/><br/>
Al pulsarse la barra espaciadora se invocar&#225; a la funci&#243;n <strong>stop_mode7()</strong>, eliminando esta la ventana de visualizaci&#243;n en modo 7.<br/><br/>
<hr/>
<br/><br/>
Crear una ventana de modo 7 es un procedimiento algo avanzado y requiere iniciar varios par&#225;metros, como en este caso la c&#225;mara, algunos de ellos requeridos por la funci&#243;n <a href="#162">start_mode7()</a> y otros contenidos en la estructura global <a href="#1102">m7</a> (como la variable <strong>m7.camera</strong> utilizada en el ejemplo).<br/><br/>
<hr/>
Ver: <a href="#162">start_mode7()</a> - <a href="#1102">Estructura m7</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="166">stop_scroll()</h2><br/><br/>
<strong>stop_scroll(</strong>&lt;n&#250;mero de scroll&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Elimina la ventana de scroll cuyo n&#250;mero (del 0 al 9) se pasa como par&#225;metro. Este &lt;n&#250;mero de scroll&gt; es el que se indic&#243; como primer par&#225;metro en la funci&#243;n <a href="#163">start_scroll()</a> y es necesario debido a que puede haber hasta 10 ventanas diferentes de scroll, y el sistema necesita saber cu&#225;l de ellas se est&#225; finalizando.<br/><br/>
Al eliminar una ventana de scroll morir&#225;n, autom&#225;ticamente, todos los procesos que pertenezcan en exclusiva a dicha ventana, es decir, todos los procesos que tengan su variable <a href="#1122">ctype</a> con el valor <a href="#1168">c_scroll</a> y no se est&#233;n visualizando en ninguna otra ventana de scroll.<br/><br/>
<strong>Importante:</strong> Al cambiar de modo de v&#237;deo con la funci&#243;n <a href="#157">set_mode()</a> todas las ventanas de scroll (y sus procesos) ser&#225;n igualmente eliminadas, no siendo en este caso necesario usar esta funci&#243;n (<strong>stop_scroll()</strong>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_stop_scroll;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    write(0, 160, 0, 1, &quot;Pulse [ENTER] para activar la ventana de scroll.&quot;);
    write(0, 160, 10, 1, &quot;Pulse [ESPACIO] para finalizar el scroll.&quot;);
    LOOP
        IF (scan_code==_space)

            stop_scroll(0); // Se quita el scroll.

        END
        IF (scan_code==_enter)
            start_scroll(0, 0, 103, 102, 0, 15);
        END
        scroll.x0+=1;
        scroll.y0+=1;
        scroll.x1-=1;
        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero de gr&#225;ficos y se muestran las instrucciones del programa en pantalla.<br/><br/>
Cuando se pulse la tecla ENTER se crear&#225; una ventana de scroll y al pulsarse la barra espaciadora se invocar&#225; a la funci&#243;n <strong>stop_scroll()</strong>, eliminando &#233;sta la ventana de visualizaci&#243;n del scroll.<br/><br/>
Dentro del bucle principal se acceden a las coordenadas del scroll contenidas en la <a href="#1101">estructura global scroll</a> para desplazar manualmente la ventana de scroll (<strong>scroll.x0+=1; ...</strong>).<br/><br/>
<hr/>
<br/><br/>
Crear una ventana de scroll es un procedimiento algo avanzado y requiere iniciar varios par&#225;metros, algunos de ellos requeridos por la funci&#243;n <a href="#163">start_scroll()</a> y otros contenidos en la <a href="#1101">estructura global scroll</a> (como la variable <strong>scroll.x0</strong> utilizada en el ejemplo).<br/><br/>
<hr/>
Ver: <a href="#163">start_scroll()</a> - <a href="#1101">Estructura scroll</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="167">stop_sound()</h2><br/><br/>
<strong>stop_sound(</strong>&lt;n&#250;mero de canal&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Para el sonido que est&#233; sonando por el canal pasado como par&#225;metro.<br/><br/>
El &lt;n&#250;mero de canal&gt; requerido es el valor que retorna la funci&#243;n <a href="#159">sound()</a> cuando se inicia la reproducci&#243;n de un efecto de sonido.<br/><br/>
Existen un total de 16 canales de sonido, pudiendo sonar hasta 16 sonidos simult&#225;neamente.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_stop_sound;

PRIVATE
    id_sonido;
    canal;
    sonando=FALSE;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    write(0, 160, 0, 1, &quot;Pulse [ESPACIO] para iniciar la reproducci&#243;n.&quot;);
    write(0, 160, 10, 1, &quot;Pulse [ENTER] para detener el canal de sonido.&quot;);
    id_sonido = load_pcm(&quot;help\help.pcm&quot;, 1);
    LOOP
        IF (scan_code==_space AND NOT sonando)
            canal = sound(id_sonido, 128, 256);
            sonando=TRUE;
        END
        IF (scan_code==_enter)

            stop_sound(canal); // Se para el sonido

            sonando=FALSE;
        END
        FRAME;
    END
END
</pre>
En el ejemplo se pone un gr&#225;fico de fondo y los mensajes necesarios, a la vez que se carga el efecto de sonido contenido en el archivo <strong>help.pcm</strong> con la funci&#243;n <a href="#134">load_pcm()</a>, que devuelve el identificador del sonido que se guarda en la variable <strong>id_sonido</strong>. Se puede ver que en este ejemplo se pasa a esta funci&#243;n un <strong>1</strong> como segundo par&#225;metro; esto es para indicar que el efecto de sonido cargado debe repetirse indefinidamente cada vez que sea iniciado (esto se hace para resaltar el efecto de la funci&#243;n <strong>stop_sound()</strong>.<br/><br/>
En cada paso del bucle se comprueba si se pulsa la barra espaciadora, en cuyo caso se iniciar&#225; la reproducci&#243;n del efecto de sonido con <a href="#159">sound()</a>, que devolver&#225; el n&#250;mero de canal que se guardar&#225; en la variable <strong>canal</strong>.<br/><br/>
Si se pulsa la tecla ENTER el sonido ser&#225; parado con la funci&#243;n <strong>stop_sound()</strong>.<br/><br/>
<hr/>
<br/><br/>
Para parar gradualmente un sonido, bajando su volumen poco a poco, se deben realizar varias llamadas a la funci&#243;n <a href="#102">change_sound()</a> para ir decrementando ligeramente el volumen del canal hasta que &#233;ste llegue a 0; entonces se puede llamar a la funci&#243;n <strong>stop_sound()</strong> para detener definitivamente el efecto de sonido.<br/><br/>
<hr/>
Ver: <a href="#159">sound()</a> - <a href="#102">change_sound()</a> - <a href="#134">load_pcm/wav()</a> - <a href="#170">unload_pcm/wav()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="168">system()</h2><br/><br/>
<strong>system(</strong>&lt;&quot;comando externo&quot;&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Ejecuta el comando de sistema operativo que se pasa como par&#225;metro.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_system;
BEGIN
    write(0, 160, 0, 1, &quot;Presione [ESPACIO] para hacer un DIR.&quot;);
    LOOP
        IF (scan_code==_space)

            system(&quot;dir&quot;); // Se ejecuta un comando del MS-DOS.

        END
        FRAME;
    END
END
</pre>
En el ejemplo, tras imprimir un texto, se entra dentro del bucle principal en el que se ejecutar&#225; el comando <strong>DIR</strong> del sistema operativo MS-DOS cada vez que se pulse la barra espaciadora.<br/><br/>
<hr/>
<br/><br/>
Una utilidad que puede tener este comando es, por ejemplo, borrar alg&#250;n archivo temporal que se haya creado en el programa, invocando el comando del sistema <strong>DEL &lt;</strong>nombre de archivo<strong>&gt;</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El sistema puede bloquearse seg&#250;n qu&#233; comandos se ejecuten, debiendo reinicializar el ordenador en estos casos; no se ofrece ning&#250;n tipo de garant&#237;a en cuanto al funcionamiento de esta funci&#243;n, debido a las m&#250;ltiples incompatibilidades que se pueden presentar entre los comandos externos y el gestor de procesos interno de DIV Games Studio.<br/><br/>
<hr/>
<br/><br/>
<strong>system(&quot;COMMAND.COM&quot;)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Ejecuta una sesi&#243;n del sistema operativo MS-DOS desde del propio programa. Al teclear EXIT desde la misma, se retornar&#225; al programa en el punto en el que se ejecut&#243; esta sentencia.<br/><br/>
<hr/>
Ver: <a href="#109">exit()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="169">unload_fpg()</h2><br/><br/>
<strong>unload_fpg(</strong>&lt;c&#243;digo del fichero&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Descarga de memoria el fichero de gr&#225;ficos cuyo c&#243;digo se pasa como par&#225;metro. Este &lt;c&#243;digo de fichero&gt; es el valor que retorna la funci&#243;n <a href="#132">load_fpg()</a> cuando se carga un nuevo fichero de gr&#225;ficos en la memoria.<br/><br/>
Tras descargarse un fichero de gr&#225;ficos <strong>se deben extremar las precauciones</strong> para no continuar utilizando en el programa ning&#250;n gr&#225;fico que estuviera en dicho fichero. En cuyo caso el programa correr&#237;a el riesgo de bloquearse.<br/><br/>
<strong>No es necesario descargar el fichero de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
Por lo tanto, un fichero se debe descargar de memoria &#250;nicamente cuando ya no se vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros de gr&#225;ficos, sonidos, fuentes, etc.).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_unload_fpg;

PRIVATE
    fichero1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    put_screen(fichero1, 1);
    write(0, 160, 0, 1, &quot;Pulse [ENTER] para descargar el fichero y terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_fpg(fichero1); // Se descarga el fichero.

END
</pre>
El ejemplo carga el fichero de gr&#225;ficos contenido en el archivo <strong>help.fpg</strong> con la funci&#243;n <a href="#132">load_fpg()</a>, guardando el <strong>c&#243;digo del fichero</strong> en la variable privada <strong>fichero1</strong>.<br/><br/>
El programa permanecer&#225; en un bucle hasta que se pulse la tecla ENTER, momento en el cual se descargar&#225; el fichero de memoria con <strong>unload_fpg()</strong> y terminar&#225; el programa.<br/><br/>
<hr/>
<br/><br/>
Los gr&#225;ficos cargardos individualmente con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) no se descargar&#225;n cuando se descargue el fichero n&#250;mero 0 (con c&#243;digo 0), aunque &#233;stos se utilicen como si pertenecieran al mismo, sino que se deber&#225;n descargar utilizando las funciones <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>.<br/><br/>
<hr/>
Ver: <a href="#132">load_fpg()</a> - <a href="#174">load_map/pcx()</a> - <a href="#176">unload_map/pcx()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="170">unload_pcm() / unload_wav()</h2><br/><br/>
<strong>unload_pcm(</strong>&lt;c&#243;digo del sonido&gt;<strong>)</strong><br/><br/>
<strong>unload_wav(</strong>&lt;c&#243;digo del sonido&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Descarga de memoria el sonido cuyo c&#243;digo se pasa como par&#225;metro. Este &lt;c&#243;digo de sonido&gt; es el valor que retornan las funciones <a href="#132">load_pcm()</a> y <a href="#132">load_wav()</a> cuando se carga un nuevo efecto de sonido en la memoria.<br/><br/>
Tras descargarse un efecto de sonido <strong>se deben extremar las precauciones</strong> para no continuar utilizando en el programa dicho efecto (su c&#243;digo), en cuyo caso el programa correr&#237;a el riesgo de bloquearse.<br/><br/>
<strong>No es necesario descargar el sonido de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
Por lo tanto, un sonido se debe descargar de memoria &#250;nicamente cuando ya no se vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros de gr&#225;ficos, sonidos, fuentes, etc.), lo que tendr&#225; sentido &#250;nicamente con efectos de sonido de cierta longitud, es decir, que sean lo suficientemente grandes como para que merezca la pena liberar el espacio que ocupan.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_unload_pcm;

PRIVATE
    sonido1;

BEGIN
    sonido1=load_pcm(&quot;help\help.pcm&quot;,0);
    write(0, 160, 0, 1, &quot;Pulse [ENTER] para descargar el sonido y terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_pcm(sonido1); // Se descarga el fichero.

END
</pre>
El ejemplo carga el efecto de sonido contenido en el archivo <strong>help.pcm</strong> con la funci&#243;n <a href="#134">load_pcm()</a>, guardando el <strong>c&#243;digo del sonido</strong> en la variable privada <strong>sonido1</strong>.<br/><br/>
El programa permanecer&#225; en un bucle hasta que se pulse la tecla ENTER, momento en el cual se descargar&#225; el fichero de memoria con <strong>unload_pcm()</strong> y terminar&#225; el programa.<br/><br/>
<hr/>
<br/><br/>
Para parar un efecto de sonido, pero seguir manteni&#233;ndolo en memoria para cuando se quiera hacer sonar de nuevo, se debe utilizar la funci&#243;n <a href="#167">stop_sound()</a>.<br/><br/>
<hr/>
Ver: <a href="#134">load_pcm/wav()</a> - <a href="#159">sound()</a> - <a href="#102">change_sound()</a> - <a href="#167">stop_sound()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="171">write()</h2><br/><br/>
<strong>write(</strong>&lt;fuente&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;c&#243;digo de centrado&gt;<strong>,</strong> &lt;texto&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El c&#243;digo identificador del texto que se ha escrito.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n es la utilizada para mostrar un texto alfanum&#233;rico en pantalla; para ello requiere los siguientes par&#225;metros:<br/><br/>
<strong>&lt;fuente&gt;</strong> - El <strong>c&#243;digo de la fuente</strong> o <strong>tipo de letra</strong> que se va a utilizar. Aqu&#237; se debe poner un 0 cuando se quiera utilizar la fuente del sistema (fuente de color blanco, peque&#241;a, de 6 por 8 puntos), o bien el <strong>c&#243;digo de fuente</strong> devuelto por la funci&#243;n <a href="#131">load_fnt()</a> cuando se carga una nueva fuente en el programa.<br/><br/>
<strong>&lt;x&gt;</strong>, <strong>&lt;y&gt;</strong> - Las coordenadas relativas a pantalla en las que se va a imprimir el texto, primero en el eje horizontal y despu&#233;s en el vertical.<br/><br/>
<strong>&lt;c&#243;digo de centrado&gt;</strong> - Es un c&#243;digo que determina la posici&#243;n del texto que se especifica en las coordenadas anteriores. Sus valores son:<br/><br/>
<strong>0</strong>-Arriba izquierda <strong>1</strong>-Arriba <strong>2</strong>-Arriba derecha<br/>
<strong>3</strong>-Izquierda        <strong>4</strong>-Centro <strong>5</strong>-Derecha<br/>
<strong>6</strong>-Abajo izquierda  <strong>7</strong>-Abajo  <strong>8</strong>-Abajo derecha<br/>
<br/><br/>
Por ejemplo, si se escribe un texto en las coordenadas 160, 0 y con el c&#243;digo de centrado 1 (Arriba), entonces se centrar&#225; el texto en la columna 160 y se imprimir&#225; de la l&#237;nea 0 hacia abajo. O si se quiere un texto en la esquina superior izquierda, se debe imprimir en las coordenadas 0, 0 y con c&#243;digo de centrado 0 (Arriba izquierda).<br/><br/>
<strong>&lt;texto&gt;</strong> - Como &#250;ltimo par&#225;metro se especificar&#225; texto a escribir como un literal, es decir, un texto entre comillas (Ver los <a href="#1047">s&#237;mbolos delimitadores de literales</a>).<br/><br/>
<hr/>
<br/><br/>
El texto impreso permanecer&#225; en pantalla hasta que se borre con la funci&#243;n <a href="#107">delete_text()</a>, que requiere como par&#225;metro el <strong>c&#243;digo identificador</strong> que devuelve <strong>write()</strong>.<br/><br/>
Para imprimir el valor num&#233;rico de una variable (como pudiera ser la puntuaci&#243;n del jugador) se debe utilizar funci&#243;n <a href="#172">write_int()</a>.<br/><br/>
Los textos permanecer&#225;n inalterados en pantalla aunque se impriman gr&#225;ficos en la misma o pasen gr&#225;ficos de procesos por delante o por detr&#225;s de los mismos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_write;

PRIVATE
    fuente1;

BEGIN
    fuente1 = load_fnt(&quot;help\help.fnt&quot;);

    write(0, 160, 100, 4, &quot;Texto de ejemplo con la fuente del sistema.&quot;);
    write(fuente1, 0, 0, 0, &quot;ARRIBA IZQUIERDA&quot;);
    write(fuente1, 320, 200, 8, &quot;ABAJO DERECHA&quot;);

    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo anterior se carga la fuente contenida en el archivo <strong>help.fnt</strong> con la funci&#243;n <a href="#131">load_fnt()</a> (cuyo c&#243;digo de fuente se guarda en la variable <strong>fuente1</strong>), y despu&#233;s se escriben tres textos:<br/><br/>
El primero con la fuente del sistema (0), situ&#225;ndose en las coordenadas 160, 100 (centro de la pantalla) el <strong>centro</strong> del texto (c&#243;digo de centrado 4).<br/><br/>
El segundo con la fuente cargada (cuyo <strong>identificador de fuente</strong> se tiene almacenado en la variable <strong>fuente1</strong>), situ&#225;ndose en las coordenadas 0, 0 la esquina superior izquierda del texto (c&#243;digo de centrado 0).<br/><br/>
Y, por &#250;ltimo, el tercer texto, tambi&#233;n con la fuente cargada, situ&#225;ndose en las coordenadas 320, 200 la esquina inferior derecha del texto (c&#243;digo de centrado 8).<br/><br/>
Tras esto el programa se quedar&#225; esperando indefinidamente dentro de un bucle.<br/><br/>
<hr/>
<br/><br/>
El plano de profundidad en el que aparecen los textos escritos se controla mediante la variable global <a href="#1106">text_z</a>, que sirve para regular qu&#233; gr&#225;ficos se deben ver por encima de los textos y cu&#225;les por debajo.<br/><br/>
Los textos podr&#225;n, luego, moverse hasta otra posici&#243;n si es necesario utilizando la funci&#243;n <a href="#141">move_text()</a>, que tambi&#233;n requiere como par&#225;metro el <strong>c&#243;digo identificador</strong> que devuelve <strong>write()</strong>.<br/><br/>
<hr/>
<br/><br/>
Cuando se utilicen fuentes cargadas de <strong>archivos FNT</strong> debe estar activada la paleta de colores que se ha utilizado para generar dichas fuentes (ver <a href="#133">load_pal()</a>) pues, de lo contrario, los colores pueden aparecer cambiados, visualiz&#225;ndose el texto incorrectamente.<br/><br/>
<hr/>
Ver: <a href="#172">write_int()</a> - <a href="#141">move_text()</a> - <a href="#107">delete_text()</a> - <a href="#131">load_fnt()</a> - <a href="#1106">text_z</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="172">write_int()</h2><br/><br/>
<strong>write_int(</strong>&lt;fuente&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;c&#243;digo de centrado&gt;<strong>,</strong> &lt;OFFSET variable&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El c&#243;digo identificador del texto que se ha escrito.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n es la utilizada para visualizar el valor num&#233;rico de una variable; para ello requiere los siguientes par&#225;metros:<br/><br/>
<strong>&lt;fuente&gt;</strong> - El <strong>c&#243;digo de la fuente</strong> o <strong>tipo de letra</strong> que se va a utilizar. Aqu&#237; se debe poner un 0 cuando se quiera utilizar la fuente del sistema (fuente de color blanco, peque&#241;a, de 6 por 8 puntos), o bien el <strong>c&#243;digo de fuente</strong> devuelto por la funci&#243;n <a href="#131">load_fnt()</a> cuando se carga una nueva fuente en el programa.<br/><br/>
<strong>&lt;x&gt;</strong>, <strong>&lt;y&gt;</strong> - Las coordenadas relativas a pantalla en las que se va a imprimir el valor num&#233;rico, primero en el eje horizontal y despu&#233;s en el vertical.<br/><br/>
<strong>&lt;c&#243;digo de centrado&gt;</strong> - Es un c&#243;digo que determina la posici&#243;n del valor num&#233;rico que se especifica en las coordenadas anteriores. Sus valores son:<br/><br/>
<strong>0</strong>-Arriba izquierda <strong>1</strong>-Arriba <strong>2</strong>-Arriba derecha<br/>
<strong>3</strong>-Izquierda        <strong>4</strong>-Centro <strong>5</strong>-Derecha<br/>
<strong>6</strong>-Abajo izquierda  <strong>7</strong>-Abajo  <strong>8</strong>-Abajo derecha<br/>
<br/><br/>
Por ejemplo, si se escribe un valor num&#233;rico en las coordenadas 160, 0 y con el c&#243;digo de centrado 1 (Arriba), entonces se centrar&#225; el valor num&#233;rico en la columna 160 y se imprimir&#225; de la l&#237;nea 0 hacia abajo. O si se quiere un valor num&#233;rico en la esquina superior izquierda, se debe imprimir en las coordenadas 0, 0 y con c&#243;digo de centrado 0 (Arriba izquierda).<br/><br/>
<strong>&lt;OFFSET variable&gt;</strong> - Como &#250;ltimo par&#225;metro se debe especificar el desplazamiento dentro de la memoria del ordenador de la variable cuyo valor se quiere visualizar (el desplazamiento del dato se obtiene con el operador <a href="#1085">OFFSET</a>).<br/><br/>
<hr/>
<br/><br/>
El valor num&#233;rico impreso permanecer&#225; en pantalla hasta que se borre con la funci&#243;n <a href="#107">delete_text()</a>, que requiere como par&#225;metro el <strong>c&#243;digo identificador</strong> que devuelve <strong>write_int()</strong>.<br/><br/>
<strong>Importante:</strong> Durante el tiempo que aparezca el valor de la variable en pantalla, &#233;ste se ir&#225; actualizando autom&#225;ticamente cada vez que se modifique la variable, no siendo necesarias nuevas llamadas a <strong>write_int()</strong>.<br/><br/>
Para imprimir un texto alfanum&#233;rico de cualquier tipo (un texto fijo) se debe utilizar la funci&#243;n <a href="#171">write()</a>.<br/><br/>
Los textos permanecer&#225;n inalterados en pantalla aunque se impriman gr&#225;ficos en la misma o pasen gr&#225;ficos de procesos por delante o por detr&#225;s de ellos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_write_int;

PRIVATE
    variable;

BEGIN
    write(0, 160, 190, 1, &quot;Pulse [ESPACIO] para cambiar el valor de la variable.&quot;);

    write_int(0, 160, 100, 4, OFFSET variable); // Se imprime una variable.

    LOOP
        IF (scan_code==_space) variable=rand(-100, 100); END
        FRAME;
    END
END
</pre>
En el ejemplo se imprime un texto usando <a href="#171">write()</a> y el valor de una variable con la funci&#243;n <strong>write_int()</strong>. A esta &#250;ltima funci&#243;n se le pasan los siguientes par&#225;metros:<br/><br/>
<strong>0</strong> - Como <strong>fuente</strong> (0 es la fuente del sistema).<br/>
<strong>0, 10</strong> - Como coordenadas de pantalla.<br/>
<strong>0</strong> - Como c&#243;digo de centrado (Arriba/Izquierda).<br/>
<strong>OFFSET variable</strong> - Como el desplazamiento en memoria de la variable.<br/>
<br/><br/>
A cada paso del bucle, si se pulsa la barra espaciadora, se cambia el valor de la variable asign&#225;ndole uno elegido aleatoriamente, al azar, con la funci&#243;n <a href="#149">rand()</a>.<br/><br/>
<hr/>
<br/><br/>
El plano de profundidad en el que aparecen los textos escritos se controla mediante la variable global <a href="#1106">text_z</a>, que sirve para regular qu&#233; gr&#225;ficos se deben ver por encima de los textos y cu&#225;les por debajo.<br/><br/>
Los textos podr&#225;n luego moverse hasta otra posici&#243;n si es necesario utilizando la funci&#243;n <a href="#141">move_text()</a>, que tambi&#233;n requiere como par&#225;metro el <strong>c&#243;digo identificador</strong> que devuelve <strong>write_int()</strong>.<br/><br/>
<hr/>
<br/><br/>
Cuando se utilicen fuentes cargadas de <strong>archivos FNT</strong> debe estar activada la paleta de colores que se ha utilizado para generar dichas fuentes (ver <a href="#133">load_pal()</a>) pues, de lo contrario, los colores pueden aparecer cambiados, visualiz&#225;ndose el texto incorrectamente.<br/><br/>
<hr/>
<br/><br/>
<strong>Advertencia:</strong><br/><br/>
No es posible imprimir una expresi&#243;n, como se muestra a continuaci&#243;n:<br/><br/>
<strong>write_int(0, 0, 0, 0, offset variable + 1);</strong><br/><br/>
Para imprimir el valor de la variable m&#225;s 1, es decir, si se quisiera imprimir este valor, se deber&#237;a sumar 1 a la variable o crear otra variable y asignarle a &#233;sta el valor de la variable original m&#225;s 1, por ejemplo:<br/><br/>
<strong>variable2 = variable + 1;</strong><br/>
<strong>write_int(0, 0, 0, 0, offset variable2);</strong><br/>
<br/><br/>
En este caso se deber&#237;a tener en cuenta que habr&#237;a que actualizar el valor de <strong>variable2</strong> al menos una vez por cada imagen (por cada <a href="#1029">FRAME</a>) del juego, ya que al cambiar <strong>variable</strong> no se actualizar&#237;a autom&#225;ticamente el valor de <strong>variable2</strong> a no ser que se ejecutara nuevamente la sentencia <strong>variable2 = variable + 1;</strong>.<br/><br/>
<hr/>
Ver: <a href="#171">write()</a> - <a href="#141">move_text()</a> - <a href="#107">delete_text()</a> - <a href="#131">load_fnt()</a> - <a href="#1106">text_z</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="173">xput()</h2><br/><br/>
<strong>xput(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;angle&gt;<strong>,</strong> &lt;size&gt;<strong>,</strong> &lt;flags&gt;<strong>,</strong> &lt;region&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Versi&#243;n avanzada de la funci&#243;n <a href="#146">put()</a> para poner un gr&#225;fico en el fondo de la pantalla. Esta funci&#243;n requiere, por orden, los siguientes par&#225;metros:<br/><br/>
<strong>&lt;fichero&gt;</strong> - <strong>c&#243;digo del fichero</strong> con la librer&#237;a de gr&#225;ficos que contiene a ambos. Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
<strong>&lt;gr&#225;fico&gt;</strong> - <strong>c&#243;digo del gr&#225;fico</strong> dentro del fichero que se va a imprimir en pantalla.<br/><br/>
<strong>&lt;x&gt;, &lt;y&gt;</strong> - coordenadas relativas a pantalla donde se desea poner el gr&#225;fico. Estas coordenadas se refieren a donde se situar&#225; el centro del gr&#225;fico (o el <a href="#1136">punto de control</a> n&#250;mero 0, en caso de estar definido).<br/><br/>
<strong>&lt;angle&gt;</strong> - &#225;ngulo (en mil&#233;simas de grados) en el que se imprimir&#225; el gr&#225;fico; el &#225;ngulo normal es <strong>0</strong>.<br/><br/>
<strong>&lt;size&gt;</strong> - tama&#241;o (en porcentaje) en el que se imprimir&#225; el gr&#225;fico; el tama&#241;o normal es <strong>100</strong>.<br/><br/>
<strong>&lt;flags&gt;</strong> - Indica los espejados y transparencias con los que se imprimir&#225; el gr&#225;fico; los posibles valores son:<br/><br/>
<strong>0</strong>-Gr&#225;fico normal.<br/>
<strong>1</strong>-Espejado horizontal.<br/>
<strong>2</strong>-Espejado vertical.<br/>
<strong>3</strong>-Espejado horizontal y vertical (180&#176;).<br/>
<strong>4</strong>-Gr&#225;fico transparente.<br/>
<strong>5</strong>-Transparente y espejado horizontal.<br/>
<strong>6</strong>-Transparente y espejado vertical.<br/>
<strong>7</strong>-Transparente, espejado horizontal y vertical.<br/>
<br/><br/>
<strong>&lt;regi&#243;n&gt;</strong> - N&#250;mero de regi&#243;n (ventana dentro de la pantalla) en la que se debe imprimir el gr&#225;fico; normalmente este valor ser&#225; <strong>0</strong> para poder imprimir el gr&#225;fico en cualquier posici&#243;n de la pantalla. Para definir una regi&#243;n se debe utilizar la funci&#243;n <a href="#106">define_region()</a>.<br/><br/>
<hr/>
<br/><br/>
Los gr&#225;ficos impresos de esta forma en el fondo de la pantalla estar&#225;n en la visualizaci&#243;n del juego <strong>por debajo de todos los procesos, regiones de scroll, textos, etc.</strong><br/><br/>
Si se desea que un gr&#225;fico est&#233; por encima de otros se debe <strong>crear como un nuevo proceso</strong> y fijar su variable <a href="#1125">z</a> con la prioridad de impresi&#243;n del mismo.<br/><br/>
Para borrar el fondo de la pantalla se debe utilizar la funci&#243;n <a href="#103">clear_screen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_put;

PRIVATE
    fichero1;
    coord_x;
    coord_y;
    &#225;ngulo1;
    tama&#241;o1;
    flags1;

BEGIN
    fichero1=load_fpg(&quot;help\help.fpg&quot;);
    LOOP
        coord_x=rand(0, 319);
        coord_y=rand(0, 199);
        &#225;ngulo1=rand(-pi, pi);
        tama&#241;o1=rand(10, 200);
        flags1=rand(0, 7);

        // Se pone el gr&#225;fico 101
        xput(fichero1, 101, coord_x, coord_y, &#225;ngulo1, tama&#241;o1, flags1, 0);

        FRAME;
    END
END
</pre>
En el ejemplo se carga el fichero con los gr&#225;ficos y en cada iteraci&#243;n de bucle se pone el gr&#225;fico n&#250;mero 101 (un tri&#225;ngulo) con la funci&#243;n <strong>xput()</strong> en coordenadas aleatorias (elegidas al azar con la funci&#243;n <a href="#149">rand()</a>), con un &#225;ngulo y un tama&#241;o tambi&#233;n aleatorio, con el valor de <strong>flags</strong> aleatorio y en la regi&#243;n n&#250;mero 0 (pantalla completa).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#146">put()</a> es una versi&#243;n simplificada de la funci&#243;n <strong>xput()</strong> de utilidad cuando no se quiera rotar, escalar, espejar o imprimir con transparencias el gr&#225;fico.<br/><br/>
Para poner un gr&#225;fico en otro (en lugar del fondo de la pantalla) se deben utilizar las funciones <a href="#137">map_put()</a> o <a href="#139">map_xput()</a>.<br/><br/>
<hr/>
<br/><br/>
Si el gr&#225;fico que se quiere poner es simplemente una pantalla de fondo, resulta m&#225;s sencillo utilizar la funci&#243;n <a href="#148">put_screen()</a>, ya que &#233;sta no requiere las coordenadas de pantalla, pues centrar&#225; el gr&#225;fico en la misma de forma autom&#225;tica.<br/><br/>
<hr/>
Ver: <a href="#146">put()</a> - <a href="#137">map_put()</a> - <a href="#139">map_xput()</a> - <a href="#148">put_screen()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="174">load_map() / load_pcx()</h2><br/><br/>
<strong>load_map(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>load_pcx(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>c&#243;digo del gr&#225;fico</strong> cargado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga un <strong>archivo MAP o PCX</strong> con un gr&#225;fico en la memoria del ordenador. Se requiere el nombre del archivo como par&#225;metro, entre comillas.<br/><br/>
Se devuelve como valor de retorno el <strong>c&#243;digo del gr&#225;fico</strong>, que es un valor num&#233;rico que debe especificarse para utilizar el gr&#225;fico, en la variable <a href="#1126">graph</a> o, en general, en todas las funciones que requieran un <strong>c&#243;digo de gr&#225;fico</strong> entre sus par&#225;metros.<br/><br/>
Es posible cargar tantos gr&#225;ficos como sea necesario; cada vez que se cargue uno la funci&#243;n devolver&#225; el c&#243;digo que le corresponde (el primer gr&#225;fico cargado tendr&#225; el c&#243;digo <strong>1000</strong>, el siguiente el <strong>1001</strong>, etc.)<br/><br/>
Se puede especificar la ruta de acceso al archivo con el fichero de gr&#225;ficos, no obstante, si el fichero est&#225; en el directorio por defecto (\MAP o \PCX) no ser&#225; necesario.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong><br/><br/>
Cuando se requiera dentro de una funci&#243;n el <strong>c&#243;digo de fichero</strong> al que pertenece dicho gr&#225;fico, se debe indicar el c&#243;digo <strong>0</strong> (que es el c&#243;digo del primer <strong>fichero FPG</strong> que se cargue en el programa).<br/><br/>
<hr/>
<br/><br/>
Cuando se han cargado diferentes gr&#225;ficos se debe tener en cuenta que si &#233;stos tienen paletas diferentes, se debe activar cada una de ellas previamente con la funci&#243;n <a href="#133">load_pal()</a>, indicando el nombre del fichero como par&#225;metro, antes de utilizar el gr&#225;fico.<br/><br/>
No se pueden utilizar simult&#225;neamente gr&#225;ficos creados con distintas paletas.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_map;

PRIVATE
    mapa1;

BEGIN

    mapa1 = load_map(&quot;help\help.map&quot;); // Se carga un fichero de mapa gr&#225;fico.

    put_screen(0, mapa1);
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo se carga un mapa gr&#225;fico con la funci&#243;n <strong>load_map()</strong> guardando el <strong>c&#243;digo del gr&#225;fico</strong> que retorna en la variable privada <strong>mapa1</strong>.<br/><br/>
Este c&#243;digo se usa posteriormente como par&#225;metro de la funci&#243;n <a href="#148">put_screen()</a> para poner el gr&#225;fico en el fondo de pantalla.<br/><br/>
<hr/>
<br/><br/>
Las funciones <a href="#176">unload_map()</a> y <a href="#176">unload_pcx()</a> permiten liberar la memoria del ordenador utilizada por el gr&#225;fico cuando ya no se va a utilizar m&#225;s durante un tiempo, y para ello requieren tambi&#233;n el <strong>codigo del gr&#225;fico</strong>, para saber qu&#233; gr&#225;fico es el que se quiere descargar de memoria.<br/><br/>
<strong>No es necesario descargar el gr&#225;fico de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
<hr/>
<br/><br/>
Para cargar varios gr&#225;ficos de golpe en un programa, &#233;stos deben estar incluidos dentro de un fichero de gr&#225;ficos (FPG) y cargarse con la funci&#243;n <a href="#132">load_fpg()</a>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#188">new_map()</a> permite crear en memoria un mapa gr&#225;fico de cualquier tama&#241;o y color, sin cargarlo de un archivo en disco.<br/><br/>
<hr/>
Ver: <a href="#188">new_map()</a> - <a href="#176">unload_map/pcx()</a> - <a href="#132">load_fpg()</a> - <a href="#133">load_pal()</a> - <a href="#1126">graph</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="175">reset_sound()</h2><br/><br/>
<strong>reset_sound(</strong><strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Funci&#243;n avanzada, &#250;nicamente para usuarios muy experimentados. Reinicializa el sistema de sonido.<br/><br/>
Esta funci&#243;n sirve para activar unos nuevos par&#225;metros del hardware de sonido.<br/><br/>
Se deben establecer los siguientes valores de la <a href="#1104">estructura global setup</a>:<br/><br/>
<strong>setup.card</strong><br/>
<strong>setup.port</strong><br/>
<strong>setup.irq</strong><br/>
<strong>setup.dma</strong><br/>
<strong>setup.dma2</strong><br/>
<br/><br/>
Esta funci&#243;n se utiliza generalmente dentro de los programas de configuraci&#243;n del sistema de sonido (ver <a href="#1093">setup_program</a>).<br/><br/>
<hr/>
<br/><br/>
Para activar el resto de los valores de la estructura setup, los referentes al volumen del mezclador (<strong>mixer</strong>), se debe invocar a la funci&#243;n <a href="#178">set_volume()</a>. Los valores para establecer el volumen son:<br/><br/>
<strong>setup.master</strong><br/>
<strong>setup.sound_fx</strong><br/>
<strong>setup.cd_audio</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#178">set_volume()</a> - <a href="#1104">Estructura setup</a> - <a href="#1093">setup_program</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="176">unload_map() / unload_pcx()</h2><br/><br/>
<strong>unload_map(</strong>&lt;c&#243;digo del gr&#225;fico&gt;<strong>)</strong><br/><br/>
<strong>unload_pcx(</strong>&lt;c&#243;digo del gr&#225;fico&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Descarga de memoria el gr&#225;fico cuyo c&#243;digo se pasa como par&#225;metro. Este &lt;c&#243;digo de gr&#225;fico&gt; es el valor que retornan las funciones <a href="#174">load_map()</a>, <a href="#174">load_pcx()</a> o <a href="#188">new_map()</a> al cargar o crear un gr&#225;fico.<br/><br/>
Tras descargarse un gr&#225;fico <strong>se deben extremar las precauciones</strong> para no continuar utilizando en el programa dicho gr&#225;fico, en cuyo caso el programa correr&#237;a el riesgo de bloquearse.<br/><br/>
<strong>No es necesario descargar el gr&#225;fico</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
Luego, un gr&#225;fico solamente debe descargarse de memoria cuando ya no se vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros de gr&#225;ficos, sonidos, fuentes, etc.), lo que tendr&#225; sentido &#250;nicamente con gr&#225;ficos de un cierto tama&#241;o, es decir, que sean lo suficientemente grandes como para sea rentable liberar el espacio que ocupan.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_unload_map;

PRIVATE
    mapa1;

BEGIN
    mapa1=load_map(&quot;help\help.map&quot;);
    put_screen(0, mapa1);
    write(0, 160, 0, 1, &quot;Pulse [ENTER] para descargar el gr&#225;fico y terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_map(mapa1); // Se descarga el gr&#225;fico.

END
</pre>
En el ejemplo se carga un mapa gr&#225;fico con la funci&#243;n <a href="#174">load_map()</a> guardando el <strong>c&#243;digo del gr&#225;fico</strong> que retorna en la variable privada <strong>mapa1</strong>.<br/><br/>
Este c&#243;digo se usa, posteriormente, como par&#225;metro de la funci&#243;n <a href="#148">put_screen()</a> para poner el gr&#225;fico en el fondo de pantalla.<br/><br/>
Entonces el programa imprimir&#225; un mensaje y esperar&#225; en un bucle hasta que se pulse la tecla ENTER, momento en el cual se descargar&#225; el gr&#225;fico utilizando la funci&#243;n <strong>unload_map()</strong>.<br/><br/>
<hr/>
<br/><br/>
Los gr&#225;ficos cargados individualmente con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) no se descargar&#225;n cuando se descargue el fichero n&#250;mero 0 (con c&#243;digo 0) con la funci&#243;n <a href="#169">unload_fpg()</a>, aunque estos gr&#225;ficos se utilicen como si pertenecieran al mismo.<br/><br/>
<hr/>
Ver: <a href="#174">load_map/pcx()</a> - <a href="#169">unload_fpg()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="177">unload_fnt()</h2><br/><br/>
<strong>unload_fnt(</strong>&lt;c&#243;digo de la fuente&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Descarga de memoria la <strong>fuente</strong> (el <strong>tipo de letra</strong> o el <strong>juego de car&#225;cteres gr&#225;ficos</strong>) cuyo c&#243;digo se pasa como par&#225;metro.<br/><br/>
Este &lt;c&#243;digo de fuente&gt; es el valor que retorna la funci&#243;n <a href="#131">load_fnt()</a> al cargar una nueva fuente de letras contenida en un <strong>archivo FNT</strong> en la memoria del ordenador.<br/><br/>
Tras descargarse una fuente <strong>se deben extremar las precauciones</strong> para no continuar utilizando en el programa dicha fuente; si se hiciera as&#237;, se correr&#237;a el riesgo de que el programa pudiera bloquearse.<br/><br/>
<strong>No es necesario descargar la fuente</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
Despu&#233;s, se debe descargar una fuente de memoria &#250;nicamente cuando ya no se vaya a utilizar durante un tiempo determinado y se quiera liberar el espacio ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros de gr&#225;ficos, sonidos, fuentes, etc.).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_unload_fnt;

PRIVATE
    fuente1;

BEGIN
    fuente1=load_fnt(&quot;help\help.fnt&quot;);
    write(fuente1, 160, 0, 1, &quot;FUENTE DEL ARCHIVO EN DISCO&quot;);
    write(0, 160, 190, 1, &quot;Pulse [ENTER] para descargar la fuente y terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_enter));

    unload_fnt(fuente1); // Se descarga la fuente
END
</pre>
En el ejemplo se carga la fuente contenida en el archivo <strong>help.fnt</strong> con la funci&#243;n <a href="#131">load_fnt()</a> guardando el <strong>c&#243;digo de fuente</strong> que retorna en la variable privada <strong>fuente1</strong>.<br/><br/>
Este c&#243;digo se usa posteriormente como par&#225;metro de la funci&#243;n <a href="#171">write()</a> para poner un texto en pantalla con dicha fuente.<br/><br/>
Entonces el programa esperar&#225; en un bucle hasta que se pulse la tecla ENTER, momento en el cual se descargar&#225; la fuente utilizando la funci&#243;n <strong>unload_fnt()</strong>, con lo que se terminar&#225; el programa.<br/><br/>
<hr/>
<br/><br/>
La fuente n&#250;mero 0, (la fuente del sistema que tiene 0 como c&#243;digo de fuente), <strong>no se puede descargar</strong>.<br/><br/>
<hr/>
Ver: <a href="#131">load_fnt()</a> - <a href="#171">write()</a> - <a href="#172">write_int()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="178">set_volume()</h2><br/><br/>
<strong>set_volume(</strong><strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Funci&#243;n avanzada, s&#243;lo para usuarios muy experimentados. Ajusta los diferentes controles de volumen gestionados por el mezclador (<strong>mixer</strong>) del sistema de sonido.<br/><br/>
Se deben establecer los siguientes valores de la <a href="#1104">estructura global setup</a> para poder ajustar el volumen:<br/><br/>
<strong>setup.master</strong>   - Volumen general<br/>
<strong>setup.sound_fx</strong> - Volumen de los efectos de sonido<br/>
<strong>setup.cd_audio</strong> - Volumen de la m&#250;sica de cd-audio<br/>
<br/><br/>
Esta funci&#243;n se utiliza generalmente dentro de los programas de configuraci&#243;n del sistema de sonido (ver <a href="#1093">setup_program</a>), o bien en el resto de los programas, normalmente para fijar el volumen de la m&#250;sica de CD-Audio.<br/><br/>
<hr/>
<br/><br/>
Para activar el resto de los valores de la estructura setup (los referentes a par&#225;metros de la tarjeta de sonido), se debe invocar a la funci&#243;n <a href="#175">reset_sound()</a> con los siguientes valores de la estructura definidos:<br/><br/>
<strong>setup.card</strong><br/>
<strong>setup.port</strong><br/>
<strong>setup.irq</strong><br/>
<strong>setup.dma</strong><br/>
<strong>setup.dma2</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#175">reset_sound()</a> - <a href="#1104">Estructura setup</a> - <a href="#1093">setup_program</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="179">set_color()</h2><br/><br/>
<strong>set_volume(</strong>&lt;color&gt;<strong>,</strong> &lt;red&gt;<strong>,</strong> &lt;green&gt;<strong>,</strong> &lt;blue&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Redefine un color de la paleta. Esta funci&#243;n sirve para modificar las componentes de un color concreto de la paleta del juego.<br/><br/>
Se debe tener cuidado con ella, pues todos los gr&#225;ficos de pantalla que utilicen dicho color se ver&#225;n afectados, para modificar los colores de un s&#243;lo gr&#225;fico se debe utilizar la funci&#243;n <a href="#105">convert_palette()</a>.<br/><br/>
El &lt;color&gt; debe ser un n&#250;mero entre <strong>0</strong> y <strong>255</strong>. Las <strong>componentes del color</strong> se especificar&#225;n como n&#250;meros entre <strong>0</strong> (m&#237;nimo) y <strong>63</strong> (m&#225;ximo).<br/><br/>
<strong>&lt;red&gt;</strong>   - Componente roja del color.<br/>
<strong>&lt;green&gt;</strong> - Componente verde del color.<br/>
<strong>&lt;blue&gt;</strong>  - Componente azul del color.<br/>
<br/><br/>
A continuaci&#243;n se muestra un programa que modifica de forma aleatoria los colores de la paleta.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_color;
GLOBAL color,r,g,b;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 2);
    LOOP
        color=rand(1,255);
        r=rand(0,63);
        g=rand(0,63);
        b=rand(0,63);

        set_color(color, r, g, b); // Se redefine un color de la paleta

        FRAME;
    END
END
</pre>
En el ejemplo se pone como fondo una pantalla multicolor y dentro del bucle principal del programa se modifican al azar las componentes de un color cualquiera de la paleta cuando est&#233; pulsada la barra espaciadora. Para obtener n&#250;meros al azar se utiliza la funci&#243;n <a href="#149">rand()</a>.<br/><br/>
<hr/>
<br/><br/>
Para modificar toda la paleta, es preferible cargar &#233;sta de un archivo con la funci&#243;n <a href="#133">load_pal()</a>.<br/><br/>
<hr/>
<br/><br/>
Para realizar otros efectos de paleta, se puede utilizar la funci&#243;n <a href="#154">roll_palette()</a> que permite realizar ciclos de color, o la funci&#243;n <a href="#110">fade()</a> que permite realizar m&#250;ltiples fundidos y saturaciones de color a diferentes velocidades.<br/><br/>
<hr/>
Ver: <a href="#154">roll_palette()</a> - <a href="#133">load_pal()</a> - <a href="#110">fade()</a> - <a href="#111">fade_off()</a> - <a href="#112">fade_on()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="180">net_join_game()</h2><br/><br/>
<strong>net_join_game(</strong>&lt;nombre de la partida&gt;<strong>,</strong> &lt;OFFSET estructura&gt;<strong>,</strong> &lt;SIZEOF(estructura)&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
N&#250;mero de jugador dentro de la partida (0, 1, 2, ...). Si se produce un error, se devuelve un n&#250;mero negativo, siendo estos los c&#243;digos de error existentes:<br/><br/>
<strong> -1</strong> : Conexi&#243;n abortada por el usuario.<br/>
<strong> -2</strong> : No se pudo inicializar la conexi&#243;n.<br/>
<strong> -3</strong> : El n&#250;mero de jugadores no coincide.<br/>
<strong> -4</strong> : Se produjeron errores de sincronismo.<br/>
<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Las funciones de red son de un nivel extremadamente avanzado, por lo que pueden resultar muy complejas de entender para usuarios que no tengan bastante experiencia en programaci&#243;n.<br/><br/>
En primer lugar debe inicializarse la estructura global predefinida <a href="#1410">net</a> con los par&#225;metros que definen el tipo de conexi&#243;n que debe establecerse.<br/><br/>
Entonces, una llamada a la funci&#243;n <strong>net_join_game()</strong> bastar&#225; para crear una nueva partida o para unirse a la misma (si esta ya estuviera creada).<br/><br/>
El nombre de la partida (un literal, como <strong>&quot;MiPartida&quot;</strong>), sirve &#250;nicamente para que un s&#243;lo juego pueda ejecutar varias partidas simult&#225;neamente en una sola red local. Diferenciando a cada una de las mismas de esta forma.<br/><br/>
A partir de ese momento todos los equipos que se hayan conectado a la partida enviar&#225;n y recibir&#225;n datos de los dem&#225;s de forma autom&#225;tica, a trav&#233;s de la estructura indicada como par&#225;metro.<br/><br/>
<strong>La estructura de datos.</strong><br/><br/>
Esta debe ser una estructura global del programa con tantos registros como jugadores deban conectarse simult&#225;neamente.<br/><br/>
En los campos de esta estructura se podr&#225;n leer y escribir los datos enviados; cada jugador debe introducir sus valores en su registro. El n&#250;mero de registro que le corresponde a cada jugador es el devuelto por esta funci&#243;n.<br/><br/>
El sistema enviar&#225; autom&#225;ticamente su registro a los dem&#225;s jugadores, y los registros de los dem&#225;s jugadores a este.<br/><br/>
<a href="#1410">La estructura predefinida net</a><br/><br/>
En esta estructura se establecen los par&#225;metros que definen el tipo de conexi&#243;n. Los campos de esta estructura se resumen a continuaci&#243;n.<br/><br/>
<strong>net.device</strong> - Dispositivo de conexi&#243;n (1-IPX, 2-Cable serie o 3-M&#243;dem).<br/><br/>
<strong>net.com</strong> - N&#186; de dispositivo COM, de 1 a 4 (s&#243;lo para serie y m&#243;dem).<br/><br/>
<strong>net.speed</strong> - Velocidad (en baudios), hasta 115000 (s&#243;lo para serie y m&#243;dem).<br/><br/>
<strong>net.number</strong> - N&#250;mero de tel&#233;fono (s&#243;lo m&#243;dem), por ejemplo <strong>net.number=&quot;913040622&quot;;</strong>.<br/><br/>
<strong>net.init</strong> - Cadena de inicio del m&#243;dem, por ejemplo <strong>net.init=&quot;ATZ&quot;;</strong>.<br/><br/>
<strong>net.mode</strong> - 0 o 1 seg&#250;n sea pulsos o tonos (tambi&#233;n s&#243;lo para el m&#243;dem).<br/><br/>
<strong>net.server</strong> - Indica si es el servidor (s&#243;lo lectura, no se debe modificar).<br/><br/>
<strong>net.max_players</strong> - Numero m&#225;ximo de jugadores, de 2 a 16 (debe coincidir con el n&#250;mero de registros de la estructura global).<br/><br/>
<strong>net.num_players</strong> - Numero actual de jugadores, de 1 a 16 (se pueden ir conectando y desconectando jugadores en cualquier momento).<br/><br/>
Cuando la conexi&#243;n se realiza por cable serie o por m&#243;dem &#250;nicamente podr&#225;n conectarse <strong>2 jugadores</strong>.<br/><br/>
<hr/>
<br/><br/>
Es muy importante que el n&#250;mero de registros de la estructura utilizada para el traspaso de datos tenga tantos registros como los indicados en <strong>net.max_players</strong>.<br/><br/>
Por ejemplo, si se crea un juego en el que el n&#250;mero m&#225;ximo de jugadores sean 8, y la informaci&#243;n que deben pasarse los jugadores es &#250;nicamente sus coordenadas (x,y), entonces se podr&#237;a hacer como se indica en el siguiente programa (suponiendo una conexi&#243;n IPX para una red local).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_net_join_game;

GLOBAL
  STRUCT jugador[7] // 8 jugadores como m&#225;ximo (de 0 a 7).
    x,y;
  END

  id_red;

BEGIN

  net.device=1;
  net.max_players=8; // Se indica aqu&#237; el n&#250;mero de registros.

  // ...

  id_red=net_join_game(&quot;xxx&quot;,OFFSET jugador, sizeof(jugador));

  IF (id_red&lt;0)

    // Se ha producido un error ...

  END

  // El registro de este jugador es &quot;jugador[id_red]&quot;

  jugador[id_red].x=x; // Defino mis campos
  jugador[id_red].y=y;

  FRAME; // Envio / Recepci&#243;n de datos

  // Ahora hay conectados &quot;net.num_players&quot;, y sus datos est&#225;n en
  // los dem&#225;s registros de la estructura jugador[].

  // ...

END
</pre>
<strong>Nota:</strong> Se puede encontrar m&#225;s informaci&#243;n sobre como estructurar un juego por red en el manual de usuario de DIV Games Studio.<br/><br/>
<hr/>
Ver: <a href="#181">net_get_games()</a> - <a href="#1410">STRUCT net</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="181">net_get_games()</h2><br/><br/>
<strong>net_get_games()</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Partidas activas para este juego.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve el n&#250;mero de partidas activas para este juego (para conexiones en red local). Esta funci&#243;n sirve para ver si existe alguna partida activa en un momento determinado.<br/><br/>
Para establecer una conexi&#243;n se utiliza la funci&#243;n <a href="#180">net_join_game()</a>, bien sea para crear partidas o para conectarse a las mismas.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_net_get_games;

GLOBAL
  n;  // Partidas activas.

BEGIN

  // ...

  n=net_get_games();

  IF (n&gt;0)
    // ...
  END

  //...

END
</pre>
Unicamente es &#250;til para conexiones IPX, careciendo de sentido en conexiones por cable serie o a trav&#233;s de m&#243;dem (ya que en estos casos &#250;nicamente puede haber una partida).<br/><br/>
<hr/>
Ver: <a href="#180">net_join_game()</a> - <a href="#1410">,STRUCT net</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="182">stop_mode8()</h2><br/><br/>
<strong>stop_mode8(</strong>&lt;n&#250;mero de m8&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Elimina la ventana de modo 8 cuyo n&#250;mero (del 0 al 9) se pasa como par&#225;metro. Este &lt;n&#250;mero de m8&gt; es el que se indic&#243; como primer par&#225;metro en la funci&#243;n <a href="#190">start_mode8()</a>, es necesario debido a que pueden haber hasta 10 ventanas diferentes de modo 8, y el sistema necesita saber cu&#225;l de ellas se est&#225; finalizando.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Crear una ventana de modo 8 es un procedimiento avanzado y requiere iniciar varios par&#225;metros, como en este caso la c&#225;mara, algunos de ellos requeridos por la funci&#243;n <a href="#190">start_mode8()</a> y otros contenidos en la <a href="#1411">estructura global m8</a> (como la variable <strong>m8.camera</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_stop_mode8;

BEGIN
  load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
  load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  write(0,0,0,0,&quot;Pulse ESC para finalizar ...&quot;);
  REPEAT
      FRAME;
  UNTIL (key(_esc));

  stop_mode8(0); // Elimina la regi&#243;n n&#250;mero 0 de modo 8

END
</pre>
Este programa muestra un ejemplo de inicializaci&#243;n de una regi&#243;n de modo 8, cargando el mapa contenido en el archivo <strong>wld_view.prg</strong>, e inicializando una regi&#243;n (la n&#250;mero <strong>0</strong>) con <a href="#190">start_mode8()</a>.<br/><br/>
El programa espera en un bucle hasta detectar la tecla <strong>ESC</strong>, momento en el que sale del mismo y elimina esta regi&#243;n con <strong>stop_mode8()</strong>.<br/><br/>
<hr/>
Ver: <a href="#190">start_mode8()</a> - <strong>1411,STRUCT m8</strong> - <a href="#189">load_wld()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="183">xadvance()</h2><br/><br/>
<strong>xadvance(</strong>&lt;angulo&gt;<strong>,</strong> &lt;distancia&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Avanza el proceso <strong>en el &#225;ngulo indicado</strong> tantos puntos como indique <strong>la distancia indicada</strong> como par&#225;metro.<br/><br/>
Esta funci&#243;n equivale a la funci&#243;n <a href="#101">advance()</a>, si se utiliza la variable <a href="#1129">angle</a> como primer par&#225;metro.<br/><br/>
La distancia puede ser tambi&#233;n un n&#250;mero negativo, con lo cual el gr&#225;fico del proceso avanzar&#225; (sus coordenadas <a href="#1123">x</a> e <a href="#1124">y</a>) en la direcci&#243;n contraria a este &#225;ngulo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_xadvance;

PRIVATE
  angle2;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    graph=101;
    x=160;
    y=100;
    write(0, 0, 0, 0, &quot;Use los cursores para cambiar la direcci&#243;n.&quot;);
    LOOP
        angle+=5000;
        IF (key(_right)) angle2-=10000; END
        IF (key(_left)) angle2+=10000; END

        advance(angle2,4); // Avanzamos dos puntos el proceso

        FRAME;
    END
END
</pre>
Este ejemplo dibujar&#225; un tri&#225;ngulo en pantalla que avanzar&#225; en la direcci&#243;n seleccionada con los cursores, independiente en todo momento de la orientaci&#243;n del gr&#225;fico en pantalla (del &#225;ngulo de visualizaci&#243;n del mismo).<br/><br/>
Se recuerda que el &#225;ngulo se especifica en mil&#233;simas de grado.<br/><br/>
<hr/>
Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a> - <a href="#101">advance()</a> - <a href="#118">get_distx()</a> - <a href="#119">get_disty()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="184">char()</h2><br/><br/>
<strong>char(</strong>&lt;literal&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El valor <strong>ASCII</strong> del (primer) car&#225;cter contenido en el literal.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
La funci&#243;n <strong>char()</strong> sirve para obtener el valor ordinal de un car&#225;cter<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_char;
PRIVATE valor;
BEGIN
  // ..
  valor=&quot;A&quot;;       // Se asigna la direcci&#243;n del literal &quot;A&quot; en memoria.
  // ..
  valor=char(&quot;A&quot;); // Se asigna el valor ASCII de &quot;A&quot; (65 en decimal).
  // ..
END
</pre>
En un programa, los literales (textos entre comillas) se traducen como la direcci&#243;n de memoria en la que se han almacenado los mismos. Para asignar a una variable un car&#225;cter (su valor ordinal), en lugar de la direcci&#243;n de la cadena, se debe utilizar esta funci&#243;n.<br/><br/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="185">path_find()</h2><br/><br/>
<strong>path_find(</strong>&lt;modo&gt;<strong>,</strong> &lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;tama&#241;o casilla&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;, &lt;OFFSET estructura&gt;<strong>,</strong> &lt;sizeof(estructura)&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
N&#250;mero de puntos de la ruta, o 0 si no se encontr&#243; ninguna.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Busca una ruta desde las coordenadas actuales del proceso hasta un punto determinado, sorteando los obst&#225;culos definidos en un mapa de b&#250;squeda (en el manual de usuario se puede encontrar informaci&#243;n sobre estos mapas).<br/><br/>
<strong>El modo.</strong><br/><br/>
Se puede realizar la b&#250;squeda de diferente forma, seg&#250;n el <strong>&lt;modo&gt;</strong> indicado como primer par&#225;metro de la funci&#243;n.<br/><br/>
<strong>0</strong> - B&#250;squeda menos precisa y m&#225;s r&#225;pida.<br/>
<strong>1</strong> - B&#250;squeda m&#225;s precisa, pero m&#225;s lenta.<br/>
<br/><br/>
<strong>El mapa de b&#250;squeda.</strong><br/><br/>
Los c&#243;digos de <strong>&lt;fichero&gt;</strong> y <strong>&lt;gr&#225;fico&gt;</strong> se refieren al mapa de b&#250;squeda. Este es una versi&#243;n reducida del decorado real, donde se aparecen en <strong>color negro</strong> (el n&#250;mero 0 de la paleta) las zonas libres y con <strong>color blanco</strong> los obst&#225;culos del mismo.<br/><br/>
Como <strong>&lt;tama&#241;o casilla&gt;</strong> se indica el factor de reducci&#243;n del mapa de b&#250;squeda, es decir, por cuanto se tendr&#237;an que multiplicar el ancho y alto del mismo para mostrarse a tama&#241;o real. Por ejemplo, si para una pantalla de 320x200 se genera un mapa de b&#250;squeda de 160x100, entonces el tama&#241;o de casilla ser&#225; 2.<br/><br/>
<strong>Los puntos de la ruta.</strong><br/><br/>
A continuaci&#243;n se deben indicar las coordenadas <strong>&lt;x&gt;</strong> e <strong>&lt;y&gt;</strong> hacia las que debe dirigirse el proceso (se toma como origen de la ruta las coordenadas actuales del proceso que ejecute la funci&#243;n <strong>path_find()</strong>).<br/><br/>
Esta funci&#243;n retorna una serie de puntos en una estructura, estos son los puntos que conforman la ruta desde el origen hasta el punto destino.<br/><br/>
Por ello se debe declarar una estructura que contenga dos campos (x,y), y tantos registros como puntos puedan conformar la ruta calculada.<br/><br/>
A la funci&#243;n se le debe pasar, como los dos &#250;ltimos par&#225;metros, la direcci&#243;n (<a href="#1085">OFFSET</a>) de esta estructura y su tama&#241;o (<a href="#1094">SIZEOF()</a>), de forma que pueda devolver el resultado en la misma.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_path_find;

GLOBAL
    num_puntos;
    STRUCT puntos[100]
      x,y;
    END
    &#237;ndice;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 7);
    graph=200;
    mouse.graph=200;
    LOOP

        // Obtiene la ruta hasta las coordenadas del rat&#243;n

        num_puntos=path_find(0,0,201,2,mouse.x,mouse.y,OFFSET puntos,sizeof(puntos));

        // Si se obtuvo una ruta, se muestra y se avanza hasta el destino

        IF (num_puntos&gt;0)
            FOR (&#237;ndice=0;&#237;ndice&lt;num_puntos-1;&#237;ndice++)
                draw(1,24,15,0,puntos[&#237;ndice].x,puntos[&#237;ndice].y,puntos[&#237;ndice+1].x,puntos[&#237;ndice+1].y);
            END
            IF (fget_dist(x,y,puntos[0].x,puntos[0].y)&gt;4)
                xadvance(fget_angle(x,y,puntos[0].x,puntos[0].y),4);
            ELSE
                x=puntos[0].x;
                y=puntos[0].y;
            END
            draw(1,24,15,0,x,y,puntos[0].x,puntos[0].y);
        END

        FRAME;
        delete_draw(all_drawing);
    END
END
</pre>
En este ejemplo se utiliza el <strong>gr&#225;fico n&#250;mero 7</strong> del fichero <strong>help.fpg</strong> como decorado, y el <strong>gr&#225;fico n&#250;mero 201</strong> del mismo como su <strong>mapa de b&#250;squeda</strong>.<br/><br/>
El tama&#241;o de las casillas en el mapa de b&#250;squeda es <strong>2</strong><br/><br/>
El proceso principal est&#225; continuamente obteniendo una ruta hasta el puntero del rat&#243;n con la funci&#243;n <strong>path_find()</strong>.<br/><br/>
Los diferentes segmentos de esta ruta se representas con l&#237;neas utilizando la funci&#243;n <a href="#249">draw()</a>, y el incremento de las coordenadas se realiza con la funci&#243;n <a href="#183">xadvance()</a>.<br/><br/>
Para obtener la distancia y el &#225;ngulo hacia el siguiente punto de la ruta se utilizan las funciones <a href="#114">fget_dist()</a> y <a href="#113">fget_angle()</a>.<br/><br/>
<hr/>
<br/><br/>
Para ver si se puede ir directamente en l&#237;nea recta entre dos puntos (sin atravesar ning&#250;n obst&#225;culo) se puede utilizar la funci&#243;n <a href="#186">path_line()</a>.<br/><br/>
La funci&#243;n <a href="#187">path_free()</a> determina si un punto determinado del mapa es un obst&#225;culo o si es un punto libre (accesible).<br/><br/>
<hr/>
Ver: <a href="#186">path_line()</a> - <a href="#187">path_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="186">path_line()</h2><br/><br/>
<strong>path_line(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;tama&#241;o casilla&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<a href="#1151">True (1)</a>, si se puede ir hasta un punto sin atravesar ning&#250;n obst&#225;culo, o <a href="#1152">false (0)</a> en caso contrario.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Determina si, dentro de un mapa de b&#250;squeda, se puede ir en linea recta hasta un punto (partiendo de las coordenadas actuales del proceso), sin atravesar ning&#250;n obst&#225;culo del mapa de b&#250;squeda (en el manual de usuario se puede encontrar informaci&#243;n sobre estos mapas).<br/><br/>
En caso de querer obtener una ruta para sortear los obst&#225;culos entre dos puntos, se debe utilizar la funci&#243;n <a href="#185">path_find()</a>, y para ver si el punto destino est&#225; dentro de un obst&#225;culo la funci&#243;n <a href="#187">path_free()</a>.<br/><br/>
<strong>El mapa de b&#250;squeda.</strong><br/><br/>
Los c&#243;digos de <strong>&lt;fichero&gt;</strong> y <strong>&lt;gr&#225;fico&gt;</strong> se refieren al mapa de b&#250;squeda. Este es una versi&#243;n reducida del decorado real, donde se aparecen en <strong>color negro</strong> (el n&#250;mero 0 de la paleta) las zonas libres y con <strong>color blanco</strong> los obst&#225;culos del mismo.<br/><br/>
Como <strong>&lt;tama&#241;o casilla&gt;</strong> se indica el factor de reducci&#243;n del mapa de b&#250;squeda, es decir, por cuanto se tendr&#237;an que multiplicar el ancho y alto del mismo para mostrarse a tama&#241;o real. Por ejemplo, si para una pantalla de 320x200 se genera un mapa de b&#250;squeda de 160x100, entonces el tama&#241;o de casilla ser&#225; 2.<br/><br/>
A continuaci&#243;n se deben indicar las coordenadas <strong>&lt;x&gt;</strong> e <strong>&lt;y&gt;</strong> hacia las que debe dirigirse el proceso (se toma como origen de la ruta las coordenadas actuales del proceso que ejecute la funci&#243;n <strong>path_find()</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_path_line;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 7);
    graph=200;
    mouse.graph=200;
    LOOP

        // Mira si puede ir en l&#237;nea recta hacia el rat&#243;n

        IF (path_line(0,201,2,mouse.x,mouse.y))

            IF (fget_dist(x,y,mouse.x,mouse.y)&gt;4)
                xadvance(fget_angle(x,y,mouse.x,mouse.y),4);
                draw(1,24,15,0,x,y,mouse.x,mouse.y);
            ELSE
                x=mouse.x;
                y=mouse.y;
            END
        END

        FRAME;
        delete_draw(all_drawing);
    END
END
</pre>
En este ejemplo se utiliza el <strong>gr&#225;fico n&#250;mero 7</strong> del fichero <strong>help.fpg</strong> como decorado, y el <strong>gr&#225;fico n&#250;mero 201</strong> del mismo como su <strong>mapa de b&#250;squeda</strong>. El tama&#241;o de las casillas en el mapa de b&#250;squeda es <strong>2</strong><br/><br/>
El proceso principal est&#225; continuamente comprobando si se puede ir en l&#237;nea recta hsata las coordenadas del rat&#243;n con la funci&#243;n <strong>path_line()</strong>. Cuando esto sea posible, se traza la l&#237;nea con la funci&#243;n <a href="#249">draw()</a>, y se avanzan las coordenadas del proceso con la funci&#243;n <a href="#183">xadvance()</a>.<br/><br/>
Para obtener la distancia y el &#225;ngulo hacia el cursor del rat&#243;n se utilizan las funciones <a href="#114">fget_dist()</a> y <a href="#113">fget_angle()</a>.<br/><br/>
<hr/>
Ver: <a href="#185">path_find()</a> - <a href="#187">path_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="187">path_free()</h2><br/><br/>
<strong>path_free(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;tama&#241;o casilla&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<a href="#1151">True (1)</a>, si un punto est&#225; libre (no es un obst&#225;culo) en un mapa de b&#250;squeda, o <a href="#1152">false (0)</a> en caso contrario.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Determina si, dentro de un mapa de b&#250;squeda, unas coordenadas est&#225;n situadas en una zona acesible, fuera de cualquier obst&#225;culo (en el manual de usuario se puede encontrar informaci&#243;n sobre estos mapas de b&#250;squeda).<br/><br/>
En caso de querer obtener una ruta para sortear los obst&#225;culos entre dos puntos, se debe utilizar la funci&#243;n <a href="#185">path_find()</a>, y para ver si se puede ir hasta un punto en l&#237;nea recta sin atravesar ning&#250;n obst&#225;culo la funci&#243;n <a href="#186">path_line()</a>.<br/><br/>
<strong>El mapa de b&#250;squeda.</strong><br/><br/>
Los c&#243;digos de <strong>&lt;fichero&gt;</strong> y <strong>&lt;gr&#225;fico&gt;</strong> se refieren al mapa de b&#250;squeda. Este es una versi&#243;n reducida del decorado real, donde se aparecen en <strong>color negro</strong> (el n&#250;mero 0 de la paleta) las zonas libres y con <strong>color blanco</strong> los obst&#225;culos del mismo.<br/><br/>
Como <strong>&lt;tama&#241;o casilla&gt;</strong> se indica el factor de reducci&#243;n del mapa de b&#250;squeda, es decir, por cuanto se tendr&#237;an que multiplicar el ancho y alto del mismo para mostrarse a tama&#241;o real. Por ejemplo, si para una pantalla de 320x200 se genera un mapa de b&#250;squeda de 160x100, entonces el tama&#241;o de casilla ser&#225; 2.<br/><br/>
A continuaci&#243;n se deben indicar las coordenadas <strong>&lt;x&gt;</strong> e <strong>&lt;y&gt;</strong> a consultar.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_path_free;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 7);
    mouse.graph=200;
    mouse.size=400;
    LOOP

        // Mira si el rat&#243;n est&#225; en una zona accesible

        IF (path_free(0,201,2,mouse.x,mouse.y))
            mouse.angle+=5000;
        END

        FRAME;
    END
END
</pre>
En este ejemplo se utiliza el <strong>gr&#225;fico n&#250;mero 7</strong> del fichero <strong>help.fpg</strong> como decorado, y el <strong>gr&#225;fico n&#250;mero 201</strong> del mismo como su <strong>mapa de b&#250;squeda</strong>. El tama&#241;o de las casillas en el mapa de b&#250;squeda es <strong>2</strong><br/><br/>
El proceso principal est&#225; continuamente comprobando, con la funci&#243;n <strong>path_free()</strong>, si el puntero del rat&#243;n se encuentra sobre una zona libre, o bien sobre un obst&#225;culo.<br/><br/>
Cuando el cursor se encuentre en una zona libre, fuera de cualquier obst&#225;culo, se ir&#225; rotando su gr&#225;fico.<br/><br/>
<hr/>
Ver: <a href="#185">path_find()</a> - <a href="#186">path_find()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="188">new_map()</h2><br/><br/>
<strong>new_map(</strong>&lt;ancho&gt;<strong>,</strong> &lt;alto&gt;<strong>,</strong> &lt;centro x&gt;<strong>,</strong> &lt;centro y&gt;<strong>,</strong> &lt;color&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>c&#243;digo del gr&#225;fico</strong> creado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Crea un nuevo mapa en memoria (sin cargarlo de un archivo del disco).<br/><br/>
Para ello, la funci&#243;n requiere el <strong>&lt;ancho&gt;</strong> y <strong>&lt;alto&gt;</strong> (en puntos) del mapa que se debe crear, su punto central (dentro del mismo) en <strong>&lt;centro x&gt;</strong> y <strong>&lt;centro y&gt;</strong>, y el color con el que se debe rellenar inicialmente el mapa (el n&#250;mero de color dentro de la paleta activa, de 0 a 255).<br/><br/>
Esta funci&#243;n se comporta practicam&#233;nte igual que <a href="#174">load_map()</a>, salvo que no se lee un archivo en disco con el gr&#225;fico, sino que se crea como un gr&#225;fico s&#243;lido de un s&#243;lo color.<br/><br/>
Se devuelve como valor de retorno el <strong>c&#243;digo del gr&#225;fico</strong>, que es un valor num&#233;rico que debe especificarse para utilizar el gr&#225;fico, en la variable <a href="#1126">graph</a> o, en general, en todas las funciones que requieran un <strong>c&#243;digo de gr&#225;fico</strong> entre sus par&#225;metros.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong><br/><br/>
Cuando se requiera dentro de una funci&#243;n el <strong>c&#243;digo de fichero</strong> al que pertenece dicho gr&#225;fico, se debe indicar el c&#243;digo <strong>0</strong> (que es el c&#243;digo del primer <strong>fichero FPG</strong> que se cargue en el programa).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_new_map;

BEGIN

    // Se crea un mapa de 16x32 puntos
    // con su centro en el punto (0,0)
    // y con el color 15 de la paleta

    mouse.graph = new_map(16,32,0,0,15); // Se asigna como puntero del rat&#243;n

    REPEAT
        FRAME;
    UNTIL (key(_esc));

    unload_map(mouse.graph); // Y finalmente se libera o descarga el gr&#225;fico
END
</pre>
En el ejemplo se crea un mapa con la funci&#243;n <strong>new_map()</strong> guardando el <strong>c&#243;digo del gr&#225;fico</strong> que retorna en la variable <a href="#1100">mouse.graph</a>, de forma que aparezca como puntero del rat&#243;n.<br/><br/>
Pulsando la tecla <strong>ESC</strong> se saldr&#225; del bucle de visualizaci&#243;n del programa y se descargar&#225; el gr&#225;fico con la funci&#243;n <a href="#176">unload_map()</a> (exactamente igual que si se hubiera cargado de un archivo del disco).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#176">unload_map()</a> permite liberar la memoria del ordenador utilizada por el gr&#225;fico cuando ya no se va a utilizar m&#225;s durante un tiempo, y para ello requiere tambi&#233;n el <strong>codigo del gr&#225;fico</strong> para saber qu&#233; gr&#225;fico es el que se quiere descargar de memoria.<br/><br/>
<strong>No es necesario descargar el gr&#225;fico de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
<hr/>
Ver: <a href="#174">load_map/pcx()</a> - <a href="#176">unload_map/pcx()</a> - <a href="#1126">graph</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="189">load_wld()</h2><br/><br/>
<strong>load_wld(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;fichero&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga un <strong>mapa de modo 8</strong> en un programa. Estos mapas se guardan en los archivos con extensi&#243;n WLD, y se crean con el men&#250; de mapas 3d (en el manual de usuario se puede encontrar m&#225;s informaci&#243;n sobre como construir estos mapas).<br/><br/>
Se requieren como par&#225;metros el <strong>&lt;nombre de archivo&gt;</strong> que contiene el mapa en formato WLD, y el c&#243;digo del <strong>&lt;fichero&gt;</strong> que contiene las texturas del mismo. Este fichero con las texturas del mapa se debe haber cargado previamente en el programa con la funci&#243;n <a href="#132">load_fpg()</a>.<br/><br/>
Una vez cargado el mapa, se debe iniciar una regi&#243;n de pantalla de modo 8 con la funci&#243;n <a href="#190">start_mode8()</a>. El funcionamiento es muy similar a los modos 7 que muestran un plano abatido (ver <a href="#162">start_mode7()</a>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_wld;

GLOBAL
    fichero;

BEGIN
  set_mode(m640x480);
  set_fps(70,0);
  fichero = load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);

  load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,fichero); // Carga un archivo WLD

  start_mode8(id,0,0);
  ctype=c_m8;
  height=64;
  radius=64;
  m8.height=32;
  go_to_flag(0);
  LOOP
    IF (key(_right)) angle-=5000; END
    IF (key(_left))  angle+=5000; END
    IF (key(_up))    advance(24); END
    IF (key(_down))  advance(-9); END
    IF (key(_q))     z+=16;       END
    IF (key(_a))     z-=16;       END
    IF (key(_w))     m8.angle+=8; END
    IF (key(_s))     m8.angle-=8; END
    FRAME;
  END
END
</pre>
Este programa muestra un ejemplo de inicializaci&#243;n de una regi&#243;n de modo 8, cargando el mapa contenido en el archivo <strong>wld_view.prg</strong>, y cuyas texturas se encuentran en el fichero <strong>wld_view.fpg</strong>.<br/><br/>
<hr/>
Ver: <a href="#190">start_mode8()</a> - <a href="#191">go_to_flag()</a> - <a href="#132">load_fpg()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="190">start_mode8()</h2><br/><br/>
<strong>start_mode8(</strong>&lt;identificador de la c&#225;mara&gt;<strong>,</strong> &lt;n&#250;mero de m8&gt;<strong>,</strong> &lt;n&#250;mero de regi&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
&#201;sta es una funci&#243;n avanzada que requiere que el usuario tenga cierta experiencia para poder utilizarla.<br/><br/>
Crea una ventana de visualizaci&#243;n de un modo 8, es decir, visualiza un mapa de sectores tridimensional; <strong>en primer lugar se debe cargar el mapa con la funci&#243;n</strong> <a href="#189">load_wld()</a>, y entonces a esta funci&#243;n con los siguientes par&#225;metros:<br/><br/>
<strong>&lt;identificador de la c&#225;mara&gt;</strong> - <a href="#1039">C&#243;digo identificador</a> del proceso en cuya posici&#243;n debe situarse la c&#225;mara del modo 8, la c&#225;mara se situar&#225; en las coordenadas <strong>(x,y)</strong>, a la altura <strong>(z)</strong> y mirando en la direcci&#243;n indicada por <strong>(angle)</strong> (todos son <a href="#1201">datos locales predefinidos</a> del proceso).<br/><br/>
<strong>&lt;n&#250;mero de m8&gt;</strong> - Se pueden crear hasta 10 ventanas de modo 8 en pantalla, con los n&#250;mero del <strong>0</strong> al <strong>9</strong>; si &#250;nicamente se quiere crear una, lo mejor es definir la n&#250;mero <strong>0</strong>. Este n&#250;mero ser&#225; necesario posteriormente para modificar los par&#225;metros de la ventana, pues el sistema necesitar&#225; saber cu&#225;l de las <strong>10</strong> posibles ventanas de modo 8 se quiere alterar.<br/><br/>
<strong>&lt;n&#250;mero de regi&#243;n&gt;</strong> - Aqu&#237; se indicar&#225; la regi&#243;n rectangular de pantalla en la que se va a mostrar el modo 8. Si se indica <strong>0</strong> como n&#250;mero de regi&#243;n, se mostrar&#225; en toda la pantalla. El resto de regiones se deben definir previamente con la funci&#243;n <a href="#106">define_regi&#243;n()</a> (una <strong>regi&#243;n</strong> no es m&#225;s que una zona rectangular de la pantalla).<br/><br/>
<strong>Nota:</strong> El funcionamiento es muy similar a los modos 7 que muestran un plano abatido (ver <a href="#162">start_mode7()</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Adem&#225;s de la llamada a la funci&#243;n se deben inicializar algunos valores de la</strong> <a href="#1411">estructura global m8</a> <strong>para el correcto funcionamiento de la ventana</strong>. &#201;sta es una estructura de 10 registros (uno para cada posible ventana de modo 8) y cada registro tiene los siguientes campos:<br/><br/>
<strong>camera</strong>   - <a href="#1039">C&#243;digo identificador</a> de la c&#225;mara<br/>
<strong>height</strong>   - Altura de la c&#225;mara respecto al proceso<br/>
<strong>angle</strong>    - Angulo vertical de la c&#225;mara (-128,128)<br/>
<strong>z</strong>        - Plano de profundidad (prioridad de impresi&#243;n de la regi&#243;n)<br/>
<br/><br/>
El campo <strong>camera</strong> es <strong>imprescindible</strong>, por ello se solicita como uno de los par&#225;metros de llamada de la funci&#243;n <strong>start_mode8()</strong> ya que, sin este campo, la ventana no puede determinar desde d&#243;nde se debe <strong>ver</strong> el mapa.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_start_mode8;

GLOBAL
    fichero;

BEGIN
  set_mode(m640x480);
  set_fps(70,0);
  fichero = load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
  load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,fichero);

  start_mode8(id,0,0); // Inicializa una regi&#243;n de modo 8

  ctype=c_m8;
  height=64;
  radius=64;
  m8.height=32;
  go_to_flag(0);
  LOOP
      IF (key(_right)) angle-=5000; END
      IF (key(_left))  angle+=5000; END
      IF (key(_up))    advance(24); END
      IF (key(_down))  advance(-9); END
      IF (key(_q))     z+=16;       END
      IF (key(_a))     z-=16;       END
      IF (key(_w))     m8.angle+=8; END
      IF (key(_s))     m8.angle-=8; END
      FRAME;
  END
END
</pre>
Este programa muestra un ejemplo de inicializaci&#243;n de una regi&#243;n de modo 8, cargando el mapa contenido en el archivo <strong>wld_view.prg</strong>, y cuyas texturas se encuentran en el fichero <strong>wld_view.fpg</strong>.<br/><br/>
<hr/>
<br/><br/>
Para crear un proceso cuyo gr&#225;fico se visualice en el modo 8, se debe definir su variable local <a href="#1122">ctype</a> como <a href="#1412">c_m8</a> (<strong>tipo de coordenada</strong> como <strong>coordenada de modo 8</strong>).<br/><br/>
Cuando un proceso pertenezca al modo 8 sus variables <a href="#1123">x</a> e <a href="#1124">y</a> estar&#225;n referidas al punto dentro del mapa de sectores (WLD), y su variable <a href="#1125">z</a> indicar&#225; la altura.<br/><br/>
Si hubiera varias ventanas de <strong>modo 8</strong> el proceso se visualizar&#237;a por defecto en todas, si &#250;nicamente se tuviera que visualizar el algunas de ellas, se deber&#237;a definir su variable local <a href="#1134">cnumber</a>.<br/><br/>
Para que un proceso tenga varios gr&#225;ficos (varias vistas), dependiendo del &#225;ngulo desde el que se le mire, se debe definir su gr&#225;fico con la variable local <a href="#1132">xgraph</a> (en lugar de la variable <a href="#1126">graph</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para eliminar una regi&#243;n de modo 8 se debe utilizar la funci&#243;n <a href="#182">stop_mode8()</a>, a la que se le debe indicar el <strong>n&#250;mero de m8</strong>.<br/><br/>
<hr/>
Ver: <a href="#1411">STRUCT m8</a> - <a href="#189">load_wld()</a> - <a href="#191">go_to_flag()</a> - <a href="#182">stop_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="191">go_to_flag()</h2><br/><br/>
<strong>go_to_flag(</strong>&lt;n&#250;mero de bandera&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Posiciona un proceso de un modo 8 en una bandera, el propio proceso que quiere situarse en dicha posici&#243;n es el que debe llamar a la funci&#243;n, y como &#250;nico par&#225;metro se debe indicar el <strong>&lt;n&#250;mero de bandera&gt;</strong>.<br/><br/>
Tras llamar a la funci&#243;n el proceso se situar&#225;, en el pr&#243;ximo <a href="#1029">FRAME</a>, en las coordenadas de la bandera. La altura de la bandera siempre se entiende como la altura m&#237;nima del sector en el que se encuentre.<br/><br/>
Las banderas se sit&#250;an en el editor de mapas tridimensionales, cuyo manejo est&#225; explicado en el manual de usuario del programa.<br/><br/>
<strong>Nota:</strong> Esta funci&#243;n equivale simplemente a asignarle al proceso las coordenadas de esta bandera a sus coordenadas (<strong>x</strong>,<strong>y</strong>,<strong>z</strong>). La ventaja que proporciona, es el poder situar directamente en el editor la posici&#243;n de determinados objetos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_go_to_flag;

BEGIN
  load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
  load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
  start_mode8(id,0,0);
  ctype=c_m8;

  go_to_flag(0); // Sit&#250;a el proceso c&#225;mara en la bandera 0

  LOOP
      FRAME;
  END
END
</pre>
Este programa ejemplo inicializa de una regi&#243;n de modo 8 cargando el mapa contenido en el archivo <strong>wld_view.prg</strong> con la funci&#243;n <a href="#189">load_wld()</a>, e inicializa una regi&#243;n con <a href="#190">start_mode8()</a>.<br/><br/>
Entonces sit&#250;a al proceso (que act&#250;a como c&#225;mara de la ventana) en la posici&#243;n indicada por la bandera n&#250;mero 0 del mapa de sectores.<br/><br/>
<hr/>
Ver: <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a> - <a href="#189">load_wld()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="192">set_sector_height()</h2><br/><br/>
<strong>set_sector_height(</strong>&lt;n&#250;mero de sector&gt;<strong>,</strong> &lt;altura del suelo&gt;<strong>,</strong> &lt;altura del techo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica la altura del <strong>suelo</strong> o <strong>techo</strong> de un sector de un modo 8. Se requieren los siguientes par&#225;metros:<br/><br/>
<strong>&lt;n&#250;mero de sector&gt;</strong> - N&#250;mero de sector del mapa cuyas alturas se quieren modificar. Este n&#250;mero se puede obtener en el editor de mapas tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.<br/><br/>
<strong>&lt;altura del suelo&gt;</strong> - Se debe indicar la nueva altura del suelo del sector (un valor entre 0 y 4096), si se indica<strong> -1</strong> como par&#225;metro, se mantendr&#225; la altura actual del suelo del sector (&#250;til para modificar s&#243;lo la altura del techo).<br/><br/>
<strong>&lt;altura del techo&gt;</strong> - Se debe indicar la nueva altura del techo del sector (un valor entre 0 y 4096), si se indica<strong> -1</strong> como par&#225;metro, se mantendr&#225; la altura actual del techo del sector (&#250;til para modificar s&#243;lo la altura del suelo).<br/><br/>
Para iniciar una regi&#243;n de modo 8, se debe llamar a la funci&#243;n <a href="#190">start_mode8()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Si la altura del techo es igual a la del suelo, no se podr&#225; entrar en dicho sector (si este est&#225; dentro de otro, aparecer&#225; como una columna). La altura del techo no debe ser inferior a la altura del suelo.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_sector_height;

GLOBAL
    sector=255;
    altura;
    &#225;ngulo1;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=64;
    LOOP
        altura=1000+get_distx(&#225;ngulo1,64);
        &#225;ngulo1+=5000;

        set_sector_height(sector,altura,-1);

        FRAME;
    END
END
</pre>
Este peque&#241;o ejemplo inicializa una regi&#243;n de modo 8, cargando el mapa <strong>wld_view.wld</strong>, y se sit&#250;a en unas coordenadas predeterminadas con la funci&#243;n <a href="#191">go_to_flag()</a>.<br/><br/>
Posteriormente, dentro del bucle principal del programa, se fija la altura del suelo del sector n&#250;mero <strong>255</strong> con la funci&#243;n <strong>set_sector_height()</strong>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#193">get_sector_height()</a> permite averiguar las alturas de suelo y techo de un sector de un modo 8.<br/><br/>
<hr/>
Ver: <a href="#193">get_sector_height()</a> - <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="193">get_sector_height()</h2><br/><br/>
<strong>get_sector_height(</strong>&lt;n&#250;mero de sector&gt;<strong>,</strong> &lt;OFFSET suelo&gt;<strong>,</strong> &lt;OFFSET techo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La <strong>altura de suelo y techo</strong> de un sector de un modo 8 (en las variables cuyo <a href="#1085">offset</a> se indica como los dos &#250;ltimos par&#225;metros).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar dentro de un programa la altura del suelo y techo de un sector determinado, dentro de un modo 8.<br/><br/>
Para ello se requiere el <strong>&lt;n&#250;mero de sector&gt;</strong>, y el <a href="#1085">OFFSET</a> (direcci&#243;n de memoria) de las dos variables en las que debe devolver el resultado.<br/><br/>
Esta informaci&#243;n tambi&#233;n puede obtenerse dentro del editor de mapas tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_sector_height;

GLOBAL
    altura_techo;
    altura_suelo;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    // ...

    // Obtiene las alturas de un sector

    get_sector_height(255,OFFSET altura_suelo,OFFSET altura_techo);

    // ...
END
</pre>
Este peque&#241;o ejemplo muestra como debe llamarse a la funci&#243;n <strong>get_sector_height()</strong> para obtener las alturas de un sector (en este caso, en las variables <strong>altura_techo</strong> y <strong>altura_suelo</strong> se obtiene estos valores para el sector n&#250;mero <strong>255</strong>).<br/><br/>
<hr/>
<br/><br/>
Para establecer din&#225;micamente las alturas de un sector se debe utilizar la funci&#243;n <a href="#192">set_sector_height()</a>.<br/><br/>
<hr/>
Ver: <a href="#192">set_sector_height()</a> - <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="194">set_point_m8()</h2><br/><br/>
<strong>set_point_m8(</strong>&lt;n&#250;mero de v&#233;rtice&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica las coordenadas de un v&#233;rtice de un mapa tridimensional de modo 8. Se requieren los siguientes par&#225;metros:<br/><br/>
<strong>&lt;n&#250;mero de v&#233;rtice&gt;</strong> - N&#250;mero de v&#233;rtice del mapa cuya posici&#243;n se quiere modificar. Este n&#250;mero se puede obtener en el editor de mapas tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.<br/><br/>
<strong>&lt;x&gt;</strong>, <strong>&lt;y&gt;</strong> - Se debe indicar las nuevas coordenadas del v&#233;rtice. Las coordenadas dentro de un mapa tridimensional se situan dentro del rango (<strong>0</strong> .. <strong>30200</strong>).<br/><br/>
Para iniciar una regi&#243;n de modo 8, se debe llamar a la funci&#243;n <a href="#190">start_mode8()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Esta es una funci&#243;n cuya utilizaci&#243;n puede desembocar en m&#250;ltiples <strong>errores de visibilidad</strong>. Por ello, no se recomienda su utilizaci&#243;n a usuarios con poca experiencia.<br/><br/>
Los v&#233;rtices &#250;nicamente se pueden mover <strong>dentro del sector</strong> en el que se encuentren, <strong>no se pueden cruzar</strong> (ni los v&#233;rtices, ni las l&#237;neas que estos forman) y, adem&#225;s, no se deben mover sectores que puedan contener procesos en su interior.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_point_m8;

GLOBAL
    posici&#243;n1;
    posici&#243;n2;
    &#225;ngulo1;
    &#225;ngulo2;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=64;
    LOOP
        posici&#243;n1=3400+get_distx(&#225;ngulo1,150);
        &#225;ngulo1+=5000;
        posici&#243;n2=3400+get_distx(&#225;ngulo2,150);
        &#225;ngulo2+=7000;

        set_point_m8(1620,posicion1,9280); // Fija el v&#233;rtice 1620

        set_point_m8(1621,posicion2,9456); // Fija el v&#233;rtice 1621

        FRAME;
    END
END
</pre>
Este peque&#241;o ejemplo inicializa una regi&#243;n de modo 8, cargando el mapa <strong>wld_view.wld</strong>, y se sit&#250;a en unas coordenadas predeterminadas con la funci&#243;n <a href="#191">go_to_flag()</a>.<br/><br/>
Posteriormente, dentro del bucle principal del programa, se fija la posici&#243;n de los v&#233;rtices <strong>1620</strong> y <strong>1621</strong> con la funci&#243;n <strong>set_point_m8()</strong>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#195">get_point_m8()</a> permite averiguar las coordenadas de un v&#233;rtice de un mapa tridimensional para modo 8.<br/><br/>
<hr/>
Ver: <a href="#195">get_point_m8()</a> - <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="195">get_point_m8()</h2><br/><br/>
<strong>get_point_m8(</strong>&lt;n&#250;mero de v&#233;rtice&gt;<strong>,</strong> &lt;OFFSET x&gt;<strong>,</strong> &lt;OFFSET y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Las <strong>coordenadas de un v&#233;rtice</strong> de un mapa de modo 8 (en las variables cuyo <a href="#1085">offset</a> se indica como los dos &#250;ltimos par&#225;metros).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar dentro de un programa las coordenadas de un v&#233;rtice determinado, dentro de un modo 8.<br/><br/>
Para ello se requiere el <strong>&lt;n&#250;mero de v&#233;rtice&gt;</strong>, y el <a href="#1085">OFFSET</a> (direcci&#243;n de memoria) de las dos variables en las que debe devolver el resultado.<br/><br/>
Esta informaci&#243;n tambi&#233;n puede obtenerse dentro del editor de mapas tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_point_m8;

GLOBAL
    posici&#243;n_x;
    posici&#243;n_y;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    // ...

    // Obtiene las coordenadas de un v&#233;rtice

    get_point_m8(1620,OFFSET posici&#243;n_x,OFFSET posici&#243;n_y);

    // ...
END
</pre>
Este peque&#241;o ejemplo muestra como debe llamarse a la funci&#243;n <strong>get_point_m8()</strong> para obtener las alturas de un sector (en este caso, en las variables <strong>posici&#243;n_x</strong> y <strong>posici&#243;n_y</strong>).<br/><br/>
<hr/>
<br/><br/>
Para establecer din&#225;micamente las posici&#243;n de un v&#233;rtice se debe utilizar la funci&#243;n <a href="#194">set_point_m8()</a>.<br/><br/>
<hr/>
Ver: <a href="#194">set_point_m8()</a> - <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="196">set_fog()</h2><br/><br/>
<strong>set_fog(</strong>&lt;posici&#243;n inicio&gt;<strong>,</strong> &lt;posici&#243;n final&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica la niebla de un modo 8 iniciado con la funci&#243;n <a href="#190">start_mode8()</a>, para ello se requieren los siguientes par&#225;metros:<br/><br/>
<strong>&lt;posici&#243;n inicio&gt;</strong> - Porcentaje o distancia inicial de la niebla (de 0 a 100), de esta forma se determina a partir de que punto se comienza a aplicar el efecto.<br/><br/>
<strong>&lt;posici&#243;n final&gt;</strong> - Porcentaje o distancia final de la niebla (de 0 a 100), de esta forma se determina a partir de que punto la niebla ser&#225; completamente opaca.<br/><br/>
Normalmente se suele establecer la posici&#243;n o porcentaje final como el doble del inicial, cuanto m&#225;s distanciados est&#233;n ambos valores, m&#225;s l&#233;ntamente se ir&#225; introduciendo la niebla.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_fog;

GLOBAL
    niebla;
    &#225;ngulo1;

BEGIN
  load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
  load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  FRAME;
  z+=128;
  LOOP
      niebla=25+get_distx(&#225;ngulo1,20);
      &#225;ngulo1+=5000;

      set_fog(niebla,niebla*2); // Establece el nivel de niebla del modo 8

      FRAME;
  END
END
</pre>
Este peque&#241;o ejemplo muestra como debe llamarse a la funci&#243;n <strong>set_fog()</strong> para modificar la niebla de una regi&#243;n de modo 8.<br/><br/>
La variable <strong>niebla</strong> se va variando entre <strong>5</strong> y <strong>45</strong> (utilizando la funci&#243;n <a href="#118">get_distx()</a>), este ser&#225; la posici&#243;n inicial, la final se fijar&#225; siempre el doble que esta.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <a href="#201">set_env_color()</a> permite fijar el color ambiente o de niebla de una regi&#243;n de modo 8.<br/><br/>
<hr/>
Ver: <a href="#201">set_env_color()</a> - <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="197">set_sector_texture()</h2><br/><br/>
<strong>set_sector_texture(</strong>&lt;n&#250;mero de sector&gt;<strong>,</strong> &lt;textura suelo&gt;<strong>,</strong> &lt;textura techo&gt;<strong>,</strong> &lt;luminosidad&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica las <strong>texturas de suelo y techo</strong> de un sector de un modo 8. Se requieren los siguientes par&#225;metros:<br/><br/>
<strong>&lt;n&#250;mero de sector&gt;</strong> - N&#250;mero de sector del mapa cuyas texturas se quieren modificar. Este n&#250;mero se puede obtener en el editor de mapas tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.<br/><br/>
<strong>&lt;textura del suelo&gt;</strong> - Se debe indicar c&#243;digo del gr&#225;fico que se desea asignar como nueva <strong>textura del suelo</strong> del sector (el n&#250;mero de gr&#225;fico dentro del FPG que contiene todas las texturas del modo 8). Si se indica<strong> -1</strong> como par&#225;metro, se mantendr&#225; la textura actual (para modificar s&#243;lo la del techo).<br/><br/>
<strong>&lt;textura del techo&gt;</strong> - Se debe indicar c&#243;digo del gr&#225;fico que se desea asignar como nueva <strong>textura del techo</strong> del sector (el n&#250;mero de gr&#225;fico dentro del FPG que contiene todas las texturas del modo 8). Si se indica<strong> -1</strong> como par&#225;metro, se mantendr&#225; la textura actual (para modificar s&#243;lo la del suelo).<br/><br/>
<strong>&lt;luminosidad&gt;</strong> - Luminosidad de la textura, de <strong>0</strong> (color de ambiente, que normalmente es de color negro) hasta <strong>15</strong> (textura con los colores originales). Si se indica<strong> -1</strong> se mantendr&#225; el nivel de luminosidad actual del sector.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Todas las texturas deben estar contenidas en un mismo archivo FPG, este es el archivo que se carga con <a href="#132">load_fpg()</a> y cuyo n&#250;mero se pasa como par&#225;metro a la funci&#243;n <a href="#189">load_wld()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_sector_texture;

GLOBAL
    textura=94;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=128;
    m8.angle=-64;
    LOOP
        IF (textura++==103) textura=94; END

        set_sector_texture(255,textura,-1,15);

        FRAME;
    END
END
</pre>
Este peque&#241;o ejemplo inicializa una regi&#243;n de modo 8, cargando el mapa <strong>wld_view.wld</strong>, y se sit&#250;a en unas coordenadas predeterminadas con la funci&#243;n <a href="#191">go_to_flag()</a>.<br/><br/>
Posteriormente, dentro del bucle principal del programa, se fija la textura del suelo del sector n&#250;mero <strong>255</strong> con la funci&#243;n <strong>set_sector_texture()</strong>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#198">get_sector_texture()</a> permite averiguar cuales son las texturas (y luminosidad) que tiene un sector de modo 8.<br/><br/>
La funci&#243;n <a href="#199">set_wall_texture()</a> permite establecer la textura de una pared.<br/><br/>
<hr/>
Ver: <a href="#198">get_sector_texture()</a> - <a href="#199">set_wall_texture()</a> - <a href="#192">set_sector_height()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="198">get_sector_texture()</h2><br/><br/>
<strong>get_sector_texture(</strong>&lt;n&#250;mero de sector&gt;<strong>,</strong> &lt;OFFSET textura suelo&gt;<strong>,</strong> &lt;OFFSET textura techo&gt;<strong>,</strong> &lt;OFFSET luminosidad&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La <strong>luminosidad, y las texturas del suelo y techo</strong> de un sector de un modo 8 (en las variables cuyo <a href="#1085">offset</a> se indica en los par&#225;metros).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar dentro de un programa cuales son las texturas de suelo y techo o la luminosidad de un sector determinado, dentro de un modo 8.<br/><br/>
Para ello se requiere el <strong>&lt;n&#250;mero de sector&gt;</strong>, y el <a href="#1085">OFFSET</a> (direcci&#243;n de memoria) de las variables en las que debe devolver el resultado.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_sector_texture;

GLOBAL
    textura_suelo;
    textura_techo;
    luminosidad;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    // ...

    // Obtiene la luminosidad y texturas de un sector

    get_sector_texture(255,OFFSET textura_suelo,OFFSET textura_techo,OFFSET luminosidad);

    // ...
END
</pre>
Este peque&#241;o ejemplo muestra como debe llamarse a la funci&#243;n <strong>get_sector_texture()</strong> para obtener las texturas y luminosidad de un sector (en este caso, en las variables <strong>textura_techo</strong>, <strong>textura_suelo</strong> y <strong>luminosidad</strong> se obtiene estos valores para el sector n&#250;mero <strong>255</strong>).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#197">set_sector_texture()</a> permite establecer las texturas y luminosidad de un sector de modo 8 din&#225;micamente.<br/><br/>
La funci&#243;n <a href="#200">get_wall_texture()</a> permite averiguar cual es la textura de una pared de un modo 8.<br/><br/>
<hr/>
Ver: <a href="#197">set_sector_texture()</a> - <a href="#200">get_wall_texture()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="199">set_wall_texture()</h2><br/><br/>
<strong>set_wall_texture(</strong>&lt;n&#250;mero de sector&gt;<strong>,</strong> &lt;textura&gt;<strong>,</strong> &lt;luminosidad&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica la <strong>textura de una pared</strong> de un modo 8. Se requieren los siguientes par&#225;metros:<br/><br/>
<strong>&lt;n&#250;mero de pared&gt;</strong> - N&#250;mero de pared del mapa cuya textura se quiere modificar. Este n&#250;mero se puede obtener en el editor de mapas tridimensionales, cuyo manejo se aborda en el manual de usuario del programa.<br/><br/>
<strong>&lt;textura&gt;</strong> - Se debe indicar c&#243;digo del gr&#225;fico que se desea asignar como nueva textura de la pared (el n&#250;mero de gr&#225;fico dentro del FPG que contiene todas las texturas del modo 8). Si se indica<strong> -1</strong> como par&#225;metro, se mantendr&#225; la textura actual.<br/><br/>
<strong>&lt;luminosidad&gt;</strong> - Luminosidad de la textura, de <strong>0</strong> (color de ambiente, que normalmente es de color negro) hasta <strong>15</strong> (textura con los colores originales). Si se indica<strong> -1</strong> se mantendr&#225; el nivel de luminosidad actual.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Todas las texturas deben estar contenidas en un mismo archivo FPG, este es el archivo que se carga con <a href="#132">load_fpg()</a> y cuyo n&#250;mero se pasa como par&#225;metro a la funci&#243;n <a href="#189">load_wld()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_wall_texture;

GLOBAL
    textura=104;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    start_mode8(id,0,0);
    ctype=c_m8;
    go_to_flag(1);
    FRAME;
    z+=128;
    LOOP
        IF (textura++==113) textura=104; END

        set_wall_texture(511,textura,15); // Modifica la textura de una pared

        FRAME;
    END
END
</pre>
Este peque&#241;o ejemplo inicializa una regi&#243;n de modo 8, cargando el mapa <strong>wld_view.wld</strong>, y se sit&#250;a en unas coordenadas predeterminadas con la funci&#243;n <a href="#191">go_to_flag()</a>.<br/><br/>
Posteriormente, dentro del bucle principal del programa, se fija la textura de la pared n&#250;mero <strong>255</strong> con la funci&#243;n <strong>set_wall_texture()</strong>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#200">get_wall_texture()</a> permite averiguar cual es la textura de una pared.<br/><br/>
La funci&#243;n <a href="#197">set_sector_texture()</a> permite establecer las <strong>texturas de suelo y techo</strong> de un sector de modo 8.<br/><br/>
<hr/>
Ver: <a href="#200">get_wall_texture()</a> - <a href="#197">set_sector_texture()</a> - <a href="#192">set_sector_height()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="200">get_wall_texture()</h2><br/><br/>
<strong>get_wall_texture(</strong>&lt;n&#250;mero de pared&gt;<strong>,</strong> &lt;OFFSET textura&gt;<strong>,</strong> &lt;OFFSET luminosidad&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La <strong>luminosidad y la textura</strong> de una pared de un modo 8 (en las variables cuyo <a href="#1085">offset</a> se indica en los par&#225;metros).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar dentro de un programa cual es la textura y luminosidad de una pared determinada, dentro de un modo 8.<br/><br/>
Para ello se requiere el <strong>&lt;n&#250;mero de pared&gt;</strong>, y el <a href="#1085">OFFSET</a> (direcci&#243;n de memoria) de las variables en las que debe devolver el resultado.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_wall_texture;

GLOBAL
    textura;
    luminosidad;

BEGIN
    load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
    load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
    // ...

    // Obtiene la luminosidad y textura de una pared

    get_wall_texture(255,OFFSET textura,OFFSET luminosidad);

    // ...
END
</pre>
Este peque&#241;o ejemplo muestra como debe llamarse a la funci&#243;n <strong>get_wall_texture()</strong> para obtener la textura y luminosidad de un sector (en este caso, en las variables <strong>textura</strong> y <strong>luminosidad</strong> se obtiene estos valores para la pared n&#250;mero <strong>255</strong>).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#199">set_wall_texture()</a> permite establecer la textura y luminosidad de una pared de modo 8 din&#225;micamente.<br/><br/>
La funci&#243;n <a href="#198">get_sector_texture()</a> permite averiguar cuales son las texturas de suelo y techo de un sector de un modo 8.<br/><br/>
<hr/>
Ver: <a href="#199">set_wall_texture()</a> - <a href="#198">get_sector_texture()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="201">set_env_color()</h2><br/><br/>
<strong>set_env_color(</strong>&lt;% red&gt;<strong>,</strong> &lt;% green&gt;<strong>,</strong> &lt;% blue&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica el color del ambiente o niebla de un modo 8, para ello se requieren las componentes <strong>&lt;red&gt;</strong> (rojo), <strong>&lt;green&gt;</strong> (verde) y <strong>&lt;blue&gt;</strong> (azul) del mismo.<br/><br/>
Las tres componentes se deben especificar como un porcentaje, de <strong>0</strong> a <strong>100</strong>.<br/><br/>
Por defecto la niebla se establece de color negro (0,0,0), pero se puede modificar este color para crear ambientes distintos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_env_color;

GLOBAL
    luz;
    &#225;ngulo1;

BEGIN
  load_fpg(&quot;HELP\WLD_VIEW.FPG&quot;);
  load_wld(&quot;HELP\WLD_VIEW.WLD&quot;,0);
  start_mode8(id,0,0);
  ctype=c_m8;
  go_to_flag(0);
  FRAME;
  set_fog(30,90);
  z+=128;
  LOOP
      luz=50+get_distx(&#225;ngulo1,50);
      &#225;ngulo1+=5000;

      set_env_color(luz,luz,luz); // Establece el color ambiente

      FRAME;
  END
END
</pre>
Este peque&#241;o ejemplo muestra como debe llamarse a la funci&#243;n <strong>set_env_color()</strong> para modificar el color de la niebla de una regi&#243;n de modo 8.<br/><br/>
La variable <strong>luz</strong> se va variando entre <strong>0</strong> y <strong>100</strong> (utilizando la funci&#243;n <a href="#118">get_distx()</a>), y se fija este mismo porcentaje para las tres componentes del color, de forma que este aparecer&#225; entre <strong>negro</strong> y <strong>blanco</strong>, pasando por toda la escala de grises.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <a href="#196">set_fog()</a> permite fijar la densidad de la niebla o ambiente de una regi&#243;n de modo 8.<br/><br/>
<hr/>
Ver: <a href="#196">set_fog()</a> - <a href="#190">start_mode8()</a> - <a href="#1411">STRUCT m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="202">strcpy()</h2><br/><br/>
<strong>strcpy(</strong>&lt;cadena destino&gt;<strong>,</strong> &lt;cadena origen&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Copia una cadena y retorna la direcci&#243;n de la cadena destino.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Copia la <strong>&lt;cadena origen&gt;</strong> sobre la <strong>&lt;cadena destino&gt;</strong>, a partir de su inicio (se perder&#225; el contenido de anterior de esta &#250;ltima).<br/><br/>
La <strong>&lt;cadena destino&gt;</strong> debe ser un dato de tipo <a href="#1406">STRING</a>, de una longitud suficiente como para contener el texto de la <strong>&lt;cadena origen&gt;</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strcpy;

GLOBAL
    STRING cadena1=&quot;Texto inicial&quot;;

BEGIN
    write(0,0,0,0,&quot;Texto contenido en &lt;cadena1&gt;:&quot;);
    write(0,0,10,0,cadena1);
    write(0,0,192,0,&quot;Pulse [ESPACIO] para copiar otro texto en &lt;cadena1&gt;&quot;);
    LOOP
        IF (key(_space))

            strcpy(cadena1,&quot;Texto final&quot;); // Modifica cadena1

        END
        FRAME;
   END
END
</pre>
<hr/>
<br/><br/>
Cuando la longitud de la cadena copiada sea menor de 1024 car&#225;cteres, se podr&#225; realizar esta misma operaci&#243;n con una sentencia como la siguiente (continuando con el ejemplo anterior):<br/><br/>
<strong>cadena1 = &quot;Texto final&quot;;</strong><br/><br/>
Es decir, con una sentencia gen&#233;rica de <a href="#1019">asignaci&#243;n</a> como la siguiente:<br/><br/>
<strong>&lt;cadena destino&gt; = &lt;cadena origen&gt; ;</strong><br/><br/>
Siendo siempre <strong>&lt;cadena destino&gt;</strong> un dato de tipo <a href="#1406">STRING</a>. Para unir varias cadenas de texto en una sola se debe utilizar la funci&#243;n <a href="#203">strcat()</a>.<br/><br/>
<hr/>
Ver: <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="203">strcat()</h2><br/><br/>
<strong>strcat(</strong>&lt;cadena destino&gt;<strong>,</strong> &lt;cadena origen&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Concatena (une) dos cadenas y retorna la direcci&#243;n de la cadena destino.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Une dos cadenas de texto, copiando la <strong>&lt;cadena origen&gt;</strong> a continuaci&#243;n del texto contenido en la <strong>&lt;cadena destino&gt;</strong>.<br/><br/>
La <strong>&lt;cadena destino&gt;</strong> debe ser un dato de tipo <a href="#1406">STRING</a>, de una longitud suficiente como para contener ambas cadenas.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strcat;

GLOBAL
    STRING cadena1=&quot;Inicio &quot;;

BEGIN
    write(0,0,0,0,&quot;Texto contenido en &lt;cadena1&gt;:&quot;);
    write(0,0,10,0,cadena1);
    write(0,0,192,0,&quot;Pulse [ESPACIO] para a&#241;adir un texto a &lt;cadena1&gt;&quot;);
    LOOP
        IF (key(_space))

            strcat(cadena1,&quot;Final&quot;); // Suma un texto a cadena1

        END
        FRAME;
   END
END
</pre>
<hr/>
<br/><br/>
Cuando la longitud de la cadena resultante de la suma de ambas sea menor de 1024 car&#225;cteres, se podr&#225; realizar esta misma operaci&#243;n con una sentencia como la siguiente (continuando con el ejemplo anterior):<br/><br/>
<strong>cadena1 = cadena1 + &quot;Final&quot;;</strong><br/><br/>
(o bien)<br/><br/>
<strong>cadena1 += &quot;Final&quot;;</strong><br/><br/>
Es decir, con una sentencia gen&#233;rica de <a href="#1019">asignaci&#243;n</a> (o con el s&#237;mbolo <a href="#1058">+=</a>, de asignaci&#243;n operativa) como la siguiente:<br/><br/>
<strong>&lt;cadena destino&gt; = &lt;cadena destino&gt; + &lt;cadena origen&gt; ;</strong><br/><br/>
(o bien)<br/><br/>
<strong>&lt;cadena destino&gt; += &lt;cadena origen&gt; ;</strong><br/><br/>
Siendo siempre <strong>&lt;cadena destino&gt;</strong> un dato de tipo <a href="#1406">STRING</a>.<br/><br/>
<hr/>
<br/><br/>
Para copiar cadenas de texto se debe utilizar la funci&#243;n <a href="#202">strcpy()</a>.<br/><br/>
Para separar (o restar) cadenas de texto, se debe utilizar la funci&#243;n <a href="#211">strdel()</a>.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="204">strlen()</h2><br/><br/>
<strong>strlen(</strong>&lt;cadena de texto&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La longitud de la cadena, en car&#225;cteres (contando los espacios).<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Cuenta el n&#250;mero de car&#225;cteres del texto pasado como par&#225;metro, o contenido actualmente en la cadena pasada.<br/><br/>
La <strong>&lt;cadena de texto&gt;</strong> puede ser un literal (texto entre comillas) o un dato de cualquier otro tipo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strlen;

GLOBAL
    STRING cadena1=&quot;Texto ejemplo&quot;;
    longitud_cadena1;

BEGIN
    write(0,0,0,0,&quot;Texto contenido en &lt;cadena1&gt;:&quot;);
    write(0,0,10,0,cadena1);
    write(0,0,20,0,&quot;Longitud de &lt;cadena1&gt;:&quot;);

    longitud_cadena1=strlen(cadena1); // Calcula la longitud

    write_int(0,0,30,0,OFFSET longitud_cadena1);
    LOOP
        FRAME;
    END
END
</pre>
<hr/>
<br/><br/>
Se puede a&#241;adir un car&#225;cter a una cadena con la funci&#243;n <a href="#203">strcat()</a>, o bien con una sentencia de <a href="#1019">asignaci&#243;n</a> como la siguiente:<br/><br/>
<strong>cadena1+=&quot;a&quot;;</strong><br/><br/>
Para quitar car&#225;cteres de una cadena se debe utilizar <a href="#211">strdel()</a>, aunque tambi&#233;n es posible eliminar car&#225;cteres del final de una cadena con sentencias como las siguientes:<br/><br/>
<strong>cadena1--;</strong><br/>
<strong>cadena1-=1;</strong><br/>
<strong>cadena1=cadena1-1;</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="205">strcmp()</h2><br/><br/>
<strong>strcmp(</strong>&lt;cadena1&gt;<strong>,</strong> &lt;cadena2&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong> +n</strong> - Si la primera cadena es mayor que la segunda.<br/>
<strong>  0</strong> - Si las dos cadenas son id&#233;nticas.<br/>
<strong> -n</strong> - Si la primera cadena es menor que la segunda.<br/>
<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Compara dos cadenas de texto, car&#225;cter a car&#225;cter, devolviendo <strong>0</strong> cuando ambas cadenas sean id&#233;nticas.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strcmp;

GLOBAL
    STRING micadena;

BEGIN
    // ...

    IF (strcmp(micadena,&quot;abc&quot;)==0)

        // Las dos cadenas son iguales ...

    END

    // ...
END
</pre>
<hr/>
<br/><br/>
La comparaci&#243;n de cadenas puede realizarse, siempre que las cadenas sean de menos de 1024 car&#225;cteres, con los operadores de comparaci&#243;n usuales del lenguaje.<br/><br/>
Por ejemplo, la comparaci&#243;n del ejemplo anterior podr&#237;a haberse expresado con la siguiente sentencia:<br/><br/>
<strong>IF (micadena==&quot;abc&quot;)</strong><br/>
<strong>//...</strong><br/>
<strong>END</strong><br/>
<br/><br/>
De igual forma, se puede comparar el s&#237;mbolo <a href="#1046">&lt;&gt;</a> si dos cadenas son diferentes, con los s&#237;mbolos <a href="#1069">&lt;</a> o <a href="#1072">&lt;=</a> si una cadena es menor, o menor o igual a otra, etc.<br/><br/>
<hr/>
<br/><br/>
Para buscar una cadena dentro de otra (ver si esta contenida en ella), se utiliza la funci&#243;n <a href="#207">strstr()</a>, y para ver si una cadena contiene alg&#250;n car&#225;cter se utiliza la funci&#243;n <a href="#206">strchr()</a>.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="206">strchr()</h2><br/><br/>
<strong>strchr(</strong>&lt;cadena de texto&gt;<strong>,</strong> &lt;car&#225;cteres&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong> -1</strong> Si no se encontraron los car&#225;cteres dentro de la cadena.<br/>
<strong> +n</strong> Si uno de los car&#225;cteres se encontr&#243; en la posici&#243;n <strong>n</strong> de la cadena.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Busca uno o varios <strong>&lt;car&#225;cteres&gt;</strong> en una <strong>&lt;cadena de texto&gt;</strong>. Se recibe la cadena como primer par&#225;metro y, como segundo, uno o varios car&#225;cteres en un literal (entre comillas).<br/><br/>
Esta funci&#243;n determinar&#225; si la cadena contiene alguno de dichos car&#225;cteres y, en caso afirmativo, indicar&#225; en que posici&#243;n aparece el car&#225;cter dentro de la cadena (de 0 en adelante). En caso de aparecer el car&#225;cter varias veces, la funci&#243;n siempre retornar&#225; la posici&#243;n primera.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strchr;

GLOBAL
    STRING micadena=&quot;FGHIJK&quot;;
    posici&#243;n;

BEGIN
    write(0,0,0,0,&quot;Primera vocal de &lt;micadena&gt; en la posici&#243;n:&quot;);

    posici&#243;n=strchr(micadena,&quot;AEIOU&quot;);

    write_int(0,0,10,0,OFFSET posici&#243;n);
    LOOP
        FRAME;
    END
END
</pre>
En este ejemplo se utiliza la funci&#243;n <strong>strchr()</strong> para que determine que la primera vocal de <strong>micadena</strong> se encuentra en la posici&#243;n <strong>3</strong> de dicha cadena.<br/><br/>
<hr/>
<br/><br/>
Siempre se puede acceder a los car&#225;cteres de un dato de tipo <a href="#1406">STRING</a> como si este fuera una tabla de car&#225;cteres. Por ejemplo, para sustituir en el dato <strong>micadena</strong> del ejemplo anterior, el car&#225;cter &quot;I&quot; por un car&#225;cter &quot;-&quot; se podr&#237;a utilizar la siguiente sentencia:<br/><br/>
<strong>micadena[3]=char(&quot;-&quot;);</strong><br/><br/>
Para convertir un car&#225;cter contenido en un literal en su valor ordinal (ASCII) se utiliza la funci&#243;n <a href="#184">char()</a>.<br/><br/>
<hr/>
<br/><br/>
Para determinar si una cadena esta completamente contenida en otra (si aparece como una subcadena dentro de la misma), se debe utilizar la funci&#243;n <a href="#207">strstr()</a>.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="207">strstr()</h2><br/><br/>
<strong>strstr(</strong>&lt;cadena de texto&gt;<strong>,</strong> &lt;subcadena&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong> -1</strong> Si no se encontrar&#243; la subcadena dentro de la cadena.<br/>
<strong> +n</strong> Si se encontr&#243; en la posici&#243;n <strong>n</strong> de la cadena de texto.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Busca la secuencia de car&#225;cteres contenida en la <strong>&lt;subcadena&gt;</strong> en una <strong>&lt;cadena de texto&gt;</strong>.<br/><br/>
Esta funci&#243;n determinar&#225; si la cadena contiene a la subcadena (como &quot;CASA&quot; contiene &quot;ASA&quot;) y, en caso afirmativo, indicar&#225; en que posici&#243;n aparece la subcadena dentro de la cadena (de 0 en adelante, 1 en el ejemplo anterior). En caso de aparecer la subcadena varias veces, la funci&#243;n siempre retornar&#225; la posici&#243;n primera.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strstr;

GLOBAL
    STRING micadena=&quot;Esta es una cadena de ejemplo.&quot;;
    posici&#243;n;

BEGIN

    posici&#243;n=strstr(micadena,&quot;es&quot;);

    write_int(0,0,10,0,OFFSET posici&#243;n);
    LOOP
        FRAME;
    END
END
</pre>
En este ejemplo se utiliza la funci&#243;n <strong>strstr()</strong> para que determine d&#243;nde se encuentra la subcadena <strong>&quot;es&quot;</strong> dentro de <strong>micadena</strong>. Retornar&#225; la posici&#243;n <strong>5</strong>, debido a que la funci&#243;n distingue entre may&#250;sculas y min&#250;sculas, por lo que no se reconoce la subcadena &quot;Es&quot; (de &quot;Esta&quot;) que se encuentra en la posici&#243;n <strong>0</strong> de la cadena.<br/><br/>
<hr/>
<br/><br/>
Para realizar conversiones entre may&#250;sculas y min&#250;sculas, se pueden utilizar las funciones <a href="#209">upper()</a> y <a href="#210">lower()</a>.<br/><br/>
<hr/>
<br/><br/>
Para determinar si una cadena contiene alg&#250;n car&#225;cter en concreto, se debe utilizar la funci&#243;n <a href="#206">strchr()</a> que, adem&#225;s, permite buscar de una sola vez cualquier car&#225;cter dentro de un conjunto especificado.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="208">strset()</h2><br/><br/>
<strong>strset(</strong>&lt;cadena de texto&gt;<strong>,</strong> &lt;car&#225;cter&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Asigna a todas las posiciones de la <strong>&lt;cadena&gt;</strong> el <strong>&lt;car&#225;cter&gt;</strong> indicado como segundo par&#225;metro.<br/><br/>
La funci&#243;n puede recibir el <strong>&lt;car&#225;cter&gt;</strong> de dos formas; como un literal (el car&#225;cter entre comillas), o bien como su ordinal (su valor ASCII) que debe ser un valor entre <strong>0</strong> y <strong>255</strong>.<br/><br/>
Se inicializar&#225; toda la cadena con ese mismo car&#225;cter. La longitud de la cadena depende del valor indicado entre corchetes en su inicializaci&#243;n, en caso de no indicarse la longitud del dato de tipo <a href="#1406">STRING</a>, se crear&#225; una cadena de <strong>256</strong> car&#225;cteres (desde la posici&#243;n 0 hasta 255).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strset;

GLOBAL
    STRING micadena=&quot;Esta es una cadena de ejemplo.&quot;;

BEGIN
    write(0,0,0,0,&quot;Contenido de &lt;micadena&gt; (pulse espacio para cambiarlo):&quot;);
    write(0,0,10,0,micadena);
    LOOP
        IF (key(_space))

            strset(micadena,&quot;*&quot;); // Rellena la cadena con asteriscos

        END
        FRAME;
    END
END
</pre>
<hr/>
<br/><br/>
Para calcular la longitud actual de una cadena se utiliza la funci&#243;n <a href="#204">strlen()</a>.<br/><br/>
Para borrar caracteres de una cadena (tanto del inicio como del final) se debe utilizar <a href="#211">strdel()</a>.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="209">upper()</h2><br/><br/>
<strong>upper(</strong>&lt;cadena o car&#225;cter&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Si se recibe un car&#225;cter correspondiente a una letra min&#250;scula, retorna dicho car&#225;cter convertido en may&#250;scula.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Convierte una cadena (o un simple car&#225;cter) a may&#250;sculas, incluyendo los car&#225;cteres especiales, como la letra &quot;&#241;&quot; o las vocales acentuadas.<br/><br/>
Esta funci&#243;n puede trabajar en dos modos, en funci&#243;n del par&#225;metro que reciba:<br/><br/>
- Si recibe una cadena de texto (o literal entre comillas), convertir&#225; a may&#250;sculas todos los car&#225;cteres contenidos en dicha cadena y no retornar&#225; ning&#250;n valor significativo (&#250;nicamente el propio puntero a la cadena recibida).<br/><br/>
- Si recibe un s&#243;lo car&#225;cter (su valor ordinal o ASCII), devolver&#225; el car&#225;cter convertido en may&#250;scula (nuevamente su valor ordinal), y la funci&#243;n no cambiar&#225; ning&#250;n dato en memoria.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_upper;

GLOBAL
    STRING micadena=&quot;Esta es una cadena de ejemplo.&quot;;
    BYTE   miletra=&quot;a&quot;;

BEGIN

    upper(micadena); // Convierte una cadena a may&#250;sculas
    upper(miletra);  // Convierte un car&#225;cter en may&#250;scula

    write(0,0,0,0,micadena);
    write(0,0,10,0,OFFSET miletra);
    LOOP
        FRAME;
    END
END
</pre>
Este ejemplo tiene definidos dos datos globales (<strong>micadena</strong> y <strong>miletra</strong>), se utilizar&#225; la funci&#243;n <strong>upper()</strong> para convertirlos a may&#250;sculas, y entonces se mostrar&#225;n en pantalla.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n no modificar&#225; aquellos car&#225;cteres que no sean letras min&#250;sculas.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#210">lower()</a> es la inversa a <strong>upper()</strong>, ya que puede convertir una cadena (o un car&#225;cter) a min&#250;sculas.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#210">lower()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="210">lower()</h2><br/><br/>
<strong>lower(</strong>&lt;cadena o car&#225;cter&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Si se recibe un car&#225;cter correspondiente a una letra may&#250;scula, retorna dicho car&#225;cter convertido en min&#250;scula.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Convierte una cadena (o un simple car&#225;cter) a min&#250;sculas, incluyendo los car&#225;cteres especiales, como la letra &quot;&#241;&quot; o las vocales acentuadas.<br/><br/>
Esta funci&#243;n puede trabajar en dos modos, en funci&#243;n del par&#225;metro que reciba:<br/><br/>
- Si recibe una cadena de texto (o literal entre comillas), convertir&#225; a min&#250;sculas todos los car&#225;cteres contenidos en dicha cadena y no retornar&#225; ning&#250;n valor significativo (&#250;nicamente el propio puntero a la cadena recibida).<br/><br/>
- Si recibe un s&#243;lo car&#225;cter (su valor ordinal o ASCII), devolver&#225; el car&#225;cter convertido en min&#250;scula (nuevamente su valor ordinal), y la funci&#243;n no cambiar&#225; ning&#250;n dato en memoria.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_lower;

GLOBAL
    STRING micadena=&quot;ESTA ES UNA CADENA DE EJEMPLO&quot;;
    BYTE   miletra=&quot;A&quot;;

BEGIN

    lower(micadena); // Convierte una cadena a min&#250;sculas
    lower(miletra);  // Convierte un car&#225;cter en min&#250;scula

    write(0,0,0,0,micadena);
    write(0,0,10,0,OFFSET miletra);
    LOOP
        FRAME;
    END
END
</pre>
Este ejemplo tiene definidos dos datos globales (<strong>micadena</strong> y <strong>miletra</strong>), se utilizar&#225; la funci&#243;n <strong>lower()</strong> para convertirlos a min&#250;sculas, y entonces se mostrar&#225;n en pantalla.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n no modificar&#225; aquellos car&#225;cteres que no sean letras may&#250;sculas.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#209">upper()</a> es la inversa a <strong>lower()</strong>, ya que puede convertir una cadena (o un car&#225;cter) a may&#250;sculas.<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#211">strdel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="211">strdel()</h2><br/><br/>
<strong>strdel(</strong>&lt;cadena de texto&gt;<strong>,</strong> &lt;resta inicio&gt;<strong>,</strong> &lt;resta final&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n borra car&#225;cteres de una <strong>&lt;cadena de texto&gt;</strong>. Se eliminar&#225;n <strong>&lt;resta inicio&gt;</strong> car&#225;cteres del inicio de la cadena y <strong>&lt;resta final&gt;</strong> car&#225;cteres del final de la misma.<br/><br/>
Para eliminar &#250;nicamente car&#225;cteres del inicio de la cadena se debe indicar <strong>0</strong> como <strong>&lt;resta final&gt;</strong>, y para eliminar s&#243;lo del final, <strong>0</strong> como <strong>&lt;resta inicio&gt;</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_strdel;

GLOBAL
    STRING micadena=&quot;Esta es una cadena de ejemplo.&quot;;

BEGIN

    strdel(micadena,5,9);

    write(0,0,0,0,micadena);
    LOOP
        FRAME;
    END
END
</pre>
Este ejemplo utiliza la funci&#243;n <strong>strdel()</strong> para eliminar los primeros <strong>5</strong> car&#225;cteres de <strong>&lt;micadena&gt;</strong> y los &#250;ltimos <strong>9</strong>, para luego mostrar la cadena resultante en pantalla (&quot;es una cadena de&quot;).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Si se indica una cantidad negativa de car&#225;cteres (bien sea para el inicio o para el final), la funci&#243;n a&#241;adir&#225; espacios a la cadena.<br/><br/>
<hr/>
<br/><br/>
Tambi&#233;n es posible eliminar car&#225;cteres del final de una cadena con sentencias como las siguientes:<br/><br/>
<strong>cadena1--;</strong><br/>
<strong>cadena1-=1;</strong><br/>
<strong>cadena1=cadena1-1;</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#202">strcpy()</a> - <a href="#203">strcat()</a> - <a href="#204">strlen()</a> - <a href="#205">strcmp()</a> - <a href="#206">strchr()</a> - <a href="#207">strstr()</a> - <a href="#208">strset()</a> - <a href="#209">upper()</a> - <a href="#210">lower()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="212">screen_copy()</h2><br/><br/>
<strong>screen_copy(</strong>&lt;regi&#243;n&gt;<strong>,</strong> &lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>,</strong> &lt;ancho&gt;<strong>,</strong> &lt;alto&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Copia una region de pantalla a una regi&#243;n de cualquier gr&#225;fico.<br/><br/>
Se trata de una potente funci&#243;n que puede resultar muy vers&#225;til, al proporcionar &quot;feedback&quot; de la pantalla del ordenador, es decir, que puede enviar una imagen de la pantalla a un gr&#225;fico (operaci&#243;n contraria a lo normal).<br/><br/>
Se debe primero definir el n&#250;mero de <strong>&lt;regi&#243;n&gt;</strong> rectangular que se va a copiar de la pantalla (de la imagen anterior del programa), estas regiones se definen con la funci&#243;n <a href="#106">define_region()</a>. La <strong>regi&#243;n n&#250;mero 0</strong> siempre se refiere a la pantalla completa.<br/><br/>
Despu&#233;s se deber&#225; indicar el gr&#225;fico al que se debe transferir la imagen, con los par&#225;metros <strong>&lt;fichero&gt;</strong> y <strong>&lt;gr&#225;fico&gt;</strong> (el fichero ser&#225; el n&#250;mero 0, si el gr&#225;fico pertenece al primer FPG cargado, o bien si se ha cargado de forma separada).<br/><br/>
Por &#250;ltimo se indicar&#225; <strong>la zona dentro del gr&#225;fico</strong> a la cual debe transferirse la imagen. Esta se definir&#225; como <strong>&lt;x&gt;</strong>, <strong>&lt;y&gt;</strong>, <strong>&lt;ancho&gt;</strong> y <strong>&lt;alto&gt;</strong>, referidos a las coordenadas dentro del gr&#225;fico (siendo las coordenadas [0,0] su esquina superior izquierda).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_screen_copy;

GLOBAL
    &#225;ngulo;
    &#225;ngulo2;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    graph=2;
    x=160;
    y=100;
    put(0,graph,x,y);
    LOOP

        // Copia la pantalla (regi&#243;n 0) al gr&#225;fico 2

        screen_copy(0,0,2,0,0,320,200);

        &#225;ngulo+=1000;
        &#225;ngulo2+=1971;
        angle=get_distx(&#225;ngulo,25000);
        size=95+get_disty(&#225;ngulo2,30);
        FRAME;
    END
END
</pre>
Este ejemplo carga el fichero de gr&#225;ficos, en el que el <strong>gr&#225;fico n&#250;mero 2</strong> es una cuadr&#237;cula de diferentes colores, para ponerlo en pantalla y definirlo como gr&#225;fico del proceso principal, que ir&#225; rot&#225;ndo y cambiando de tama&#241;o (en funci&#243;n de <strong>&#225;ngulo</strong> y <strong>&#225;ngulo2</strong>, respectivamente).<br/><br/>
Es entonces cuando se utiliza la funci&#243;n <strong>screen_copy()</strong> para reenviar la imagen de pantalla a este gr&#225;fico, con lo que se produce dicho efecto.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El <strong>tama&#241;o</strong> de la regi&#243;n de pantalla (la zona transferida) y el de la regi&#243;n del gr&#225;fico (donde se transfiere) <strong>no tiene que coincidir</strong>. La funci&#243;n <strong>screen_copy()</strong> realizar&#225; una <strong>reducci&#243;n</strong> o <strong>ampliaci&#243;n</strong> cuando sea necesario, para ajustar el tama&#241;o de la zona transferida.<br/><br/>
<hr/>
Ver: <a href="#106">define_region()</a> - <a href="#103">clear_screen()</a> - <a href="#1126">graph</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="213">qsort()</h2><br/><br/>
<strong>qsort(</strong>&lt;nombre estructura&gt;<strong>,</strong> &lt;nombre campo&gt;<strong>,</strong> &lt;modo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Ordena o desordena una estructura del programa por uno de sus campos.<br/><br/>
Se trata de una simple pero vers&#225;til funci&#243;n que posibilita la r&#225;pida ordenaci&#243;n y desordenaci&#243;n de estructuras de datos.<br/><br/>
Su uso es muy simple, se requiere &#250;nicamente el <strong>&lt;nombre de la estructura&gt;</strong>, el del <strong>&lt;campo que se va a utilizar como &#237;ndice&gt;</strong>, y el <strong>&lt;modo de ordenaci&#243;n&gt;</strong>; uno de los indicados a continuaci&#243;n:<br/><br/>
<strong>0</strong> - Ordenaci&#243;n ascendente (de menor a mayor).<br/><br/>
<strong>1</strong> - Ordenaci&#243;n descendente (de mayor a menor).<br/><br/>
<strong>2</strong> - Desordenaci&#243;n aleatoria.<br/><br/>
Se puede utilizar como campo &#237;ndice cualquiera de los datos contenidos en la estructura, bien se trate de un dato num&#233;rico, o de una cadena de texto (en cuyo caso se ordenar&#225; alfab&#233;ticamente).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_qsort;

GLOBAL

  STRUCT miestructura[9];
    STRING nombre[32];
    puntos;
    x,y;
  END

BEGIN

  //...

  // Ordena los registros de miestructura, de forma que se sit&#250;en los de
  // mayor puntuaci&#243;n al principio

  qsort(miestructura,puntos,1);

  //...

END
</pre>
Este ejemplo muestra la f&#225;cil utilizaci&#243;n de la funci&#243;n <strong>qsort()</strong> para ordenar una estructura, que puede representar cualquier tipo de objeto dentro de un programa.<br/><br/>
No es necesario que el campo utilizado como &#237;ndice (<strong>puntos</strong> en este caso) sea el primero de la estructura.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La desordenaci&#243;n de una estructura requiere igualmente un campo que diferencie a los distintos registros de la misma. Esta operaci&#243;n puede ser &#250;til para dotar de &quot;aleatoriedad&quot; a un programa (por ejemplo, para &quot;barajar&quot; un conjunto de cartas).<br/><br/>
<hr/>
<br/><br/>
<h2 id="214">load_song()</h2><br/><br/>
<strong>load_song(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;repetici&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Identificador de la canci&#243;n cargada, o -1 si se produce un error.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga una canci&#243;n de un archivo MOD, S3M o XM, para su posterior reproducci&#243;n.<br/><br/>
La funci&#243;n requiere el nombre del archivo que contiene el m&#243;dulo musical, y si este debe reproducirse una s&#243;la vez (indicando <strong>0</strong> en <strong>&lt;repetici&#243;n&gt;</strong>) o indefinidamente (indicando <strong>1</strong>).<br/><br/>
Estos m&#243;dulos musicales se pueden componer con m&#250;ltiples programas shareware o de libre uso. En DIV Games Studio se pueden reproducir, tanto en el entorno como en los programas creados, pero no se pueden crear nuevos m&#243;dulos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_song;

GLOBAL
    id_canci&#243;n;

BEGIN

    load_song(&quot;help\help.xm&quot;,1); // Carga un m&#243;dulo XM, con repetici&#243;n

    song(id_canci&#243;n);
    write(0,0,0,0,&quot;Pulse ESC para terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_ESC));
    unload_song(id_canci&#243;n);
END
</pre>
Este ejemplo carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> con la funci&#243;n <strong>load_song()</strong>, indicando que este debe reproducirse indefinidamente. La reproducci&#243;n del archivo se inicia con una llamada a la funci&#243;n <a href="#216">song()</a>.<br/><br/>
Para descargar una canci&#243;n de memoria se debe utilizar la funci&#243;n <a href="#215">unload_song()</a>, si bien todos los programas creados en DIV Games Studio liberar&#225;n toda la memoria ocupada de forma autom&#225;tica al finalizar.<br/><br/>
El volumen de reproducci&#243;n puede controlarse mediante la funci&#243;n <a href="#178">set_volume()</a> y los datos contenidos en la <a href="#1104">estructura setup</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Con esta versi&#243;n de DIV Games Studio se incluyen varios archivos con m&#243;dulos musicales de libre utilizaci&#243;n, en el directorio <strong>MOD</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para reproducir canciones contenidas en una pista de CD-Audio se deben utilzar las funciones <a href="#144">play_cd()</a> y <a href="#164">stop_cd()</a>.<br/><br/>
<hr/>
Ver: <a href="#215">unload_song()</a> - <a href="#216">song()</a> - <a href="#144">play_cd()</a> - <a href="#1104">Estructura setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="215">unload_song()</h2><br/><br/>
<strong>unload_song(</strong>&lt;identificador del m&#243;dulo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Descarga de memoria el m&#243;dulo musical cuyo identificador se pasa como par&#225;metro. Este <strong>&lt;identificador del m&#243;dulo&gt;</strong> es el valor que retorna la funci&#243;n <a href="#214">load_song()</a> al cargarlo en memoria.<br/><br/>
Tras descargarse un m&#243;dulo <strong>se deben extremar las precauciones</strong> para no continuar utiliz&#225;ndolo en el programa, en cuyo caso el programa correr&#237;a el riesgo de bloquearse.<br/><br/>
<strong>No es necesario descargar los m&#243;dulos</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica. Luego, solamente deben descargarse de memoria cuando ya no se vayan a utilizar durante un tiempo determinado y se quiera liberar el espacio ocupado en la memoria del ordenador para cargar otros recursos (otros ficheros de gr&#225;ficos, sonidos, fuentes, etc.).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_unload_song;

GLOBAL
    id_canci&#243;n;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);
    song(id_canci&#243;n);
    write(0,0,0,0,&quot;Pulse ESC para terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_ESC));

    unload_song(id_canci&#243;n); // Libera la memoria ocupada por el m&#243;dulo

END
</pre>
Este ejemplo carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> con la funci&#243;n <a href="#214">load_song()</a>. La reproducci&#243;n del archivo se inicia con una llamada a la funci&#243;n <a href="#216">song()</a>.<br/><br/>
El programa permanecer&#225; reproduciendo este m&#243;dulo hasta que se pulse la tecla <strong>ESC</strong>, momento en el que se finalizar&#225; el bucle principal y se descargar&#225; el m&#243;dulo de memoria con la funci&#243;n <strong>unload_song()</strong>, indicando como par&#225;metro <strong>id_canci&#243;n</strong> que es contiene el <strong>identificador del m&#243;dulo</strong> devuelto al cargarlo.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las m&#250;sicas contenidas en pistas de CD-Audio, cuya reproducci&#243;n se inicia con la funci&#243;n <a href="#144">play_cd()</a>, no ocupan memoria en el ordenador, por lo que no pueden descargarse con la funci&#243;n <strong>unload_song()</strong>.<br/><br/>
<hr/>
Ver: <a href="#214">load_song()</a> - <a href="#216">song()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="216">song()</h2><br/><br/>
<strong>song(</strong>&lt;indentificador del m&#243;dulo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Inicia la reproducci&#243;n de un m&#243;dulo musical cargado previamente con la funci&#243;n <a href="#214">load_song()</a>. La funci&#243;n debe recibir como &#250;nico par&#225;metro el <strong>&lt;identificador del m&#243;dulo&gt;</strong> a reproducir.<br/><br/>
Tan s&#243;lo puede reproducirse un m&#243;dulo a la vez, si se inicia la reproducci&#243;n de un m&#243;dulo cuando otro est&#233; sonando, se detendr&#225; el anterior. No obstante se pueden reproducir simult&#225;neamente un m&#243;dulo musical, una pista de CD-Audio (ver <a href="#144">play_cd()</a>) y m&#250;ltiples efectos de sonido (ver <a href="#159">sound()</a>).<br/><br/>
La reproducci&#243;n siempre se realizar&#225; a partir del inicio del m&#243;dulo (el comienzo de la canci&#243;n). Para reproducir cualquier parte de un m&#243;dulo se debe llamar a la funci&#243;n <a href="#218">set_song_pos()</a>, que fija la posici&#243;n a partir de la cual debe reproducirse un m&#243;dulo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_song;

GLOBAL
    id_canci&#243;n;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);

    song(id_canci&#243;n); // Inicia la reproducci&#243;n del m&#243;dulo musical

    write(0,0,0,0,&quot;Pulse ESC para terminar&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_ESC));
    unload_song(id_canci&#243;n);
END
</pre>
Este ejemplo carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> con la funci&#243;n <a href="#214">load_song()</a>, indicando que este debe reproducirse indefinidamente (esto se indica en la misma carga del archivo).<br/><br/>
Entonces se inicia la reproducci&#243;n del archivo con la funci&#243;n <strong>song()</strong>.<br/><br/>
El programa entrar&#225; entonces en un bucle en el que continuar&#225; sonando este m&#243;dulo, hasta que una pulsaci&#243;n de la tecla <strong>ESC</strong> desemboque en la finalizaci&#243;n del programa.<br/><br/>
El volumen de reproducci&#243;n puede controlarse mediante la funci&#243;n <a href="#178">set_volume()</a> y los datos contenidos en la <a href="#1104">estructura setup</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para finalizar la reproducci&#243;n de un m&#243;dulo musical se debe emplear la funci&#243;n <a href="#217">stop_song()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede averiguar si un m&#243;dulo est&#225; reproduci&#233;ndose llamando a la funci&#243;n <a href="#222">is_playing_song()</a>.<br/><br/>
<hr/>
Ver: <a href="#214">load_song()</a> - <a href="#217">stop_song()</a> - <a href="#144">play_cd()</a> - <a href="#159">sound()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="217">stop_song()</h2><br/><br/>
<strong>stop_song(</strong><strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Detiene la reproducci&#243;n del m&#243;dulo musical (MOD, S3M o XM) que este sonando.<br/><br/>
Esta funci&#243;n no requiere ning&#250;n par&#225;metro, ya que &#250;nicamente puede reproducirse &#250;n m&#243;dulo musical a la vez.<br/><br/>
No es imprescindible detener la reproducci&#243;n de un m&#243;dulo musical antes de descargarlo de memoria (operaci&#243;n realizada con la funci&#243;n <a href="#215">unload_song()</a>), esta acci&#243;n se realiza de forma autom&#225;tica.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_stop_song;

GLOBAL
    id_canci&#243;n;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);
    song(id_canci&#243;n);
    write(0,0,0,0,&quot;Pulse SPACE para detener la canci&#243;n ...&quot;);
    LOOP
        IF (key(_space))

            stop_song(); // Detiene el m&#243;dulo

        END
        FRAME;
    END
    unload_song(id_canci&#243;n);
END
</pre>
Este ejemplo carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> con la funci&#243;n <a href="#214">load_song()</a>. La reproducci&#243;n del archivo se inicia con una llamada a la funci&#243;n <a href="#216">song()</a>.<br/><br/>
El programa entra entonces en un bucle en el que continuar&#225; la reproducci&#243;n de dicho m&#243;dulo, hasta que una pulsaci&#243;n de la tecla barra espaciadora provoque una llamada a <strong>stop_song()</strong> y se detenga el m&#243;dulo.<br/><br/>
Para descargar una canci&#243;n de memoria se debe utilizar la funci&#243;n <a href="#215">unload_song()</a>, si bien todos los programas creados en DIV Games Studio liberar&#225;n toda la memoria ocupada de forma autom&#225;tica al finalizar.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para detener una canci&#243;n de CD-Audio se utiliza la funci&#243;n <a href="#164">stop_cd()</a>, y hacerlo con un efecto de sonido, la funci&#243;n <a href="#167">stop_sound()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede averiguar si un m&#243;dulo est&#225; reproduci&#233;ndose llamando a la funci&#243;n <a href="#222">is_playing_song()</a>.<br/><br/>
<hr/>
Ver: <a href="#216">song()</a> - <a href="#214">load_song()</a> - <a href="#144">play_cd()</a> - <a href="#159">sound()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="218">set_song_pos()</h2><br/><br/>
<strong>set_song_pos(</strong>&lt;posici&#243;n del m&#243;dulo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Fija la posici&#243;n de reproducci&#243;n del m&#243;dulo musical (el n&#250;mero de &quot;pattern&quot;).<br/><br/>
Esta <strong>&lt;posici&#243;n del m&#243;dulo&gt;</strong> es un n&#250;mero entre 0 y el n&#250;mero m&#225;ximo de <strong>pattern</strong> (patrones) del m&#243;dulo. Este valor varia para cada m&#243;dulo, y se define en los programas utilizados para componerlos. Los m&#243;dulos suelen tener un n&#250;mero muy variable de patrones, aunque la media puede situarse entre 30 y 40.<br/><br/>
Dentro de cada patr&#243;n los m&#243;dulos tienen un determinado n&#250;mero de l&#237;neas (normalmente 64), en las cuales aparecen las notas musicales, por lo que se podr&#237;a definir cada patr&#243;n como una peque&#241;a secci&#243;n del m&#243;dulo musical.<br/><br/>
Para obtener la posici&#243;n actual de un m&#243;dulo que se est&#225; reproduciendo se utiliza la funci&#243;n <a href="#219">get_song_pos()</a>.<br/><br/>
Se puede variar la posici&#243;n del m&#243;dulo tanto si este est&#225; parado, como si se est&#225; reproduciendo. Esta funci&#243;n puede utilizarse para avanzar o retroceder en la reproducci&#243;n del m&#243;dulo, para implementar diversos bucles repetitivos de ciertas partes de un m&#243;dulo, etc.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_set_song_pos;

GLOBAL
    id_canci&#243;n;
    posici&#243;n_m&#243;dulo;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);
    song(id_canci&#243;n);
    write(0,0,0,0,&quot;Pulse SPACE cambiar la posici&#243;n del m&#243;dulo ...&quot;);
    write(0,0,20,0,&quot;Posici&#243;n:&quot;);
    write_int(0,0,30,0,OFFSET posici&#243;n_m&#243;dulo);
    LOOP
        IF (key(_space))
            posici&#243;n_m&#243;dulo=rand(0,19);

            set_song_pos(posici&#243;n_m&#243;dulo); // Cambia la posici&#243;n del m&#243;dulo

        END
        posici&#243;n_m&#243;dulo=get_song_pos();
        FRAME;
    END
END
</pre>
Este programa carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> y entonces inicia su reproducci&#243;n con la funci&#243;n <a href="#216">song()</a>.<br/><br/>
A partir de este momento se mostrar&#225; la posici&#243;n actual de m&#243;dulo en pantalla, y se podr&#225; cambiar la misma pulsando la barra espaciadora (se asignar&#225; una posici&#243;n al azar, entre 0 y 19, ya que este m&#243;dulo tiene 20 patrones).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> No se puede fijar la l&#237;nea de reproducci&#243;n de un m&#243;dulo (dentro de cada patr&#243;n), pero si que se puede obtener este valor con la funci&#243;n <a href="#220">get_song_line()</a>.<br/><br/>
<hr/>
Ver: <a href="#219">get_song_pos()</a> - <a href="#216">song()</a> - <a href="#214">load_song()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="219">get_song_pos()</h2><br/><br/>
<strong>get_song_pos(</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La posici&#243;n actual del m&#243;dulo musical que se est&#233; reproduciendo.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Devuelve la posici&#243;n actual de reproducci&#243;n del m&#243;dulo musical, esta posici&#243;n puede fijarse con la funci&#243;n <a href="#218">set_song_pos()</a>.<br/><br/>
Esta <strong>&lt;posici&#243;n del m&#243;dulo&gt;</strong> es un n&#250;mero entre 0 y el n&#250;mero m&#225;ximo de <strong>pattern</strong> (patrones) del m&#243;dulo. Este valor varia para cada m&#243;dulo, y se define en los programas utilizados para componerlos. Los m&#243;dulos suelen tener un n&#250;mero muy variable de patrones, aunque la media puede situarse entre 30 y 40.<br/><br/>
Dentro de cada patr&#243;n los m&#243;dulos tienen un determinado n&#250;mero de l&#237;neas (normalmente 64), en las cuales aparecen las notas musicales, por lo que se podr&#237;a definir cada patr&#243;n como una peque&#241;a secci&#243;n del m&#243;dulo musical.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_song_pos;

GLOBAL
    id_canci&#243;n;
    posici&#243;n_m&#243;dulo;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);
    song(id_canci&#243;n);
    write(0,0,0,0,&quot;Posici&#243;n del m&#243;dulo:&quot;);
    write_int(0,0,10,0,OFFSET posici&#243;n_m&#243;dulo);
    LOOP

        posici&#243;n_m&#243;dulo=get_song_pos(); // Obtiene la posici&#243;n

        FRAME;
    END
END
</pre>
Este programa carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> y entonces inicia su reproducci&#243;n con la funci&#243;n <a href="#216">song()</a>.<br/><br/>
A partir de este momento se mostrar&#225; la posici&#243;n actual del m&#243;dulo en pantalla, obtenida mediante la funci&#243;n <strong>get_song_pos()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede obtener el n&#250;mero de l&#237;nea que se est&#225; reproduciendo, dentro del patr&#243;n, con la funci&#243;n <a href="#220">get_song_line()</a>.<br/><br/>
<hr/>
Ver: <a href="#220">get_song_line()</a> - <a href="#218">set_song_pos()</a> - <a href="#216">song()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="220">get_song_line()</h2><br/><br/>
<strong>get_song_line(</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El n&#250;mero de l&#237;nea del m&#243;dulo musical.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Con esta funci&#243;n se puede obtener el n&#250;mero de l&#237;nea del m&#243;dulo musical que se est&#225; reproduciendo (dentro de la posici&#243;n, o patr&#243;n actual).<br/><br/>
Esta posici&#243;n actual, o patr&#243;n (pattern), puede obtenerse con la funci&#243;n <a href="#219">get_song_pos()</a>.<br/><br/>
Dentro de cada patr&#243;n los m&#243;dulos tienen un determinado n&#250;mero de l&#237;neas (normalmente 64), en las cuales aparecen las notas musicales. Los m&#243;dulos suelen tener un n&#250;mero muy variable de patrones, aunque la media puede situarse entre 30 y 40.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_song_line;

GLOBAL
    id_canci&#243;n;
    l&#237;nea_m&#243;dulo;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);
    song(id_canci&#243;n);
    write(0,0,0,0,&quot;L&#237;nea del m&#243;dulo:&quot;);
    write_int(0,0,10,0,OFFSET l&#237;nea_m&#243;dulo);
    LOOP

        l&#237;nea_m&#243;dulo=get_song_line(); // Obtiene el n&#250;mero de l&#237;nea

        FRAME;
    END
END
</pre>
Este programa carga el m&#243;dulo contenido en el archivo <strong>help.xm</strong> y entonces inicia su reproducci&#243;n con la funci&#243;n <a href="#216">song()</a>.<br/><br/>
A partir de este momento se mostrar&#225; la l&#237;nea actual del m&#243;dulo en pantalla, obtenida mediante la funci&#243;n <strong>get_song_line()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> No se puede fijar la l&#237;nea del m&#243;dulo musical, aunque si se puede fijar la posici&#243;n a partir de la que debe reproducirse con la funci&#243;n <a href="#218">set_song_pos()</a> (siempre se comenzar&#225; en la l&#237;nea 0 del patr&#243;n).<br/><br/>
<hr/>
Ver: #219,get_song_pos()} - <a href="#218">set_song_pos()</a> - <a href="#216">song()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="221">is_playing_sound()</h2><br/><br/>
<strong>is_playing_sound(</strong>&lt;n&#250;mero de canal&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>0</strong> - Si el canal est&#225; parado.<br/>
<strong>1</strong> - Si est&#225; sonando un sonido por el canal.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite saber si uno de los <strong>canales de sonido</strong> esta reproduciendo sonido, o si est&#225; disponible.<br/><br/>
Se requiere como par&#225;metro el <strong>&lt;n&#250;mero de canal&gt;</strong>, este valor se obtiene como retorno de la funci&#243;n <a href="#159">sound()</a> al iniciarse la reproducci&#243;n de un efecto de sonido.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_is_playing_sound;

GLOBAL
    sonido;
    canal;

BEGIN
    write(0,0,0,0,&quot;Pulse ESC para finalizar.&quot;);
    sonido = load_pcm(&quot;help\help.pcm&quot;,0);
    canal  = sound(sonido, 256, rand(100,400));
    REPEAT

        // Si finaliz&#243; la reproducci&#243;n, vuelve a lanzar el sonido

        IF (NOT is_playing_sound(canal))

            canal = sound(sonido, 256, rand(100,400));
        END
        FRAME;
    UNTIL (key(_ESC));
END
</pre>
Este ejemplo utiliza una funci&#243;n para tocar un sonido continuamente, de forma controlada por el programa, en lugar de autom&#225;ticamente (lo que se suele hacer indicando en la carga del sonido que &#233;ste es c&#237;clico, en las funciones <a href="#134">load_pcm()</a> o <a href="#134">load_wav()</a>).<br/><br/>
Se inicia la reproducci&#243;n de nuevo siempre que el canal del sonido haya quedado libre, es decir, cada vez que acabe de reproducirse el efecto.<br/><br/>
El programa aprovecha esta circunstancia (controlar manualmente la repetici&#243;n) para emitir el sonido a una frecuencia diferente en cada ocasi&#243;n, lo que no podr&#237;a hacerse con una repetici&#243;n autom&#225;tica. Esta frecuencia se obtiene como un valor al azar entre 100 y 400 con la funci&#243;n <a href="#149">rand()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Un mismo sonido puede reproducirse por diferentes canales cada vez, por ello es necesario guardar el n&#250;mero de canal cada vez que se inicia la reproducci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#159">sound()</a> - <a href="#102">change_sound()</a> - <a href="#222">is_playing_song()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="222">is_playing_song()</h2><br/><br/>
<strong>is_playing_song(</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>0</strong> - No est&#225; sonando ning&#250;n m&#243;dulo.<br/>
<strong>1</strong> - Si est&#225; sonando un m&#243;dulo musical.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar si se est&#225; reproduciendo un m&#243;dulo de m&#250;sica digital de un archivo MOD, S3M o XM.<br/><br/>
Estos m&#243;dulos se deben cargar con la funci&#243;n <a href="#214">load_song()</a> y su reproducci&#243;n se inicia con una llamada a <a href="#216">song()</a>.<br/><br/>
Unicamente puede reproducirse un m&#243;dulo a la vez, por lo que esta funci&#243;n no requiere ning&#250;n par&#225;metro, simplemente devuelve <strong>1</strong> si hay alg&#250;n m&#243;dulo reproduci&#233;ndose.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_is_playing_song;

GLOBAL
    id_canci&#243;n;
    sonando;

BEGIN
    load_song(&quot;help\help.xm&quot;,1);
    song(id_canci&#243;n);
    write(0,0,0,0,&quot;ENTER iniciar el m&#243;dulo / SPACE para detenerlo&quot;);
    write_int(0,0,10,0,OFFSET sonando);
    LOOP
        IF (key(_enter)) song(id_canci&#243;n); END
        IF (key(_space)) stop_song(); END

        sonando = is_playing_song(); // Determina si est&#225; sonando

        FRAME;
    END
END
</pre>
Este ejemplo carga el m&#243;dulo musical contenido en el archivo <strong>help.xm</strong> y permite, dentro de un bucle, iniciarlo con la tecla <strong>ENTER</strong> y detenerlo con la barra espaciadora.<br/><br/>
Dentro de este mismo bucle se utiliza la funci&#243;n <strong>is_playing_song()</strong> para determinar si este est&#225; sonando en cada momento.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para finalizar la reproducci&#243;n de un m&#243;dulo musical se debe emplear la funci&#243;n <a href="#217">stop_song()</a>.<br/><br/>
<hr/>
Ver: <a href="#214">load_song()</a> - <a href="#216">song()</a> - <a href="#221">is_playing_sound()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="223">fopen()</h2><br/><br/>
<strong>fopen(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;modo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>handle</strong> o identificador de archivo abierto, o bien <strong>0</strong> si se produjo un error.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Abre un archivo del disco para lectura o escritura, utilizando el sistema de acceso a trav&#233;s de un <strong>handle</strong> o <strong>identificador de archivo</strong> que esta funci&#243;n retorna del archivo abierto o creado.<br/><br/>
Se requiere el <strong>&lt;nombre del archivo&gt;</strong> a abrir o crear, y el <strong>&lt;modo&gt;</strong> de apertura, que debe ser un literal (texto entre comillas) dentro de los siguientes:<br/><br/>
&quot;<strong>r</strong>&quot; - Abre el archivo para lectura de los datos contenidos en el mismo.<br/><br/>
&quot;<strong>w</strong>&quot; - Crea el archivo para escritura (si existe, se perder&#225; su contenido anterior).<br/><br/>
&quot;<strong>a</strong>&quot; - Abre el archivo para escribir al final del mismo, o lo crea en caso de no existir a&#250;n.<br/><br/>
&quot;<strong>r+</strong>&quot; - Abre un archivo existente para actualizarlo, permitiendo tanto lectura como escritura.<br/><br/>
&quot;<strong>w+</strong>&quot; - Crea un fichero (o trunca el existente) para escritura, permitiendo tambi&#233;n lectura del mismo.<br/><br/>
&quot;<strong>a+</strong>&quot; - Abre un archivo para leer del mismo en cualquier posici&#243;n y escribir al final del mismo.<br/><br/>
Una vez abierto un archivo, pueden utilizarse todas las funciones de archivos basadas en <strong>handles</strong>, pero una vez se hayan realizado las operaciones necesarias en el fichero <strong>se debe cerrar</strong>, utilizando para ello la funci&#243;n <a href="#224">fclose()</a>.<br/><br/>
Las funciones principales son <a href="#225">fread()</a> para la lectura de datos dentro del archivo y <a href="#226">fwrite()</a> para escritura de datos; es importante haber abierto el archivo en un <strong>modo</strong> apropiado para las operaciones realizadas. Es decir, que por ejemplo no se podr&#225; escribir en el fichero si se ha abierto exclusivamente para lectura.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fopen;

GLOBAL
    tabla1[3]=11,22,33,44;
    tabla2[3];
    mihandle;

BEGIN

    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;); // Abre archivo para escritura

    fwrite(OFFSET tabla1,4,mihandle);
    fclose(mihandle);

    mihandle=fopen(&quot;help\help.dat&quot;,&quot;r&quot;); // Abre archivo para lectura

    fread(OFFSET tabla2,4,mihandle);
    fclose(mihandle);
END
</pre>
Este programa ejemplo tiene definidas dos tablas globales; <strong>tabla1</strong> con cuatro valores inicializados a 11, 22, 33 y 44, y <strong>tabla2</strong> con cuatro sin incializar (a cero).<br/><br/>
Se utilizan las funciones de archivos para escribir en un archivo el contenido de la <strong>tabla1</strong> y despu&#233;s cargarlo sobre la <strong>tabla2</strong>. Al finalizar el programa, se habr&#225;n copiado los datos de la primera tabla en la segunda.<br/><br/>
Se llama a la funci&#243;n <strong>fopen()</strong> en dos ocasiones, la primera para <strong>crearlo y escribir</strong> en &#233;l, y la segunda para <strong>abrirlo y leer</strong> su contenido.<br/><br/>
Es importante resaltar que cada vez que se abra o cree un archivo, se tiene que cerrar despu&#233;s con la funci&#243;n <a href="#224">fclose()</a> (se puede ver como, en el ejemplo, se cierra el archivo en dos ocasiones).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#227">fseek()</a> permite situar el <strong>puntero de lectura/escritura</strong> en cualquier posici&#243;n del archivo. De esta forma, se pueden leer o escribir datos de cualquier punto del archivo.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#230">flush()</a> vac&#237;a los buffers de escritura y permite adem&#225;s averiguar cuantos archivos hay abiertos en cada momento.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las funciones <a href="#155">save()</a> y <a href="#130">load()</a> permiten igualmente salvar datos en archivos del disco y recuperarlos. Estas funciones son mas simples y con menos funcionalidad, pero su uso es mucho m&#225;s sencillo que las funciones basadas en <strong>handles</strong> aqu&#237; descritas.<br/><br/>
<hr/>
Ver: <a href="#224">fclose()</a> <a href="#225">fread()</a> - <a href="#226">fwrite()</a> - <a href="#155">save()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="224">fclose()</h2><br/><br/>
<strong>fclose(</strong>&lt;handle&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
N&#250;mero de archivos que se han cerrado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Cierra un archivo abierto con la funci&#243;n <a href="#223">fopen()</a>, para ello debe recibir como par&#225;metro el <strong>handle</strong> o <strong>identificador de archivo</strong> devuelto por dicha funci&#243;n.<br/><br/>
En una segunda modalidad, la funci&#243;n <strong>fclose()</strong> puede <strong>cerrar todos los archivos abiertos</strong> de una vez, para ello se debe indicar simplemente <strong>0</strong> (cero) como par&#225;metro, en lugar de un <strong>handle</strong>.<br/><br/>
En cualquier caso, la funci&#243;n retornar&#225; el n&#250;mero de archivos que se han cerrado, si se devuelve <strong>0</strong> puede deberse a uno de estos casos:<br/><br/>
<strong> -</strong> No hab&#237;a ning&#250;n archivo abierto.<br/>
<strong> -</strong> El <strong>handle</strong> pasado no se corresponde con ning&#250;n archivo abierto. <strong> -</strong> El archivo correspondiente a dicho <strong>handle</strong> ya habia sido cerrado.<br/><br/>
Todos los archivos abiertos deben cerrarse antes de que el programa finalice su ejecuci&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fclose;

GLOBAL
    tabla1[3]=11,22,33,44;
    tabla2[3];
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);
    fwrite(OFFSET tabla1,4,mihandle);

    fclose(mihandle); // Se cierra el archivo para abrirlo en otro modo

    mihandle=fopen(&quot;help\help.dat&quot;,&quot;r&quot;);
    fread(OFFSET tabla2,4,mihandle);

    fclose(mihandle); // Se cierra el archivo definitivamente
END
</pre>
Se utilizan las funciones de archivos para escribir en un archivo el contenido de la <strong>tabla1</strong> y despu&#233;s cargarlo sobre la <strong>tabla2</strong>. Al finalizar el programa, se habr&#225;n copiado los datos de la primera tabla en la segunda.<br/><br/>
Si un archivo abierto en un modo (con la funci&#243;n <a href="#223">fopen()</a>) quiere accederse en otro modo diferente, se debe primero cerrar para entonces volver a abrirlo en el nuevo modo; como sucede en el ejemplo, se cierra el archivo de escritura para abrirlo entonces en modo lectura.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#230">flush()</a> vac&#237;a los buffers de escritura y permite adem&#225;s averiguar cuantos archivos hay abiertos en cada momento.<br/><br/>
<hr/>
Ver: <a href="#223">fopen()</a> <a href="#225">fread()</a> - <a href="#226">fwrite()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="225">fread()</h2><br/><br/>
<strong>fread(</strong>&lt;OFFSET datos&gt;<strong>,</strong> &lt;longitud&gt;<strong>,</strong> &lt;handle&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>0</strong> - Se produjo un error, o no se leyeron todos los datos pedidos.<br/>
<strong>1</strong> - Si se pudieron leer todos los datos.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite leer datos de un archivo abierto con la funci&#243;n <a href="#223">fopen()</a>, a partir de la posici&#243;n indicada por el <strong>puntero de lectura/escritura</strong>.<br/><br/>
El archivo se debe haber abierto en un <strong>modo de lectura</strong>, o que la permita.<br/><br/>
El <strong>puntero</strong> se situa inicialmente al comienzo del archivo, al abrirse el mismo, y avanza secuencialmente seg&#250;n se vayan leyendo datos. No obst&#225;nte puede situarse este puntero del archivo en cualquier posici&#243;n, utilizando la funci&#243;n <a href="#227">fseek()</a> y la funci&#243;n <a href="#228">ftell()</a> permite obtener la posici&#243;n actual del puntero de un archivo.<br/><br/>
La funci&#243;n <strong>fread()</strong> requiere como primer par&#225;metro el <strong>&lt;</strong><a href="#1085">OFFSET</a> <strong>de los datos&gt;</strong> en los que deben leerse los datos del archivo, es decir, la direcci&#243;n de memoria a partir de la cual se deben colocar los datos que se vayan leyendo del archivo.<br/><br/>
Como segundo par&#225;metro se requiere la <strong>&lt;longitud&gt;</strong> o tama&#241;o total de los datos que se quieren leer, es decir, el n&#250;mero de posiciones de memoria que ocupan dichos datos. La longitud de un dato se puede obtener con la funci&#243;n <a href="#1094">sizeof()</a>.<br/><br/>
El &#250;ltimo par&#225;metro debe ser el <strong>handle</strong> o <strong>identificador de archivo</strong> que se obtuvo al abrir el archivo como valor de retorno de <a href="#223">fopen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fread;

GLOBAL
    tabla1[3]=11,22,33,44;
    tabla2[3];
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);
    fwrite(OFFSET tabla1,4,mihandle);
    fclose(mihandle);
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;r&quot;);

    fread(OFFSET tabla2,4,mihandle); // Lee el archivo sobre &lt;tabla2&gt;

    fclose(mihandle);
END
</pre>
Este programa ejemplo tiene definidas dos tablas globales; <strong>tabla1</strong> con cuatro valores inicializados a 11, 22, 33 y 44, y <strong>tabla2</strong> con cuatro sin incializar (a cero).<br/><br/>
Se utilizan las funciones de archivos para escribir en un archivo el contenido de la <strong>tabla1</strong> y despu&#233;s cargarlo sobre la <strong>tabla2</strong>. Al finalizar el programa, se habr&#225;n copiado los datos de la primera tabla en la segunda.<br/><br/>
Se llama a la funci&#243;n <a href="#223">fopen()</a> en dos ocasiones, la primera para <strong>crearlo y escribir</strong> en &#233;l, y la segunda para <strong>abrirlo y leer</strong> su contenido.<br/><br/>
Es importante resaltar que cada vez que se abra o cree un archivo, se tiene que cerrar despu&#233;s con la funci&#243;n <a href="#224">fclose()</a> (se puede ver como, en el ejemplo, se cierra el archivo en dos ocasiones).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n inversa a <strong>fopen()</strong>, es decir, la que permite escribir datos en un archivo en lugar de leerlos, es <a href="#226">fwrite()</a>. La forma de utilizar esta funci&#243;n y sus par&#225;metros son id&#233;nticos a los de <strong>fread()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Por defecto, la <strong>&lt;longitud&gt;</strong> se especifica como el n&#250;mero de datos simples, teniendo en cuenta que un dato simple (una variable) ocupa <strong>4 bytes</strong>. Es decir, que si por ejemplo, se leen diez datos (indicando 10 como longitud), se estar&#225;n leyendo cuarenta bytes.<br/><br/>
Se puede cambiar esta relaci&#243;n modificando la variable global <a href="#1420">unit_size</a>, que por defecto vale <strong>4</strong> en todos los programas.<br/><br/>
<hr/>
Ver: <a href="#223">fopen()</a> - <a href="#226">fwrite()</a> - <a href="#227">fseek()</a> - <a href="#1420">unit_size</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="226">fwrite()</h2><br/><br/>
<strong>fwrite(</strong>&lt;OFFSET datos&gt;<strong>,</strong> &lt;longitud&gt;<strong>,</strong> &lt;handle&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>0</strong> - Se produjo un error, o no se escribieron todos los datos.<br/>
<strong>1</strong> - Si se pudieron escribir todos los datos.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite escribir datos en un archivo abierto con la funci&#243;n <a href="#223">fopen()</a>, a partir de la posici&#243;n indicada por el <strong>puntero de lectura/escritura</strong>.<br/><br/>
El archivo se debe haber abierto en un <strong>modo de escritura</strong>, o que la permita.<br/><br/>
El <strong>puntero</strong> se situa inicialmente al comienzo del archivo, al abrirse o crearse el mismo, y avanza secuencialmente seg&#250;n se vayan escribiendo datos. No obst&#225;nte puede situarse este puntero del archivo en cualquier posici&#243;n, utilizando la funci&#243;n <a href="#227">fseek()</a> y la funci&#243;n <a href="#228">ftell()</a> permite obtener la posici&#243;n actual del puntero de un archivo.<br/><br/>
La funci&#243;n <strong>fwrite()</strong> requiere como primer par&#225;metro el <strong>&lt;</strong><a href="#1085">OFFSET</a> <strong>de los datos&gt;</strong> que deben escribirse en el archivo, es decir, la direcci&#243;n de memoria.<br/><br/>
Como segundo par&#225;metro se requiere la <strong>&lt;longitud&gt;</strong> o tama&#241;o total de los datos que se quieren escribir, es decir, el n&#250;mero de posiciones de memoria que ocupan dichos datos. La longitud de un dato se puede obtener con la funci&#243;n <a href="#1094">sizeof()</a>.<br/><br/>
El &#250;ltimo par&#225;metro debe ser el <strong>handle</strong> o <strong>identificador de archivo</strong> que se obtuvo al abrir el archivo como valor de retorno de <a href="#223">fopen()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fwrite;

GLOBAL
    mitabla[3]=11,22,33,44;
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);

    fwrite(OFFSET tabla1,4,mihandle); // Escribe &lt;mitabla&gt; en el archivo

    fclose(mihandle);
END
</pre>
Este programa ejemplo escribe los datos contenidos en <strong>&lt;mitabla&gt;</strong> en el archivo <strong>help.dat</strong> del disco.<br/><br/>
Se llama a la funci&#243;n <a href="#223">fopen()</a> para crearlo y a la funci&#243;n <a href="#224">fclose()</a> para cerrarlo una vez se han escrito los datos.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n inversa a <strong>fwrite()</strong>, es decir, la que permite escribir datos en un archivo en lugar de leerlos, es <a href="#225">fread()</a>. La forma de utilizar esta funci&#243;n y sus par&#225;metros son id&#233;nticos a los de <strong>fwrite()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Por defecto, la <strong>&lt;longitud&gt;</strong> se especifica como el n&#250;mero de datos simples, teniendo en cuenta que un dato simple (una variable) ocupa <strong>4 bytes</strong>. Es decir, que si por ejemplo, se escriben diez datos (indicando 10 como longitud), se estar&#225;n escribiendo cuarenta bytes.<br/><br/>
Se puede cambiar esta relaci&#243;n modificando la variable global <a href="#1420">unit_size</a>, que por defecto vale <strong>4</strong> en todos los programas.<br/><br/>
<hr/>
Ver: <a href="#223">fopen()</a> - <a href="#225">fread()</a> - <a href="#227">fseek()</a> - <a href="#1420">unit_size</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="227">fseek()</h2><br/><br/>
<strong>fseek(</strong>&lt;handle&gt;<strong>,</strong> &lt;posici&#243;n puntero&gt;<strong>,</strong> &lt;modo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Sit&#250;a el <strong>puntero de lectura/escritura</strong> de un archivo en la posici&#243;n indicada.<br/><br/>
La funci&#243;n requiere, en primer lugar, el <strong>&lt;handle&gt;</strong> o <strong>identificador de archivo</strong> devuelto por la funci&#243;n <a href="#223">fopen()</a> al abrirlo.<br/><br/>
En segundo lugar se especifica la nueva posici&#243;n en la que debe situarse el <strong>&lt;puntero&gt;</strong> del archivo. Tras llamar a esta funci&#243;n, todas las operaciones de lectura o escritura que se efect&#250;en, lo har&#225;n a partir de esta posici&#243;n.<br/><br/>
Como &#250;ltimo par&#225;metro se debe indicar el <strong>&lt;modo&gt;</strong> en el que se especifica la nueva posici&#243;n del puntero, puede ser uno de estos tres:<br/><br/>
<strong>seek_set</strong> - Posici&#243;n respecto al inicio del archivo (0).<br/>
<strong>seek_cur</strong> - Incremento relativo a la posici&#243;n actual (1).<br/>
<strong>seek_end</strong> - Posici&#243;n respecto al final del archivo (2).<br/>
<br/><br/>
Para obtener la situaci&#243;n actual del puntero de un archivo, se debe utilizar la funci&#243;n <a href="#228">ftell()</a>.<br/><br/>
Todas las operaciones de lectura o escritura sobre un archivo avanzan autom&#225;ticamente el puntero del mismo, de forma que todos estos accesos se realicen de forma secuencial (leyendo o escribiendo los datos unos a continuaci&#243;n de otros).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_fseek;

GLOBAL
    mitabla[3]=11,22,33,44;
    midato;
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);
    fwrite(OFFSET mitabla,4,mihandle);
    fclose(mihandle);
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;r&quot;);

    // Sit&#250;a el puntero para leer el cuarto dato del archivo (44)

    fseek(mihandle,3,seek_set);

    fread(OFFSET midato,1,mihandle);
    fclose(mihandle);
END
</pre>
Este ejemplo escribe los cuatro datos contenidos en <strong>mitabla</strong> (11,22,33 y 44) en el archivo <strong>help.dat</strong>, tras esto, abre el archivo para lectura y utiliza la funci&#243;n <strong>fseek()</strong> para situar el puntero en la <strong>posici&#243;n 3</strong> a partir del inicio del archivo (con <strong>seek_set</strong>).<br/><br/>
A partir de este momento, se podr&#225; leer a partir del cuarto dato del archivo, por ello, cuando se lee un valor en la variable <strong>midato</strong> este ser&#225; <strong>44</strong>, es decir, el cuarto valor de la tabla.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Por defecto, la <strong>&lt;posici&#243;n del puntero&gt;</strong> se especifica como un n&#250;mero de datos simples, teniendo en cuenta que un dato simple (una variable) ocupa <strong>4 bytes</strong>. Es decir, que si por ejemplo, se sit&#250;a el puntero en la posici&#243;n diez a partir del inicio del fichero, se podr&#225; entonces acceder a los datos contenidos en el archivo a partir del byte cuarenta.<br/><br/>
Se puede cambiar esta relaci&#243;n modificando la variable global <a href="#1420">unit_size</a>, que por defecto vale <strong>4</strong> en todos los programas.<br/><br/>
<hr/>
Ver: <a href="#228">ftell()</a> - <a href="#225">fread()</a> - <a href="#226">fwrite()</a> - <a href="#1420">unit_size</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="228">ftell()</h2><br/><br/>
<strong>ftell(</strong>&lt;handle&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La posici&#243;n actual del puntero de lectura/escritura de un archivo.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Retorna la posici&#243;n del <strong>puntero de lectura/escritura</strong> de un archivo, para ello requiere &#250;nicamente el <strong>&lt;handle&gt;</strong> o <strong>identificador de archivo</strong> devuelto por la funci&#243;n <a href="#223">fopen()</a> al abrirlo.<br/><br/>
Para establecer una nueva posici&#243;n del puntero de un archivo, se debe utilizar la funci&#243;n <a href="#227">fseek()</a>. A diferencia de esta &#250;ltima funci&#243;n, <strong>ftell()</strong> siempre retorna la posici&#243;n del puntero respecto al inicio del archivo.<br/><br/>
Todas las operaciones de lectura o escritura sobre un archivo avanzan autom&#225;ticamente el puntero del mismo, de forma que todos estos accesos se realicen de forma secuencial (leyendo o escribiendo los datos unos a continuaci&#243;n de otros).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_ftell;

GLOBAL
    mitabla[3]=11,22,33,44;
    midato1;
    midato2;
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);

    midato1=ftell(mihandle); // Posici&#243;n del puntero antes de escribir

    fwrite(OFFSET mitabla,4,mihandle);

    midato2=ftell(mihandle); // Posici&#243;n del puntero tras escribir los datos

    fclose(mihandle);
END
</pre>
Este ejemplo escribe los cuatro datos contenidos en <strong>mitabla</strong> (11,22,33 y 44) en el archivo <strong>help.dat</strong>.<br/><br/>
Tras abrir el archivo con <a href="#223">fopen()</a>, se obtiene la posici&#243;n del puntero y se guarda en <strong>midato1</strong> (esta ser&#225; 0, al inicio del archivo).<br/><br/>
Entonces se escriben en el archivo los cuatro valores contenidos en la tabla y se vuelve a obtener la posici&#243;n del puntero, que ahora se guarda en <strong>midato2</strong> (ser&#225; 4, al final del archivo, tras los cuatro valores escritos).<br/><br/>
Finalmente, se cierra el archivo con <a href="#224">fclose()</a> antes de finalizar.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Por defecto, la <strong>&lt;posici&#243;n del puntero&gt;</strong> se especifica como un n&#250;mero de datos simples, teniendo en cuenta que un dato simple (una variable) ocupa <strong>4 bytes</strong>. Es decir, que si por ejemplo, el puntero se encuentra en la posici&#243;n diez (siempre a partir del inicio del fichero), se podr&#225; entonces acceder a los datos contenidos en el archivo a partir del byte cuarenta.<br/><br/>
Se puede cambiar esta relaci&#243;n modificando la variable global <a href="#1420">unit_size</a>, que por defecto vale <strong>4</strong> en todos los programas.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <a href="#229">filelength()</a> permite averiguar la longitud de un archivo, para ello se debe abrir previamente el mismo.<br/><br/>
<hr/>
Ver: <a href="#227">fseek()</a> - <a href="#225">fread()</a> - <a href="#226">fwrite()</a> - <a href="#1420">unit_size</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="229">filelength()</h2><br/><br/>
<strong>filelength(</strong>&lt;handle&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La longitud del archivo.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite obtener la longitud de un archivo previamente abierto con <a href="#223">fopen()</a>, para ello requiere como par&#225;metro el <strong>&lt;handle&gt;</strong> o <strong>identificador de archivo</strong> devuelto por dicha funci&#243;n.<br/><br/>
Esta funci&#243;n no modifica la posici&#243;n actual del puntero de lectura/escritura del archivo, simplemente devuelve el n&#250;mero de datos contenidos actualmente en el mismo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_filelength;

GLOBAL
    mitabla[3]=11,22,33,44;
    longitud;
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);
    fwrite(OFFSET mitabla,4,mihandle);
    fclose(mihandle);
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;r&quot;);

    longitud=filelength(mihandle); // Obtiene la longitud del archivo (4)

    fclose(mihandle);
END
</pre>
Este programa ejemplo crea primeramente un archivo denominado <strong>help.dat</strong>, escribiendo en el los cuatro valores contenidos en <strong>mitabla</strong>.<br/><br/>
Una vez creado el archivo en disco, se abrir&#225; para obtener su <strong>longitud</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Por defecto, la <strong>longitud del archivo</strong> se obtiene como el n&#250;mero de datos simples que contiene, teniendo en cuenta que un dato simple (una variable) ocupa <strong>4 bytes</strong>. Es decir, que si por ejemplo, la longitud de un archivo es diez, ocupar&#225; cuarenta bytes en el disco.<br/><br/>
Se puede cambiar esta relaci&#243;n modificando la variable global <a href="#1420">unit_size</a>, que por defecto vale <strong>4</strong> en todos los programas.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las funciones <a href="#231">get_dirinfo()</a> y <a href="#232">get_fileinfo()</a> permiten obtener mucha m&#225;s informaci&#243;n sobre la estructura de directorios (carpetas) del disco y sobre los archivos contenidos en ella.<br/><br/>
<hr/>
Ver: <a href="#223">fopen()</a> - <a href="#231">get_dirinfo()</a> - <a href="#1420">unit_size</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="230">flush()</h2><br/><br/>
<strong>flush(</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El n&#250;mero de archivos abiertos.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Vacia los buffers de escritura, es decir, hace que todos los datos escritos a un archivo de disco que est&#233;n a&#250;n en la cach&#233; de escritura se graben f&#237;sicamente en su archivo correspondiente.<br/><br/>
Esta operaci&#243;n no suele ser necesaria nunca, ya que la administraci&#243;n de la cach&#233; que realiza el sistema operativo es muy efectiva, y no van a perderse nunca datos por que no se escriban directamente al disco.<br/><br/>
No obstante, esta funci&#243;n tiene otra utilidad, y es que devuelve el <strong>numero de archivos abiertos con</strong> <a href="#223">fopen()</a> dentro de un programa.<br/><br/>
El sistema de archivos permite &#250;nicamente un m&#225;ximo de archivos abiertos, que depende de la configuraci&#243;n del sistema operativo.<br/><br/>
Deber&#225;n cerrarse con <a href="#224">fclose()</a> todos los archivos una vez se haya realizado con ellos la operaci&#243;n oportuna. Esta &#250;ltima funci&#243;n permite cerrar un s&#243;lo archivo, o todos los que est&#233;n abiertos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_flush;

GLOBAL
    midato1;
    midato2;
    mihandle;

BEGIN
    mihandle=fopen(&quot;help\help.dat&quot;,&quot;w&quot;);

    midato1=flush(); // Obtiene el n&#250;mero de archivos abiertos (1)

    fclose(mihandle);

    midato2=flush(); // Obtiene el n&#250;mero de archivos abiertos (0)

END
</pre>
Este ejemplo obtiene en dos ocasiones el n&#250;mero de archivos abiertos con la funci&#243;n <strong>flush()</strong>. Tras aberse abierto el archivo <strong>help.dat</strong> la funci&#243;n determina que hay abierto uno y, una vez cerrado el mismo, se podr&#225; comprobar como ya no hay ninguno.<br/><br/>
<hr/>
Ver: <a href="#223">fopen()</a> - <a href="#224">fclose()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="231">get_dirinfo()</h2><br/><br/>
<strong>get_dirinfo(</strong>&lt;m&#225;scara de directorio&gt;<strong>,</strong> &lt;tipos de archivo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
N&#250;mero de archivos del directorio que coinciden con la m&#225;scara y el tipo seleccionado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite obtener la lista de archivos de un directorio (carpeta) del disco.<br/><br/>
Se requiere la <strong>&lt;m&#225;scara del directorio&gt;</strong> para seleccionar los archivos que deben listarse. Esta <strong>&lt;m&#225;scara&gt;</strong> no es m&#225;s que un nombre de archivo parcial, utilizando comodines; por ejemplo, la m&#225;scara <strong>&quot;*.*&quot;</strong> (se debe indicar como un texto entre comillas) seleccionar&#225; todos los archivos del directorio.<br/><br/>
Tambi&#233;n se puede incluir en la m&#225;scara la <strong>ruta de acceso</strong> del directorio (en caso contrario se listar&#225;n los archivos del directorio actual). Por ejemplo, la m&#225;scara <strong>&quot;C:\WINDOWS\SYS*.??E&quot;</strong> seleccionar&#237;a todos los archivos del directorio <strong>&quot;C:\WINDOWS&quot;</strong> cuyo nombre comenzara por <strong>&quot;SYS&quot;</strong> y su extensi&#243;n acabara en <strong>&quot;E&quot;</strong>.<br/><br/>
Como segundo par&#225;metro se debe indicar los <strong>&lt;tipos de archivos&gt;</strong> que deben incluirse en la lista, estos son los siguientes:<br/><br/>
<strong> _normal</strong> - Listar s&#243;lo los archivos normales.<br/>
<strong> _hidden</strong> - Incluir tambi&#233;n los archivos ocultos.<br/>
<strong> _system</strong> - Incluir tambi&#233;n los archivos del sistema.<br/>
<strong> _subdir</strong> - Incluir tambi&#233;n los subdirectorios.<br/>
<strong> _volid</strong>  - Listar s&#243;lo la etiqueta del volumen.<br/>
<br/><br/>
Lo m&#225;s usual es indicar <strong>_normal</strong> como <strong>&lt;tipo de archivos&gt;</strong>, este tipo engloba a la gran mayor&#237;a de archivos que aparecen en un disco, tanto de lectura/escritura, como de s&#243;lo lectura (&#250;nicamente no se incluyen algunos archivos especiales, que normalmente son archivos internos del sistema operativo).<br/><br/>
Si se indican <strong>_hidden</strong>, <strong>_system</strong> o <strong>_subdir</strong>, se incluir&#225;n estos tipos de archivos adem&#225;s de los normales (no es necesario especificar <strong>_normal</strong>). Adem&#225;s pueden sumarse estos tipos; por ejemplo, indicando <strong>_hidden+_system</strong> se listar&#225;n todos los archivos normales, los ocultos y los del sistema.<br/><br/>
Cuando se indique <strong>_volid</strong>, &#250;nicamente se listar&#225; el nombre de la etiqueta de volumen del disco, no se incluir&#225; ning&#250;n archivo ni subdirectorio en la lista (no se pueden sumar otros tipos a este).<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <strong>get_dirinfo()</strong> simplemente retorna el <strong>n&#250;mero total</strong> de archivos listados; los nombres de estos archivos se guardan en la estructura global <a href="#1413">dirinfo</a> (el primer nombre de archivo se guarda en <strong>dirinfo.name[0]</strong>, el segundo en <strong>dirinfo.name[1]</strong>, etc.).<br/><br/>
El <strong>n&#250;mero total</strong> de archivos listados que retorna esta funci&#243;n se guarda adem&#225;s en <strong>dirinfo.files</strong>.<br/><br/>
La lista de nombres de archivos se guarda siempre en orden alfab&#233;tico, no obstante se puede utilizar la funci&#243;n <a href="#213">qsort()</a> para ordenar la estructura global <a href="#1413">dirinfo</a> por cualquier otro criterio.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n &#250;nicamente permite obtener los <strong>nombres</strong> de los archivos, para obtener m&#225;s informaci&#243;n de los mismos (los atributos, el tama&#241;o, la fecha, etc.) se debe utilizar la funci&#243;n <a href="#232">get_fileinfo()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_dirinfo;

GLOBAL
    contador;

BEGIN
    write(0,0,0,0,&quot;Listado de archivos - Pulse ESC para terminar&quot;);

    get_dirinfo(&quot;C:\WINDOWS\*.EXE&quot;,_normal); // Obtiene el listado de archivos

    FOR (contador=0;contador&lt;dirinfo.files;contador++)
       x=(contador%4)*80;
       y=16+(contador/4)*8;
       write(0,x,y,0,dirinfo.name[contador]);
    END

    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa ejemplo lista todos los archivos <strong>EXE</strong> normales del directorio C:\WINDOWS, y entonces los muestra en pantalla.<br/><br/>
El bucle <a href="#1025">FOR</a> es el encargado de mostrar en pantalla la lista de archivos de la estructura <a href="#1413">dirinfo</a> a cuatro columnas, ya que la funci&#243;n <strong>get_dirinfo()</strong> no muestra ninguna informaci&#243;n en pantalla, &#250;nicamente rellena la estructura con los nombres de los archivos encontrados en el directorio.<br/><br/>
<hr/>
<br/><br/>
Para abrir o crear un archivo se puede utilizar la funci&#243;n <a href="#223">fopen()</a>.<br/><br/>
Para cambiar de directorio se debe utilizar <a href="#235">chdir()</a>, y <a href="#236">mkdir()</a> para crear uno nuevo.<br/><br/>
La funci&#243;n <a href="#238">disk_free()</a> permite averiguar el espacio libre que queda en una unidad de disco.<br/><br/>
<hr/>
Ver: <a href="#232">get_fileinfo()</a> - <a href="#223">fopen()</a> - <a href="#235">chdir()</a> - <a href="#236">mkdir()</a> - <a href="#238">disk_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="232">get_fileinfo()</h2><br/><br/>
<strong>get_fileinfo(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>0</strong> - No se pudo obtener informaci&#243;n sobre el archivo.<br/>
<strong>1</strong> - La informaci&#243;n del archivo se guard&#243; correctamente.<br/>
<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Obtiene informaci&#243;n sobre un archivo o directorio del disco, para ello, la funci&#243;n requiere el <strong>&lt;nombre del archivo&gt;</strong> como par&#225;metro (entre comillas). Se puede indicar &#250;nicamente el nombre, o incluir adem&#225;s la ruta de acceso al mismo.<br/><br/>
Si la funci&#243;n encuentra dicho archivo en el directorio especificado (o en el actual, en caso de no especificar ninguno), retornar&#225; <strong>1</strong> y guardar&#225; toda la informaci&#243;n sobre el archivo en la estructura global <a href="#1414">fileinfo</a>, que contiene los siguientes campos:<br/><br/>
<strong> fullpath</strong> - Nombre completo (incluyendo la ruta).<br/>
<strong> drive</strong>    - Unidad de disco (1-A:, 2-B:, 3-C:, ...).<br/>
<strong> dir</strong>      - Directorio del archivo.<br/>
<strong> name</strong>     - Nombre del archivo.<br/>
<strong> ext</strong>      - Extensi&#243;n del archivo.<br/>
<strong> size</strong>     - Tama&#241;o (en datos simples, ver <a href="#1420">unit_size</a>).<br/>
<strong> day</strong>      - D&#237;a (fecha de &#250;ltima actualizaci&#243;n).<br/>
<strong> month</strong>    - Mes (fecha de &#250;ltima actualizaci&#243;n).<br/>
<strong> year</strong>     - A&#241;o (fecha de &#250;ltima actualizaci&#243;n).<br/>
<strong> hour</strong>     - Hora (hora de &#250;ltima actualizaci&#243;n).<br/>
<strong> min</strong>      - Minuto (hora de &#250;ltima actualizaci&#243;n).<br/>
<strong> sec</strong>      - Segundo (hora de &#250;ltima actualizaci&#243;n).<br/>
<strong> attrib</strong>   - Atributos del archivo.<br/>
<br/><br/>
La ruta de acceso al archivo se puede especificar completa (a partir del directorio raiz de la unidad, como &quot;C:\WINDOWS\...&quot;) o relativa al directorio actual (a partir de donde se ejecute el juego, como &quot;MAP\MIOS\...&quot;). En cualquier caso, en <strong>fileinfo.fullpath</strong> siempre se devolver&#225; la ruta completa a partir del directorio raiz, incluyendo la letra de la unidad.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <strong>get_fileinfo()</strong> &#250;nicamente obtiene informaci&#243;n sobre un archivo, para obtener la lista completa de archivos de un directorio, se debe utilizar la funci&#243;n <a href="#231">get_dirinfo()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_get_fileinfo;
BEGIN
    // ...

    get_fileinfo(&quot;HELP\HELP.FPG&quot;);

    // ...
END
</pre>
Este peque&#241;o ejemplo solicita informaci&#243;n sobre el fichero <strong>help.fpg</strong> contenido en el directorio <strong>help</strong>. Se puede extraer y trazar (con <strong>F12</strong>) para observar como, tras llamar a la funci&#243;n, la estructura global predefinida <a href="#1413">fileinfo</a> se ha rellenado con todos los datos del archivo.<br/><br/>
<hr/>
<br/><br/>
Para abrir o crear un archivo se puede utilizar la funci&#243;n <a href="#223">fopen()</a>, y para borrar un archivo existente en el disco se utiliza <a href="#237">remove()</a>.<br/><br/>
La funci&#243;n <a href="#238">disk_free()</a> permite averiguar el espacio libre que queda en una unidad de disco.<br/><br/>
<hr/>
Ver: <a href="#231">get_dirinfo()</a> - <a href="#223">fopen()</a> - <a href="#237">remove()</a> - <a href="#238">disk_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="233">getdrive()</h2><br/><br/>
<strong>getdrive(</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El n&#250;mero de la unidad de disco actual.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar cual es la unidad de disco que esta siendo utilizada actualmente, esta se devuelve como un n&#250;mero, correspondi&#233;ndose el <strong>1</strong> con la unidad <strong>A:</strong>, el <strong>2</strong> con <strong>B:</strong>, <strong>3</strong> con <strong>C:</strong>, etc. No se requieren par&#225;metros en la llamada.<br/><br/>
La funci&#243;n <a href="#234">setdrive()</a> permite establecer la unidad de disco actual; todos los accesos a disco (lectura y escritura de archivos) se efect&#250;an siempre dentro de una unidad seleccionada que, por defecto, ser&#225; la unidad en la que se ejecute el programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_getdrive;

GLOBAL
    unidad;

BEGIN
    write(0,0,0,0,&quot;Unidad de disco actual:&quot;);

    unidad=getdrive();

    write_int(0,0,20,0,OFFSET unidad);
    LOOP
        FRAME;
    END
END
</pre>
Este programa muestra en pantalla el n&#250;mero de unidad actual obtenido con la funci&#243;n <strong>getdrive()</strong>.<br/><br/>
<hr/>
<br/><br/>
Para cambiar de directorio se debe utilizar <a href="#235">chdir()</a>, y <a href="#236">mkdir()</a> para crear uno nuevo.<br/><br/>
La funci&#243;n <a href="#238">disk_free()</a> permite averiguar el espacio libre que queda en una unidad de disco.<br/><br/>
<hr/>
Ver: <a href="#234">setdrive()</a> - <a href="#235">chdir()</a> - <a href="#236">mkdir()</a> - <a href="#238">disk_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="234">setdrive()</h2><br/><br/>
<strong>setdrive(</strong>&lt;unidad&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite establecer la unidad de disco actual; todos los accesos a disco (lectura y escritura de archivos) se efect&#250;an siempre dentro de una unidad seleccionada que, por defecto, ser&#225; la unidad en la que se ejecute el programa.<br/><br/>
La <strong>&lt;unidad&gt;</strong> se debe indicar con un n&#250;mero, correspondi&#233;ndose el <strong>1</strong> con la unidad <strong>A:</strong>, el <strong>2</strong> con <strong>B:</strong>, <strong>3</strong> con <strong>C:</strong>, etc. No se retorna ning&#250;n valor.<br/><br/>
La funci&#243;n <a href="#233">getdrive()</a> permite obtener el n&#250;mero de unidad actual.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_setdrive;

GLOBAL
    unidad;

BEGIN
    // ...

    unidad=getdrive();

    setdrive(1);      // Se sit&#250;a en la unidad A:

    // ...

    setdrive(unidad); // Recupera la unidad anterior

    // ...
END
</pre>
Este programa obtiene primero la unidad actual con la funci&#243;n <a href="#233">getdrive()</a> y la guarda en la variable <strong>unidad</strong>, entonces se situa en la unidad <strong>1</strong> (A:) para, finalmente, volver a la unidad en la que se est&#233; ejecutando el programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Al cambiar a otra unidad con <strong>setdrive()</strong> no se retorna ning&#250;n valor, pero se puede llamar despu&#233;s a <a href="#233">getdrive()</a> para comprobar que el programa se ha situado en la unidad solicitada.<br/><br/>
<hr/>
<br/><br/>
Para cambiar de directorio se debe utilizar <a href="#235">chdir()</a>, y <a href="#236">mkdir()</a> para crear uno nuevo.<br/><br/>
La funci&#243;n <a href="#238">disk_free()</a> permite averiguar el espacio libre que queda en una unidad de disco.<br/><br/>
<hr/>
Ver: <a href="#233">getdrive()</a> - <a href="#235">chdir()</a> - <a href="#236">mkdir()</a> - <a href="#238">disk_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="235">chdir()</h2><br/><br/>
<strong>chdir(</strong>&lt;directorio&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>1</strong> - Se cambi&#243; al directorio indicado.<br/>
<strong>0</strong> - No se pudo acceder a dicho directorio.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Cambia el directorio actual, dentro de la unidad seleccionada.<br/><br/>
El directorio se debe indicar como un literal (un texto entre comillas), y puede ser una ruta relativa (a partir del directorio actual) o una ruta absoluta (a partir del directorio raiz).<br/><br/>
La forma de utilizaci&#243;n y posibilidades de esta funci&#243;n son las mismas que las del comando <strong>CD</strong> de la l&#237;nea de comandos del sistema operativo.<br/><br/>
Todos los programas se sit&#250;an inicialmente en el directorio en el que se encuentra su ejecutable principal.<br/><br/>
Se pueden crear nuevos directorios (o carpetas) en la estructura de un disco con la funci&#243;n <a href="#236">mkdir()</a>, y con la funci&#243;n <a href="#237">remove()</a> se pueden eliminar los existentes.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_chdir;
BEGIN
    chdir(&quot;MAP&quot;); // Se sit&#250;a en el directorio MAP\

    // ...

    chdir(&quot;..&quot;);  // Vuelve al directorio anterior
END
</pre>
Este peque&#241;o ejemplo muestra como debe utilizarse la funci&#243;n <strong>chdir()</strong> para cambiar de directorio.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#234">setdrive()</a> permite establecer la unidad de disco actual y la funci&#243;n <a href="#233">getdrive()</a> averiguarlo; todos los accesos a disco (lectura y escritura de archivos) se efect&#250;an siempre dentro de una unidad seleccionada que, por defecto, ser&#225; la unidad en la que se ejecute el programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede obtener la lista de archivos de un directorio con la funci&#243;n <a href="#231">get_dirinfo()</a>.<br/><br/>
<hr/>
Ver: <a href="#236">mkdir()</a> - <a href="#237">remove()</a> - <a href="#234">setdrive()</a> - <a href="#233">getdrive()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="236">mkdir()</h2><br/><br/>
<strong>mkdir(</strong>&lt;directorio&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Crea un directorio nuevo (dentro del directorio o carpeta actual).<br/><br/>
Se debe indicar el nombre del directorio a crear como un literal (un texto entre comillas).<br/><br/>
La forma de utilizaci&#243;n y posibilidades de esta funci&#243;n son las mismas que las del comando <strong>MD</strong> de la l&#237;nea de comandos del sistema operativo.<br/><br/>
Todos los programas se sit&#250;an inicialmente en el directorio en el que se encuentra su ejecutable principal.<br/><br/>
Se pueden cambiar el directorio en el que est&#225; situado un programa (en el que realizar&#225; sus operaciones de archivos) con la funci&#243;n <a href="#235">chdir()</a>, y con la funci&#243;n <a href="#237">remove()</a> se pueden eliminar los directorios existentes.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_mkdir;
BEGIN
    mkdir(&quot;temporal&quot;); // Crea un nuevo directorio

    // ...
    remove(&quot;temporal&quot;);
END
</pre>
Este peque&#241;o ejemplo muestra como debe utilizarse la funci&#243;n <strong>mkdir()</strong> para crear un directorio, y despu&#233;s lo elimina con la funci&#243;n <a href="#237">remove()</a>.<br/><br/>
<hr/>
<br/><br/>
La funci&#243;n <a href="#234">setdrive()</a> permite establecer la unidad de disco actual y la funci&#243;n <a href="#233">getdrive()</a> averiguarlo; todos los accesos a disco (lectura y escritura de archivos) se efect&#250;an siempre dentro de una unidad seleccionada que, por defecto, ser&#225; la unidad en la que se ejecute el programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede obtener la lista de archivos de un directorio con la funci&#243;n <a href="#231">get_dirinfo()</a>.<br/><br/>
<hr/>
Ver: <a href="#235">chdir()</a> - <a href="#237">remove()</a> - <a href="#234">setdrive()</a> - <a href="#233">getdrive()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="237">remove()</h2><br/><br/>
<strong>remove(</strong>&lt;nombre de archivo o directorio&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Borra archivos o subdirectorios contenidos dentro del directorio actual en el que se ejecuta el programa.<br/><br/>
Se debe indicar el <strong>&lt;nombre de archivo o directorio&gt;</strong> en un literal (un texto entre comillas), tambi&#233;n se aceptan los car&#225;cteres comod&#237;n &quot;?&quot; y &quot;*&quot; (como por ejemplo &quot;*.bak&quot; para eliminar todos los archivos con extensi&#243;n BAK).<br/><br/>
Se eliminar&#225;n siempre los archivos dentro del directorio actual (ver <a href="#235">chdir()</a> para cambiar de directorio) y de la unidad actual (ver <a href="#234">setdrive()</a> para cambiar de unidad).<br/><br/>
Con esta funci&#243;n tambi&#233;n se pueden eliminar directorios, pero &#250;nicamente si est&#225;n vacios (si no contienen archivos u otros subdirectorios dentro).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Esta funci&#243;n debe utilizarse con precauci&#243;n, ya que los archivos borrados no podr&#225;n recuperarse, y puede perderse informaci&#243;n o programas contenidos en el disco.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_remove;
BEGIN
    mkdir(&quot;temporal&quot;);
    // ...

    remove(&quot;temporal&quot;); // Elimina un directorio
END
</pre>
Este peque&#241;o ejemplo crea un directorio con la funci&#243;n <a href="#236">mkdir()</a> y despu&#233;s lo elimina con la funci&#243;n <strong>remove()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede obtener la lista de archivos de un directorio con la funci&#243;n <a href="#231">get_dirinfo()</a>.<br/><br/>
<hr/>
Ver: <a href="#235">chdir()</a> - <a href="#234">setdrive()</a> - <a href="#231">get_dirinfo()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="238">disk_free()</h2><br/><br/>
<strong>disk_free(</strong>&lt;unidad&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El espacio libre de la unidad de disco.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar el espacio libre de cualquier unidad de disco.<br/><br/>
Se requiere el n&#250;mero de <strong>&lt;unidad&gt;</strong> como &#250;nico par&#225;metro, correspondi&#233;ndose el <strong>1</strong> con la unidad <strong>A:</strong>, el <strong>2</strong> con <strong>B:</strong>, <strong>3</strong> con <strong>C:</strong>, etc.<br/><br/>
El espacio disponible en la unidad se retorna en <strong>Kbs</strong> (en kilobytes, siendo cada uno un total de 1024 bytes).<br/><br/>
Se puede averiguar cual es la unidad de disco actual (en la que se est&#233; ejecutando el programo) gracias a la funci&#243;n <a href="#233">getdrive()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_disk_free;

GLOBAL
    unidad;
    espacio_libre;

BEGIN
    // ...

    unidad=getdrive();
    espacio_libre=disk_free(unidad);

    // ...
END
</pre>
Este programa utiliza primeramente la funci&#243;n <a href="#233">getdrive()</a> para determinar en que unidad de disco se est&#225; ejecutando el programa (que se almacena en la variable <strong>unidad</strong>), y entonces determina el espacio libre disponible en la misma con <strong>disk_free()</strong>.<br/><br/>
<hr/>
<br/><br/>
Para obtener el tama&#241;o de los archivos del disco se deben utilizar conjuntamente las funciones <a href="#231">get_dirinfo()</a> y <a href="#232">get_fileinfo()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <a href="#239">memory_free()</a> permite determinar la memoria libre, es decir, la cantidad de memoria que queda disponible para el programa.<br/><br/>
<hr/>
Ver: <a href="#233">getdrive()</a> - <a href="#239">memory_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="239">memory_free()</h2><br/><br/>
<strong>memory_free(</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La memoria libre disponible para el programa.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite determinar la cantidad de memoria RAM del ordenador que queda disponible para uso del programa.<br/><br/>
No se requiere ning&#250;n par&#225;metro, y el total de memoria se retorna en Kbs (en kilobytes, siendo cada uno un total de 1024 bytes).<br/><br/>
Esta cantidad de memoria ser&#225; la que el programa dispone para cargar todos sus recursos (gr&#225;ficos, sonidos, etc.), por ello es conveniente comprobar con esta funci&#243;n, al inicio de los programas, que el ordenador dispone de memoria suficiente para cargar todos los recursos necesarios.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_memory_free;

GLOBAL
    memoria_libre;

BEGIN
    // ...

    memoria_libre=memory_free();

    // ...
END
</pre>
Este peque&#241;o ejemplo utiliza la funci&#243;n <strong>memory_free()</strong> para guardar en la variable global denominada <strong>memoria_libre</strong> la cantidad de RAM que queda disponible para el programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <a href="#238">disk_free()</a> permite determinar el espacio libre de una de las unidades de disco del ordenador.<br/><br/>
<hr/>
Ver: <a href="#238">disk_free()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="240">ignore_error()</h2><br/><br/>
<strong>ignore_error(</strong>&lt;n&#250;mero de error&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n permite ignorar un error de ejecuci&#243;n determinado, para ello se requiere como par&#225;metro el <strong>&lt;n&#250;mero de error&gt;</strong>; este es el n&#250;mero presente en la ventana informativa de un error que aparece en ocasiones cuando un programa se est&#225; ejecutando.<br/><br/>
En un principio, no es recomendable ignorar los errores de ejecuci&#243;n, ya que el programa se comportar&#225; anormalmente cuando suceda un error, sin dar ninguna informaci&#243;n relativa al error que ha sucedido.<br/><br/>
Cuando un programa produce un error de ejecuci&#243;n, siempre es por una causa que puede solucionarse; e ignorar el error no solucionar&#225; el problema.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> No todos los errores pueden ser ignorados, hay algunos errores que imposiblitan que el programa contin&#250;e ejecut&#225;ndose de ninguna forma; estos son los errores denominados &quot;graves&quot;, que siempre abortar&#225;n el programa en el caso de darse.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_ignore_error;
BEGIN

    ignore_error(145); // Ignorar las divisiones entre cero

    x=x/0;
END
</pre>
En este ejemplo se llama a la funci&#243;n <strong>ignore_error()</strong> para advertir al sistema de que, en adelante, debe ignorar las divisiones por cero (estas dar&#225;n un resultado indeterminado).<br/><br/>
A continuaci&#243;n se realiza una divisi&#243;n por cero, para que se pueda comprobar como no se emite ninguna ventana informativa de dicho error.<br/><br/>
Este error es el n&#250;mero <strong>145</strong>, se puede observar el mismo comentando la llamada a la funci&#243;n <strong>ignore_error()</strong> del ejemplo anterior.<br/><br/>
<hr/>
<br/><br/>
<strong>Lista de c&#243;digos de los errores de ejecuci&#243;n:</strong><br/><br/>
<strong>100</strong> No hay memoria suficiente para ejecutar el programa.<br/>
<strong>101</strong> Llamada a key() con un c&#243;digo de tecla inexistente.<br/>
<strong>102</strong> No se pudo cargar la paleta, archivo no encontrado.<br/>
<strong>103</strong> Se intent&#243; cargar un archivo de paleta inv&#225;lido.<br/>
<strong>104</strong> Demasiados ficheros FPG abiertos a la vez.<br/>
<strong>105</strong> No se pudo cargar el fichero, archivo no encontrado.<br/>
<strong>106</strong> Se intent&#243; cargar un fichero FPG no v&#225;lido.<br/>
<strong>107</strong> N&#250;mero de scroll inv&#225;lido (debe estar entre 0 y 9).<br/>
<strong>108</strong> N&#250;mero de regi&#243;n inv&#225;lido (fuera de rango).<br/>
<strong>109</strong> C&#243;digo de fichero inv&#225;lido.<br/>
<strong>110</strong> C&#243;digo de gr&#225;fico inv&#225;lido.<br/>
<strong>111</strong> Se intent&#243; usar un fichero FPG antes de cargarlo.<br/>
<strong>112</strong> Se necesita un c&#243;digo de gr&#225;fico para el scroll.<br/>
<strong>113</strong> Se han cargado demasiados fuentes de letras.<br/>
<strong>114</strong> No se pudo cargar el fuente, archivo no encontrado.<br/>
<strong>115</strong> Se intent&#243; cargar un archivo de fuente no v&#225;lido.<br/>
<strong>116</strong> C&#243;digo identificador de fuente de letras inv&#225;lido.<br/>
<strong>117</strong> C&#243;digo de centrado de texto inv&#225;lido.<br/>
<strong>118</strong> Hay demasiados textos activos en el programa.<br/>
<strong>119</strong> Indentificador de texto no v&#225;lido.<br/>
<strong>120</strong> Regi&#243;n de pantalla definida incorrectamente.<br/>
<strong>121</strong> Se intent&#243; utilizar un gr&#225;fico que no existe.<br/>
<strong>122</strong> Se intent&#243; escribir un bloque fuera de la memoria.<br/>
<strong>123</strong> No se pudo abrir el archivo para escritura.<br/>
<strong>124</strong> No se pudo escribir el archivo (ver espacio en disco).<br/>
<strong>125</strong> Se intent&#243; leer un bloque fuera de la memoria.<br/>
<strong>126</strong> No se pudo abrir el archivo para lectura.<br/>
<strong>127</strong> No se pudo leer el archivo.<br/>
<strong>128</strong> No se pudo cargar el efecto de sonido.<br/>
<strong>129</strong> No se pudo tocar el efecto de sonido solicitado.<br/>
<strong>130</strong> No se pudo iniciar la animaci&#243;n solicitada.<br/>
<strong>131</strong> N&#250;mero de modo 7 inv&#225;lido (debe estar entre 0 y 9).<br/>
<strong>132</strong> Se necesita un c&#243;digo de gr&#225;fico para el modo 7.<br/>
<strong>133</strong> N&#250;mero de punto de control inv&#225;lido.<br/>
<strong>134</strong> N&#250;mero de bot&#243;n incorrecto (debe estar entre 0 y 3).<br/>
<strong>135</strong> N&#250;mero de eje incorrecto (debe estar entre 0 y 3).<br/>
<strong>136</strong> Direcci&#243;n de la tabla de paleta fuera de la memoria.<br/>
<strong>137</strong> No se pueden comprobar regiones en gr&#225;ficos de m-7.<br/>
<strong>138</strong> C&#243;digo de informaci&#243;n gr&#225;fica incorrecto.<br/>
<strong>139</strong> No se pueden comprobar colisiones en gr&#225;ficos de m-7.<br/>
<strong>140</strong> Acceso fuera de rango.<br/>
<strong>141</strong> Se intent&#243; acceder a un proceso inv&#225;lido.<br/>
<strong>142</strong> El proceso parece bloqueado, esperando FRAME.<br/>
<strong>143</strong> No se pudo cargar el mapa, archivo no encontrado.<br/>
<strong>144</strong> Se intent&#243; cargar un archivo de mapa inv&#225;lido.<br/>
<strong>145</strong> Se ha intentado hacer una divisi&#243;n entre cero.<br/>
<strong>146</strong> El tama&#241;o de la regi&#243;n es incorrecto.<br/>
<strong>147</strong> No se pudo cargar FLI/FLC, archivo no encontrado.<br/>
<strong>148</strong> Valor de timeout incorrecto (debe ser entre 1 y 60).<br/>
<strong>149</strong> N&#250;mero de jugadores incorrecto (debe ser entre 2 y 8).<br/>
<strong>150</strong> S&#243;lo se pueden enviar datos globales.<br/>
<strong>151</strong> Tama&#241;o de casilla inv&#225;lido (debe ser entre 1 y 256).<br/>
<strong>152</strong> Mapa de b&#250;squeda no v&#225;lido (desde 1x1 hasta 128x128).<br/>
<strong>153</strong> Tama&#241;o de mapa incorrecto (de 1x1 a 32768x32768).<br/>
<strong>154</strong> N&#250;mero de color incorrecto (debe ser de 0 a 255).<br/>
<strong>155</strong> El centro est&#225; fuera de los l&#237;mites del gr&#225;fico.<br/>
<strong>156</strong> El objeto se encuentra fuera del mapa y sera eliminado.<br/>
<strong>157</strong> Textura del mapa no encontrada.<br/>
<strong>158</strong> El tama&#241;o de la textura es incorrecto.<br/>
<strong>159</strong> No se pudo cargar el mundo, archivo no encontrado.<br/>
<strong>160</strong> No se pudo cargar el mundo, archivo no v&#225;lido.<br/>
<strong>161</strong> El n&#250;mero de bandera no es v&#225;lido.<br/>
<strong>162</strong> Dispositivo inv&#225;lido (s&#243;lo 1-IPX,2-SERIAL,3-MODEM).<br/>
<strong>163</strong> Tama&#241;o de paquete inv&#225;lido (s&#243;lo de 1 a 199).<br/>
<strong>164</strong> La cadena de texto destino no es v&#225;lida.<br/>
<strong>165</strong> Se intent&#243; acceder a un puntero nulo.<br/>
<strong>166</strong> El modo de acceso al archivo no es v&#225;lido.<br/>
<strong>167</strong> No se pudo cargar el m&#243;dulo.<br/>
<strong>168</strong> Demasiados errores ignorados.<br/>
<strong>169</strong> Demasiados archivos abiertos.<br/>
<strong>170</strong> Identificador de archivo (handle) no v&#225;lido.<br/>
<strong>171</strong> Valor fuera de rango.<br/>
<strong>172</strong> Demasiados objetos gr&#225;ficos visualizados.<br/>
<strong>173</strong> Tipo de objeto gr&#225;fico no conocido.<br/>
<strong>174</strong> Porcentaje de tinta fuera de rango (0..15).<br/>
<strong>175</strong> N&#250;mero de objeto gr&#225;fico no v&#225;lido.<br/>
<strong>176</strong> Error variable de vpe: Textura de mapa [a] no encontrada en fichero [b].<br/>
<strong>177</strong> Textura de mapa.<br/>
<strong>178</strong> no encontrada en fichero.<br/>
<strong>179</strong> Se realizaron demasiadas peticiones de memoria din&#225;mica.<br/>
<strong>180</strong> El puntero no se corresponde con ninguno de los bloques reservados.<br/>
<strong>181</strong> No se pueden reservar bloques de menos de una posici&#243;n.<br/>
<strong>182</strong> Se intent&#243; (des)encriptar un bloque fuera de la memoria.<br/>
<strong>183</strong> No se puede cargar otra paleta cuando est&#225; forzada la actual.<br/>
<strong>200</strong> Archivo con datos corrompidos, no se pudo cargar.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Mediante las opciones de compilaci&#243;n (ver <a href="#1400">Compiler_options</a>) se pueden ignorar todos los errores de ejecuci&#243;n &quot;no-graves&quot;, no obstante, esta pr&#225;ctica es m&#225;s que poco recomendable.<br/><br/>
<hr/>
Ver: <a href="#1400">Compiler_options</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="241">save_map() / save_pcx()</h2><br/><br/>
<strong>save_map(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;nombre del archivo&gt;<strong>)</strong><br/><br/>
<strong>save_pcx(</strong>&lt;fichero&gt;<strong>,</strong> &lt;gr&#225;fico&gt;<strong>,</strong> &lt;nombre del archivo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
<strong>1</strong> - Si el archivo se grab&#243; con &#233;xito.<br/>
<strong>0</strong> - Se produjo un error al guardar el archivo.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Crea un archivo MAP o PCX a partir de un gr&#225;fico cargado en memoria.<br/><br/>
La funci&#243;n requiere los c&#243;digos de <strong>&lt;fichero&gt;</strong> y <strong>&lt;gr&#225;fico&gt;</strong> que identifican al gr&#225;fico, y el <strong>&lt;nombre del archivo&gt; MAP</strong> o <strong>PCX</strong> que debe crearse en el disco conteniendo dicha imagen. El nombre de archivo se debe especificar como un literal (un texto entre comillas, como &quot;imagen.pcx&quot;).<br/><br/>
Los gr&#225;ficos cargados con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a> (o creados con <a href="#188">new_map()</a>) se utilizar&#225;n como si pertenecieran al primer fichero (el fichero con el c&#243;digo 0).<br/><br/>
La funci&#243;n <strong>save_map()</strong> siempre crear&#225; archivos <strong>MAP</strong>, as&#237; como <strong>save_pcx()</strong> crear&#225; s&#243;lo archivos <strong>PCX</strong>, <strong>independientemente de la extensi&#243;n indicada</strong> en el <strong>&lt;nombre de archivo&gt;</strong>. Si no se produce ning&#250;n error, la funci&#243;n crear&#225; el archivo con la imagen y retornar&#225; <strong>1</strong>.<br/><br/>
<hr/>
<br/><br/>
Estos mapas podr&#225;n despu&#233;s cargarse dentro del entorno gr&#225;fico de DIV Games Studio o en los programas, utilizando las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_save_map;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);

    save_pcx(0,1,&quot;help\help.pcx&quot;); // Crea un archivo PCX

END
</pre>
En este ejemplo utiliza la funci&#243;n <strong>save_pcx()</strong> para crear un archivo PCX conteniendo una imagen previamente cargada dentro del fichero <strong>help.fpg</strong> con la funci&#243;n <a href="#132">load_fpg()</a>.<br/><br/>
<hr/>
<br/><br/>
Se puede crear un gr&#225;fico con la funci&#243;n <a href="#188">new_map()</a>, y para modificar un gr&#225;fico se deben utilizar las siguientes funciones:<br/><br/>
<a href="#135">map_block_copy()</a> - Transfiere un bloque de un gr&#225;fico a otro.<br/>
<a href="#136">map_get_pixel()</a> - Obtiene el color de un punto de un gr&#225;fico.<br/>
<a href="#137">map_put()</a> - Pone un gr&#225;fico en otro.<br/>
<a href="#138">map_put_pixel()</a> - Fija el color de un punto en un gr&#225;fico.<br/>
<a href="#139">map_xput()</a> - Pone un gr&#225;fico en otro, con efectos.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <a href="#253">write_map()</a> permite escribir un texto en un gr&#225;fico creado en memoria (en lugar de escribir en la pantalla).<br/><br/>
<hr/>
Ver: <a href="#174">load_map/pcx()</a> - <a href="#176">unload_map/pcx()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="242">sin()</h2><br/><br/>
<strong>sin(</strong>&lt;&#225;ngulo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El seno de un &#225;ngulo dado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula el seno en mil&#233;simas del &#225;ngulo pasado como par&#225;metro.<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), y el seno se devolver&#225; igualmente en mil&#233;simas (como un valor de -1000 a 1000).<br/><br/>
Por ejemplo, <strong>sin(90000)</strong> devolver&#225; <strong>1000</strong>, ya que el seno de 90 grados es 1.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_sin;

GLOBAL
    &#225;ngulo[15];
    seno[15];
    n;

BEGIN
    write(0,0,0,0,&quot;Angulos&quot;);
    write(0,160,0,0,&quot;Senos&quot;);
    FROM n=0 TO 15;
        &#225;ngulo[n] = rand(0, 360000);

        seno[n] = sin(&#225;ngulo[n]); // Se calcula el seno del &#225;ngulo

        write_int(0, 0,   20+n*10, 0, offset &#225;ngulo[n]);
        write_int(0, 160, 20+n*10, 0, offset seno[n]);
    END
    write(0,0,192,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa imprimir&#225; en pantalla una lista de &#225;ngulos, aleatoriamente escogidos entre 0 y 360000 (de 0 a 360 grados), y utilizar&#225; la funci&#243;n <strong>sin()</strong> para calcular el seno de los mismos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="243">cos()</h2><br/><br/>
<strong>cos(</strong>&lt;&#225;ngulo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El coseno de un &#225;ngulo dado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula el coseno en mil&#233;simas del &#225;ngulo pasado como par&#225;metro.<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), y el coseno se devolver&#225; igualmente en mil&#233;simas (como un valor de -1000 a 1000).<br/><br/>
Por ejemplo, <strong>cos(0)</strong> devolver&#225; <strong>1000</strong>, ya que el coseno de 0 grados es 1.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_cos;

GLOBAL
    &#225;ngulo[15];
    coseno[15];
    n;

BEGIN
    write(0,0,0,0,&quot;Angulos&quot;);
    write(0,160,0,0,&quot;Cosenos&quot;);
    FROM n=0 TO 15;
        &#225;ngulo[n] = rand(0, 360000);

        coseno[n] = cos(&#225;ngulo[n]); // Se calcula el coseno del &#225;ngulo

        write_int(0, 0,   20+n*10, 0, offset &#225;ngulo[n]);
        write_int(0, 160, 20+n*10, 0, offset coseno[n]);
    END
    write(0,0,192,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa imprimir&#225; en pantalla una lista de &#225;ngulos, aleatoriamente escogidos entre 0 y 360000 (de 0 a 360 grados), y utilizar&#225; la funci&#243;n <strong>cos()</strong> para calcular el coseno de los mismos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="244">tan()</h2><br/><br/>
<strong>tan(</strong>&lt;&#225;ngulo&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La tangente de un &#225;ngulo dado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula la tangente en mil&#233;simas del &#225;ngulo pasado como par&#225;metro.<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), y la tangente se devolver&#225; igualmente en mil&#233;simas (como un valor dentro del rango <a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
Por ejemplo, <strong>tan(45000)</strong> devolver&#225; <strong>1000</strong>, ya que la tangente de 45 grados es 1.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_tan;

GLOBAL
    &#225;ngulo[15];
    tangente[15];
    n;

BEGIN
    write(0,0,0,0,&quot;Angulos&quot;);
    write(0,160,0,0,&quot;Tangentes&quot;);
    FROM n=0 TO 15;
        &#225;ngulo[n] = rand(0, 360000);

        tangente[n] = tan(&#225;ngulo[n]); // Se calcula la tangente del &#225;ngulo

        write_int(0, 0,   20+n*10, 0, offset &#225;ngulo[n]);
        write_int(0, 160, 20+n*10, 0, offset tangente[n]);
    END
    write(0,0,192,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa imprimir&#225; en pantalla una lista de &#225;ngulos, aleatoriamente escogidos entre 0 y 360000 (de 0 a 360 grados), y utilizar&#225; la funci&#243;n <strong>tan()</strong> para calcular la tangente de los mismos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="245">asin()</h2><br/><br/>
<strong>asin(</strong>&lt;seno&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El arcoseno de un seno dado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula el arcoseno del seno pasado como par&#225;metro en mil&#233;simas, es decir, se obtiene el &#225;ngulo correspondiente a un seno (operaci&#243;n inversa al seno, que se puede obtener con la funci&#243;n <a href="#242">sin()</a>).<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), por ello el arcoseno se devuelve tambi&#233;n en mil&#233;simas.<br/><br/>
El <strong>&lt;seno&gt;</strong> se requiere como un valor de<strong> -1000</strong> a <strong>1000</strong> (de -1.0 a +1.0), y el resultado se devuelve como un &#225;ngulo entre<strong> -90000</strong> y <strong>90000</strong> (de -90 a +90 grados).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_asin;

GLOBAL
    seno[15];
    &#225;ngulo[15];
    n;

BEGIN
    write(0,0,0,0,&quot;Seno&quot;);
    write(0,160,0,0,&quot;Arcoseno(&#225;ngulo)&quot;);
    FROM n=0 TO 15;
        seno[n] = rand(-1000, 1000);

        &#225;ngulo[n] = asin(seno[n]); // Se calcula el arcoseno de un seno

        write_int(0, 0,   20+n*10, 0, offset seno[n]);
        write_int(0, 160, 20+n*10, 0, offset &#225;ngulo[n]);
    END
    write(0,0,192,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa imprimir&#225; en pantalla una lista de senos, aleatoriamente escogidos entre -1000 y 1000 (se representan en mil&#233;simas), y utilizar&#225; la funci&#243;n <strong>asin()</strong> para calcular el arcoseno de los mismos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="246">acos()</h2><br/><br/>
<strong>acos(</strong>&lt;coseno&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El arcocoseno de un coseno dado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula el arcocoseno del coseno pasado como par&#225;metro en mil&#233;simas, es decir, se obtiene el &#225;ngulo correspondiente a un coseno (operaci&#243;n inversa al coseno, que se puede obtener con la funci&#243;n <a href="#243">cos()</a>).<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), por ello el arcocoseno se devuelve tambi&#233;n en mil&#233;simas.<br/><br/>
El <strong>&lt;coseno&gt;</strong> se requiere como un valor de<strong> -1000</strong> a <strong>1000</strong> (de -1.0 a +1.0), y el resultado se devuelve como un &#225;ngulo entre<strong> 0</strong> y <strong>180000</strong> (de 0 a 180 grados).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_acos;

GLOBAL
    coseno[15];
    &#225;ngulo[15];
    n;

BEGIN
    write(0,0,0,0,&quot;Coseno&quot;);
    write(0,160,0,0,&quot;Arcocoseno(&#225;ngulo)&quot;);
    FROM n=0 TO 15;
        coseno[n] = rand(-1000, 1000);

        &#225;ngulo[n] = acos(coseno[n]); // Se calcula el arcocoseno de un coseno

        write_int(0, 0,   20+n*10, 0, offset coseno[n]);
        write_int(0, 160, 20+n*10, 0, offset &#225;ngulo[n]);
    END
    write(0,0,192,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa imprimir&#225; en pantalla una lista de cosenos, aleatoriamente escogidos entre -1000 y 1000 (se representan en mil&#233;simas), y utilizar&#225; la funci&#243;n <strong>acos()</strong> para calcular el arcocoseno de los mismos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="247">atan()</h2><br/><br/>
<strong>atan(</strong>&lt;tangente&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La arcotangente de una tangente dada.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula la arcotangente de la tangente pasada como par&#225;metro en mil&#233;simas, es decir, se obtiene el &#225;ngulo correspondiente a una tangente (operaci&#243;n inversa a la tangente, que se puede obtener con la funci&#243;n <a href="#244">tan()</a>).<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), por ello la arcotangente se devuelve tambi&#233;n en mil&#233;simas.<br/><br/>
La <strong>&lt;tangente&gt;</strong> se requiere como un valor dentro del rango <a href="#1177">min_int</a> ... <a href="#1178">max_int</a> (de -inf a +inf), y el resultado se devuelve como un &#225;ngulo entre<strong> -90000</strong> y <strong>90000</strong> (de -90 a +90 grados).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Existe otra funci&#243;n para calcular la arcotangente llamada <a href="#248">atan2()</a>, dicha funci&#243;n toma como par&#225;metros <strong>&lt;x&gt;</strong> e <strong>&lt;y&gt;</strong> y devuelve la arcotangente de <strong>y/x</strong> entre -180000 y 180000 (de -180 a 180 grados).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_atan;

GLOBAL
    tangente[15];
    &#225;ngulo[15];
    n;

BEGIN
    write(0,0,0,0,&quot;Tangente&quot;);
    write(0,160,0,0,&quot;Arcotangente(&#225;ngulo)&quot;);
    FROM n=0 TO 15;
        tangente[n] = rand(-1000, 1000);

        &#225;ngulo[n] = atan(tangente[n]); // Se calcula la arcotangente de una tangente

        write_int(0, 0,   20+n*10, 0, offset tangente[n]);
        write_int(0, 160, 20+n*10, 0, offset &#225;ngulo[n]);
    END
    write(0,0,192,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa imprimir&#225; en pantalla una lista de tangentes, aleatoriamente escogidas entre -1000 y 1000 (-1.0 y 1.0), y utilizar&#225; la funci&#243;n <strong>atan()</strong> para calcular la arcotangente de las mismas (entre -45 y 45 grados).<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="248">atan2()</h2><br/><br/>
<strong>atan2(</strong>&lt;x&gt;<strong>,</strong> &lt;y&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
La arcotangente de <strong>&lt;y&gt;</strong>/<strong>&lt;x&gt;</strong>.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Calcula la arcotangente de la tangente obtenida de dividir los dos valores pasados como par&#225;metro (<strong>&lt;y&gt;</strong>/<strong>&lt;x&gt;</strong>), es decir, se obtiene el &#225;ngulo correspondiente a una tangente (operaci&#243;n inversa a la tangente, que se puede obtener con la funci&#243;n <a href="#244">tan()</a>).<br/><br/>
Los &#225;ngulos se manipulan siempre en mil&#233;simas de grado (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>), por ello la arcotangente se devuelve tambi&#233;n en mil&#233;simas como un valor entre<strong> -180000</strong> y <strong>180000</strong> (de -180 a +180 grados).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> Existe otra funci&#243;n para calcular la arcotangente llamada simplemente <a href="#248">atan()</a>, dicha funci&#243;n toma como &#250;nico par&#225;metro la propia tangente y devuelve su arcotangente entre -90000 y 90000 (de -90 a 90 grados).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 2:</strong> Tambi&#233;n se puede encontrar una versi&#243;n de <strong>atan2()</strong>, adaptada a los conceptos geom&#233;tricos m&#225;s simples; se trata de la funci&#243;n denominada <a href="#113">fget_angle()</a> que obtiene directamente el &#225;ngulo entre dos puntos.<br/><br/>
<hr/>
Ver: <a href="#1035">Expresi&#243;n</a> - Ver: <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="249">draw()</h2><br/><br/>
<strong>draw(</strong>&lt;tipo&gt;<strong>,</strong> &lt;color&gt;<strong>,</strong> &lt;opacidad&gt;<strong>,</strong> &lt;regi&#243;n&gt;<strong>,</strong> &lt;x0&gt;<strong>,</strong> &lt;y0&gt;<strong>,</strong> &lt;x1&gt;<strong>,</strong> &lt;y1&gt;<strong>,</strong><strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>identificador de la primitiva gr&#225;fica</strong> pintada.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Se trata de una funci&#243;n gen&#233;rica capaz de representar varias primitivas gr&#225;ficas en pantalla (como l&#237;neas, cajas y c&#237;rculos). Se deben indicar los siguientes par&#225;metros:<br/><br/>
<strong>&lt;tipo&gt;</strong> - Tipo de primitiva, dentro de los siguientes:<br/><br/>
<strong>1</strong> - L&#237;nea recta.<br/>
<strong>2</strong> - Rect&#225;ngulo.<br/>
<strong>3</strong> - Rect&#225;ngulo relleno.<br/>
<strong>4</strong> - Elipse.<br/>
<strong>5</strong> - Elipse rellena.<br/>
<br/><br/>
<strong>&lt;color&gt;</strong> - Color de tinta para la primitiva (de <strong>0</strong> a <strong>255</strong>, como un color de la paleta).<br/><br/>
<strong>&lt;opacidad&gt;</strong> - Nivel de opacidad de la primitiva, de <strong>0</strong> a <strong>15</strong> (para permitir efectos de transparencia).<br/><br/>
<strong>&lt;regi&#243;n&gt;</strong> - N&#250;mero de regi&#243;n (ventana dentro de la pantalla) en la que se debe pintar la primitiva; normalmente este valor ser&#225; <strong>0</strong> para poder imprimir la primitiva en cualquier posici&#243;n de la pantalla. Para definir una regi&#243;n se debe utilizar la funci&#243;n <a href="#106">define_region()</a>.<br/><br/>
<strong>&lt;x0&gt;</strong>, <strong>&lt;y0&gt;</strong> - Punto inicial de la recta, o la esquina superior izquierda de la caja que contiene al rect&#225;ngulo o elipse.<br/><br/>
<strong>&lt;x1&gt;</strong>, <strong>&lt;y1&gt;</strong> - Punto final de la recta, o la esquina inferior derecha de la caja que contiene al rect&#225;ngulo o elipse.<br/><br/>
<hr/>
<br/><br/>
Cuando se pinta una primitiva con <strong>draw()</strong> esta permanecer&#225; fija en pantalla hasta que se mueva con <a href="#251">move_draw()</a>, o se elimine con <a href="#250">delete_draw()</a>.<br/><br/>
El <strong>identificador de la primitiva</strong> devuelto por la funci&#243;n <strong>draw()</strong> ser&#225; necesario para mover o borrar dicha primitiva.<br/><br/>
El sistema de representaci&#243;n de estas primitivas gr&#225;ficas es muy similar al sistema de textos; se pintan con <a href="#171">write()</a> y permanecen hasta que se muevan con <a href="#141">move_text()</a> o se eliminen con <a href="#107">delete_text()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede controlar la prioridad de impresi&#243;n de las primitivas gr&#225;ficas mediante la variable global predefinida <a href="#1418">draw_z</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_draw;

GLOBAL
    contador;
    tipo;
    color;
    opacidad;
    x0,y0;
    x1,y1;

BEGIN
    write(0,0,0,0,&quot;Pulse ESC para terminar ...&quot;);
    REPEAT
        FROM contador=1 TO 10;
            tipo=rand(1,5);
            color=rand(0,255);
            opacidad=rand(0,15);
            x0=rand(0,319);
            y0=rand(0,199);
            x1=rand(0,319);
            y1=rand(0,199);

            // Pinta una primitiva gr&#225;fica

            draw(tipo,color,opacidad,0,x0,y0,x1,y1);

        END
        FRAME;
        delete_draw(all_drawing);
    UNTIL (key(_esc));
END
</pre>
Este programa ejemplo representa en pantalla 10 primitivas gr&#225;ficas cuyas caracter&#237;sticas son seleccionadas al azar mediante la funci&#243;n <a href="#149">rand()</a>, y tras dar una imagen con <a href="#1029">FRAME</a>, las borra con la funci&#243;n <a href="#250">delete_draw()</a>.<br/><br/>
El proceso se repite hasta que se detecta la tecla ESC.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Pueden representarse en pantalla un m&#225;ximo de <strong>256</strong> primitivas gr&#225;ficas simult&#225;neamente.<br/><br/>
<hr/>
Ver: <a href="#251">move_draw()</a> - <a href="#250">delete_draw()</a> - <a href="#1418">draw_z</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="250">delete_draw()</h2><br/><br/>
<strong>delete_draw(</strong>&lt;identificador de la primitiva gr&#225;fica&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Borra una primitiva gr&#225;fica que se ha pintado con la funci&#243;n <a href="#249">draw()</a>, para ello se requiere como par&#225;metro el <strong>&lt;identificador de la primitiva&gt;</strong>, que es el c&#243;digo num&#233;rico que se retorn&#243; al pintarla.<br/><br/>
Si se especifica como par&#225;metro <strong>all_drawing</strong> se borrar&#225;n todas las primitivas gr&#225;ficas representadas en pantalla, es decir, que el <strong>identificador</strong> ser&#225; necesario s&#243;lo en el caso de querer eliminar una primitiva concreta.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_delete_draw;

PRIVATE
    id_draw;
    tipo;
    color;
    opacidad;
    x0,y0;
    x1,y1;

BEGIN
    write(0, 160, 8, 1, &quot;[ENTER] Mostrar una primitiva / [ESPACIO] borrarla&quot;);
    draw(2,127,15,0,0,0,319,199);
    LOOP
        tipo=rand(1,5);
        color=rand(0,255);
        opacidad=rand(0,15);
        x0=rand(0,319);
        y0=rand(0,199);
        x1=rand(0,319);
        y1=rand(0,199);

        id_draw=draw(tipo,color,opacidad,0,x0,y0,x1,y1);

        WHILE (NOT key(_space))
            FRAME;
        END

        delete_draw(id_draw); // Borramos el texto

        WHILE (NOT key(_enter))
            FRAME;
        END
    END
END
</pre>
En el ejemplo anterior, se imprime una primitiva en pantalla, entonces se espera hasta que se pulse la <strong>barra espaciadora</strong>, momento en el que se borra la primitiva y se espera a la tecla <strong>ENTER</strong> antes de volver a repetir el bucle.<br/><br/>
Se puede observar como s&#243;lo se borra la segunda primitiva, cuyo identificador se ha guardado en la variable <strong>id_draw</strong> (la primera es el rect&#225;ngulo que abarca toda la pantalla y se pinta con la primera llamada a <a href="#249">draw()</a> del programa).<br/><br/>
Para borrar todas las primitivas se deber&#237;a haber llamado a la funci&#243;n como <strong>delete_draw(all_drawing);</strong>, lo que tambi&#233;n habr&#237;a eliminado al rect&#225;ngulo.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Con la funci&#243;n <a href="#251">move_draw()</a> se pueden modificar las caracter&#237;sticas de una primitiva gr&#225;fica presente en pantalla (posici&#243;n, color, opacidad y tama&#241;o).<br/><br/>
<hr/>
Ver: <a href="#249">draw()</a> - <a href="#251">move_draw()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="251">move_draw()</h2><br/><br/>
<strong>move_draw(</strong>&lt;identificador de la primitiva&gt;<strong>,</strong> &lt;color&gt;<strong>,</strong> &lt;opacidad&gt;<strong>,</strong> &lt;x0&gt;<strong>,</strong> &lt;y0&gt;<strong>,</strong> &lt;x1&gt;<strong>,</strong> &lt;y1&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Modifica una primitiva gr&#225;fica que se ha pintado con la funci&#243;n <a href="#249">draw()</a>, para ello se requieren los siguientes par&#225;metros:<br/><br/>
<strong>&lt;identificador de la primitiva&gt;</strong> - Es el c&#243;digo num&#233;rico que devolvi&#243; la funci&#243;n <a href="#249">draw()</a> cuando se pint&#243; la primitiva que ahora se prentende modificar.<br/><br/>
<strong>&lt;color&gt;</strong> - Color de tinta para la primitiva (de <strong>0</strong> a <strong>255</strong>, como un color de la paleta).<br/><br/>
<strong>&lt;opacidad&gt;</strong> - Nivel de opacidad de la primitiva, de <strong>0</strong> a <strong>15</strong> (para permitir efectos de transparencia).<br/><br/>
<strong>&lt;x0&gt;</strong>, <strong>&lt;y0&gt;</strong> - Punto inicial de la recta, o la esquina superior izquierda de la caja que contiene al rect&#225;ngulo o elipse.<br/><br/>
<strong>&lt;x1&gt;</strong>, <strong>&lt;y1&gt;</strong> - Punto final de la recta, o la esquina inferior derecha de la caja que contiene al rect&#225;ngulo o elipse. y las coordenadas (<strong>x</strong>, <strong>y</strong>) de pantalla a las que se debe mover.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_move_draw;

PRIVATE
    id_draw;
    color;
    opacidad;

BEGIN
    write(0, 0, 0, 0, &quot;Mueva el rat&#243;n ...&quot;);
    id_draw=draw(4, 127, 15, 0, 0, 0, 32, 32);
    LOOP
        color=rand(0,255);
        opacidad=rand(0,15);

        // Se mueve la primitiva gr&#225;fica a las coordenadas del rat&#243;n

        move_draw(id_draw, color, opacidad, mouse.x-16, mouse.y-16, mouse.x+16, mouse.y+16);

        FRAME;
    END
END
</pre>
En el ejemplo se pinta, con la funci&#243;n <a href="#249">draw()</a>, una primitiva gr&#225;fica circular, y se guarda su <strong>identificador de primitiva gr&#225;fica</strong> en la variable global <strong>id_draw</strong>.<br/><br/>
Entonces es cuando, dentro de un bucle, se utilizar&#225; la funci&#243;n <strong>move_draw()</strong> para situar dicho c&#237;rculo en las coordenadas del rat&#243;n, y asignarle un color y opacidad escogidos al azar en cada imagen.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para eliminar (borrar) una primitiva gr&#225;fica se utiliza la funci&#243;n <a href="#250">delete_draw()</a>, y con la variable global predefinida <a href="#1418">draw_z</a> se puede controlar la prioridad de impresi&#243;n de las mismas.<br/><br/>
<hr/>
Ver: <a href="#249">draw()</a> - <a href="#250">delete_draw()</a> - <a href="#1418">draw_z</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="253">write_in_map()</h2><br/><br/>
<strong>write_in_map(</strong>&lt;fuente&gt;<strong>,</strong> &lt;texto&gt;<strong>,</strong> &lt;c&#243;digo de centrado&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>c&#243;digo del gr&#225;fico</strong> creado conteniendo al texto.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Crea un nuevo mapa en memoria (sin cargarlo de un archivo del disco, al igual que la funci&#243;n <a href="#188">new_map()</a>) y escribe en el mismo un texto cuyas caracter&#237;sticas se describen con los siguientes par&#225;metros:<br/><br/>
<strong>&lt;fuente&gt;</strong> - El <strong>c&#243;digo de la fuente</strong> o <strong>tipo de letra</strong> que se va a utilizar. Aqu&#237; se debe poner un 0 cuando se quiera utilizar la fuente del sistema (fuente de color blanco, peque&#241;a, de 6 por 8 puntos), o bien el <strong>c&#243;digo de fuente</strong> devuelto por la funci&#243;n <a href="#131">load_fnt()</a> cuando se carga una nueva fuente en el programa.<br/><br/>
<strong>&lt;texto&gt;</strong> - En segundo lugar se especificar&#225; texto a escribir como un literal, es decir, un texto entre comillas (ver los <a href="#1047">s&#237;mbolos delimitadores de literales</a>).<br/><br/>
<strong>&lt;c&#243;digo de centrado&gt;</strong> - Es un c&#243;digo que determina la posici&#243;n del texto en la que situar&#225; el <strong>centro</strong> o <a href="#1136">punto de control</a> del mapa creado. Sus posibles valores son:<br/><br/>
<strong>0</strong>-Arriba izquierda <strong>1</strong>-Arriba <strong>2</strong>-Arriba derecha<br/>
<strong>3</strong>-Izquierda        <strong>4</strong>-Centro <strong>5</strong>-Derecha<br/>
<strong>6</strong>-Abajo izquierda  <strong>7</strong>-Abajo  <strong>8</strong>-Abajo derecha<br/>
<br/><br/>
El texto siempre estar&#225; encajado en un mapa nuevo de sus mismas dimensiones, pero este <a href="#1136">punto de control</a> especificar&#225; que punto de dicho mapa se centrar&#225; en las coordenadas en las que posteriormente se sit&#250;e el mismo.<br/><br/>
<hr/>
<br/><br/>
Esta funci&#243;n se comporta practicam&#233;nte igual que <a href="#174">load_map()</a>, salvo que no se lee un archivo en disco con el gr&#225;fico, sino que se crea como un gr&#225;fico que contiene un mensaje escrito con una fuente de letras determinada.<br/><br/>
Se devuelve como valor de retorno el <strong>c&#243;digo del gr&#225;fico</strong>, que es un valor num&#233;rico que debe especificarse para utilizar el gr&#225;fico, en la variable <a href="#1126">graph</a> o, en general, en todas las funciones que requieran un <strong>c&#243;digo de gr&#225;fico</strong> entre sus par&#225;metros.<br/><br/>
Cuando se requiera dentro de una funci&#243;n el <strong>c&#243;digo de fichero</strong> al que pertenece dicho gr&#225;fico, se debe indicar el c&#243;digo <strong>0</strong> (que es el c&#243;digo del primer <strong>fichero FPG</strong> que se cargue en el programa).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_write_in_map;

GLOBAL
    mi_fuente;

BEGIN
    mi_fuente=load_fnt(&quot;help\help.fnt&quot;);

    // Se crea un mapa nuevo con el texto &quot;MOUSE&quot;
    // con el punto de control en el centro, y se
    // asigna como gr&#225;fico del puntero del rat&#243;n.

    mouse.graph = write_in_map(mi_fuente,&quot;MOUSE&quot;,4);

    REPEAT
        FRAME;
    UNTIL (key(_esc));
    unload_map(mouse.graph);
END
</pre>
En el ejemplo se carga una fuente de letras con la funci&#243;n <a href="#131">load_fnt()</a>, y entonces se crea un mapa con la funci&#243;n <strong>write_in_map()</strong> guardando el <strong>c&#243;digo del gr&#225;fico</strong> que retorna en la variable <a href="#1100">mouse.graph</a>, de forma que aparezca como puntero del rat&#243;n.<br/><br/>
El nuevo mapa se crea con el mensaje <strong>&quot;MOUSE&quot;</strong> escrito con la fuente <strong>help.fnt</strong>, y su <a href="#1136">punto de control</a> principal se sit&#250;a en el centro (con el c&#243;digo <strong>4</strong>).<br/><br/>
Pulsando la tecla <strong>ESC</strong> se saldr&#225; del bucle de visualizaci&#243;n del programa y se descargar&#225; el gr&#225;fico con la funci&#243;n <a href="#176">unload_map()</a> (exactamente igual que si se hubiera cargado de un archivo del disco).<br/><br/>
No obstante, <strong>no es necesario descargar el gr&#225;fico de memoria</strong> antes de finalizar el programa, ya que el sistema lo har&#225; de forma autom&#225;tica.<br/><br/>
<hr/>
<br/><br/>
La principal ventaja que proporciona la funci&#243;n <strong>write_in_map()</strong> es el poder tratar los textos como si se tratara de gr&#225;ficos, con lo que se podr&#225;n rotar, escalar, imprimir con transparencia, etc.<br/><br/>
<strong>Nota:</strong> Para que <strong>write_in_map()</strong> pueda mostrar un valor num&#233;rico se debe utilizar la funci&#243;n <a href="#255">itoa()</a>, que permite convertir un valor num&#233;rico en una cadena de texto.<br/><br/>
<hr/>
Ver: <a href="#171">write()</a> - <a href="#176">unload_map/pcx()</a> - <a href="#1126">graph</a> - <a href="#255">itoa()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="254">calculate()</h2><br/><br/>
<strong>calculate(</strong>&lt;texto con una expresi&#243;n num&#233;rica&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El resultado de la expresi&#243;n num&#233;rica.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Permite convertir un literal (o texto entre comillas), que contenga un n&#250;mero o expresi&#243;n num&#233;rica, en un valor constante que puede asignarse a cualquier dato.<br/><br/>
Es decir, que permite convertir un texto en n&#250;mero; por ejemplo, la sentencia <strong>x=calculate(&quot;234&quot;);</strong> asignar&#225; el valor <strong>234</strong> a la variable <strong>x</strong> (exactamente igual que la sentencia <strong>x=234;</strong>). La funci&#243;n <a href="#255">itoa()</a> permite la operaci&#243;n contraria, es decir, convertir un n&#250;mero en un texto.<br/><br/>
Pero adem&#225;s, la funci&#243;n <strong>calculate()</strong> puede evaluar una expresi&#243;n contenida en el texto con diversos operadores, que pueden ser los siguientes (se indican todos los sin&#243;nimos aceptados de cada operador):<br/><br/>
<strong> + -</strong>      Suma y Resta.<br/>
<strong> * /</strong>      Multiplicaci&#243;n y divisi&#243;n.<br/>
<strong> % MOD</strong>    M&#243;dulo, o resto de una divisi&#243;n entera.<br/>
<strong> &lt; &lt;&lt;</strong>     Rotaci&#243;n binaria a la izquierda.<br/>
<strong> &gt; &gt;&gt;</strong>     Rotaci&#243;n a la derecha.<br/>
<strong> ^ ^^ XOR</strong> OR exclusivo binario.<br/>
<strong> | || OR</strong>  OR binario.<br/>
<strong> &amp; &amp;&amp; AND</strong> AND binario.<br/>
<strong> ! NOT</strong>    Negaci&#243;n binaria.<br/>
<strong> SQRT</strong>     Raiz cuadrada.<br/>
<br/><br/>
Tambi&#233;n se pueden utilizar los par&#233;ntesis <strong>( )</strong> para indicar prioridades dentro del c&#225;lculo de la expresi&#243;n. Por ejemplo, <strong>calculate(</strong>&quot;(2+3)*4&quot;<strong>)</strong> devolver&#237;a <strong>20</strong> como resultado.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La operatividad de esta funci&#243;n es muy similar a la ventana de la <a href="#1301">calculadora</a> (<strong>Sistema\Calculadora</strong>) del entorno de ventanas.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_calculate;

GLOBAL
    STRING c&#225;lculo;
    resultado;

BEGIN
    write(0,0,0,0,&quot;Introduzca una expresi&#243;n:&quot;);
    write(0,0,10,0,c&#225;lculo);
    write(0,0,30,0,&quot;Resultado:&quot;);
    write_int(0,0,40,0,OFFSET resultado);
    LOOP
        SWITCH(ascii)
            CASE 8:
                c&#225;lculo--;
            END
            CASE 27:
                c&#225;lculo=&quot;&quot;;
            END
            CASE 0..31:
            END
            DEFAULT:
                c&#225;lculo+=ascii;
            END
        END

        resultado = calculate(c&#225;lculo); // Eval&#250;a el c&#225;lculo

        IF (timer MOD 100&gt;50)
            c&#225;lculo+=&quot;_&quot;;
        ELSE
            c&#225;lculo+=&quot; &quot;;
        END
        FRAME;
        c&#225;lculo--;
    END
END
</pre>
Este programa ejemplo permite al usuario introducir una expresi&#243;n en una cadena de texto (ver <a href="#1406">STRING</a>) y la eval&#250;a con la funci&#243;n <strong>calculate()</strong> para mostrar el resultado de la misma.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Si se produce un error en la evaluaci&#243;n de la expresi&#243;n (por ejemplo, que exista alg&#250;n par&#233;ntesis sin cerrar), la funci&#243;n devolver&#225; <strong>0</strong> como resultado.<br/><br/>
<hr/>
Ver: <a href="#255">itoa()</a> - <a href="#171">write()</a> - <a href="#1406">STRING</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="255">itoa()</h2><br/><br/>
<strong>itoa(</strong>&lt;expresi&#243;n&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
Una cadena de texto conteniendo el resutado.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n se utiliza para convertir un valor num&#233;rico o <strong>&lt;expresi&#243;n&gt;</strong> en una cadena de texto, es decir, que permite convertir un n&#250;mero en un texto. La cadena contendr&#225; tantos car&#225;cteres como d&#237;gitos tenga el resultado.<br/><br/>
La funci&#243;n <a href="#254">calculate()</a> permite la operaci&#243;n contraria; convertir un literal o cadena de texto en un valor num&#233;rico.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_itoa;

GLOBAL
    STRING mensaje;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    mouse.graph=200;
    write(0,0,0,0,mensaje);
    REPEAT

        // Compone un mensaje con texto y n&#250;meros utilizando itoa()

        mensaje = &quot;Cursor del rat&#243;n en (&quot; + itoa(mouse.x) +
                  &quot;,&quot; + itoa(mouse.y) + &quot;).&quot;;

        FRAME;
    UNTIL (key(_esc));
END
</pre>
Este programa ejemplo compone en una cadena de texto denominada <strong>mensaje</strong> (ver <a href="#1406">STRING</a>) letras y valores num&#233;ricos (las coordenadas del rat&#243;n, ver <a href="#1100">mouse</a>), y lo representa en pantalla con la funci&#243;n <a href="#171">write()</a>.<br/><br/>
El programa carga el archivo <strong>help.fpg</strong> con <a href="#132">load_fpg()</a> y asigna el gr&#225;fico <strong>200</strong> como cursor del rat&#243;n. El programa continuar&#225; hasta que se detecte la pulsaci&#243;n de la tecla <strong>ESC</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El nombre de la funci&#243;n <strong>itoa()</strong>, hom&#243;nima del lenguaje C, viene de la expresi&#243;n &quot;integer to ascii&quot;, del ingl&#233;s. Y la funci&#243;n que realiza la operaci&#243;n contraria, &quot;ascii to integer&quot; es <a href="#254">calculate()</a>.<br/><br/>
<hr/>
Ver: <a href="#254">calculate()</a> - <a href="#1035">Expresiones aritm&#233;ticas</a> - <a href="#171">write()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="256">change_channel()</h2><br/><br/>
<strong>change_channel(</strong>&lt;canal&gt;<strong>,</strong> &lt;volumen&gt;<strong>,</strong> &lt;balance&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Se trata de una funci&#243;n complementaria a <a href="#102">change_sound()</a>, que modifica las propiedades de uno de los canales de sonido que reproducen los efectos digitales (ver <a href="#159">sound()</a>) o m&#243;dulos musicales (ver <a href="#216">song()</a>).<br/><br/>
Se debe indicar el n&#250;mero de <strong>&lt;canal&gt;</strong> que quiere ajustarse, (normalmente el n&#250;mero de canal devuelto por la funci&#243;n <a href="#159">sound()</a>), y los siguientes dos valores:<br/><br/>
<strong>&lt;volumen&gt;</strong> - Se trata del volumen propio del canal, entre <strong>0</strong> y <strong>512</strong>, independiente del volumen del propio sonido y del volumen general.<br/><br/>
Cuando los volumenes de los diferentes canales son demasiado altos se producen efectos de distorsi&#243;n, por ello se recomienda modificar el volumen de los efectos de sonido mediante la funci&#243;n <a href="#102">change_sound()</a> que, adem&#225;s, permite ajustar la frecuencia de los mismos.<br/><br/>
<strong>&lt;balance&gt;</strong> - Es el &quot;panning&quot; o diferencia de volumen entre el atavoz izquierdo y derecho, debe ser un valor entre <strong>0</strong> y <strong>255</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Los niveles generales de volumen se pueden ajustar mediante la estructura global <a href="#1104">setup</a> (sonido digital, cd-audio y volumen general).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_change_channel;

PRIVATE
    balance=128;     // Valor medio (0..256)

    id_sonido;
    canal;

BEGIN
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);

    id_sonido = load_pcm(&quot;help\help.pcm&quot;, 1);
    canal = sound(id_sonido, 256, 256);

    write(0, 160, 0, 1, &quot;Presione derecha o izquierda para cambiar el balance.&quot;);
    write_int(0, 160, 10, 1, offset balance);
    LOOP

        // Cambia el balance del canal

        change_channel(canal, 50, balance);

        IF (key(_right) AND balance&lt;255) balance++; END
        IF (key(_left) AND balance&gt;0) balance--; END
        FRAME;
    END

END
</pre>
En el ejemplo se carga y se emite un sonido (contenido en el archivo <strong>help.pcm</strong>). Dentro del bucle principal del programa se puede cambiar el balance del canal por el que est&#225; sonando dicho sonido con la funci&#243;n <strong>change_channel()</strong>, utilizando las teclas de los cursores.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Ver tambi&#233;n la tabla global predefinida <a href="#1416">channel</a>, que indica cuales de los canales de sonido est&#225;n siendo utilizados.<br/><br/>
<hr/>
Ver: <a href="#102">change_sound()</a> - <a href="#159">sound()</a> - <a href="#216">song()</a> <a href="#1104">STRUCT setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="257">malloc()</h2><br/><br/>
<strong>malloc(</strong>&lt;longitud&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>OFFSET</strong> del bloque de memoria solicitado, o <strong>0</strong> si la memoria disponible no es sufuciente.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Esta funci&#243;n asigna memoria din&#225;mica, es decir, se solicita un nuevo bloque de memoria libre del ordenador para el programa.<br/><br/>
Se requiere como par&#225;metro la <strong>&lt;longitud&gt;</strong> del bloque de memoria que desea ocuparse. Esta longitud se especifica como un n&#250;mero de datos simples, ocupando cada uno de ellos 4 bytes; por ejemplo, si se solicita un bloque de longitud <strong>100</strong> se reservar&#225;n 400 bytes de memoria.<br/><br/>
Dentro de un programa pueden solicitarse un m&#225;ximo de <strong>256 bloques</strong>, independientemente de su tama&#241;o. La funci&#243;n <a href="#258">free()</a> permite liberar estos bloques de memoria.<br/><br/>
<hr/>
<br/><br/>
Normalmente el <strong>OFFSET</strong> (direcci&#243;n de memoria) retornado por la funci&#243;n <strong>malloc()</strong> se asigna a un dato de tipo puntero (ver <a href="#1405">POINTER</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_malloc;

GLOBAL
    POINTER mitabla[1000];  // Puntero a una tabla de 1000 datos

BEGIN

    mitabla = malloc(1000); // Solicita 1000 posiciones de memoria

    FOR (contador=0;contador&lt;1000;contador++) // Accede a los datos
        mitabla[contador]=-1;
    END

    free(mitabla);          // Libera la memoria ocupada por la tabla
END
</pre>
Este peque&#241;o ejemplo muestra como se puede definir un puntero a una tabla (con el puntero no se reserva espacio para los datos de la tabla), y como solicitar memoria para esta con la funci&#243;n <strong>malloc()</strong>.<br/><br/>
Una vez solicitada la memoria para la tabla de datos se accede a los mismos (se inicializan a -1, como un ejemplo), y se libera la memoria.<br/><br/>
Los bloques de memoria que no se liberen con la funci&#243;n <a href="#258">free()</a>, ser&#225;n liberados autom&#225;ticamente por el sistema al finalizar el programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La cantidad de memoria disponible para los datos de los procesos del programa (datos locales y privados) se puede controlar mediante las opciones de compilaci&#243;n (ver <a href="#1400">Compiler_options</a>).<br/><br/>
<hr/>
Ver: <a href="#258">free()</a> - <a href="#1405">POINTER</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="258">free()</h2><br/><br/>
<strong>free(</strong>&lt;OFFSET del bloque de memoria&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Libera un bloque de memoria din&#225;mica que ha sido reservado anteriormente con la funci&#243;n <a href="#257">malloc()</a><br/><br/>
Se requiere como par&#225;metro el <strong>OFFSET</strong> o direcci&#243;n de memoria en la que comienza el bloque, que es el valor que se obtiene al reservarlo.<br/><br/>
Los bloques de memoria que no se liberen con la funci&#243;n <strong>free()</strong>, ser&#225;n liberados autom&#225;ticamente por el sistema al finalizar el programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_free;

GLOBAL
    POINTER mitabla[1000];  // Puntero a una tabla de 1000 datos

BEGIN

    mitabla = malloc(1000); // Solicita 1000 posiciones de memoria

    FOR (contador=0;contador&lt;1000;contador++) // Accede a los datos
        mitabla[contador]=-1;
    END

    free(mitabla);          // Libera la memoria ocupada por la tabla
END
</pre>
Este peque&#241;o ejemplo muestra como se puede definir un puntero a una tabla (con el puntero no se reserva espacio para los datos de la tabla), y como solicitar memoria para esta con la funci&#243;n <a href="#257">malloc()</a>.<br/><br/>
Una vez solicitada la memoria para la tabla de datos se accede a los mismos (se inicializan a -1, como un ejemplo), y se libera la memoria.<br/><br/>
<hr/>
Ver: <a href="#248">free()</a> - <a href="#1405">POINTER</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="259">encode()</h2><br/><br/>
<strong>encode(</strong>&lt;OFFSET de los datos&gt;<strong>,</strong> &lt;longitud&gt;<strong>,</strong> &lt;clave&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Encripta o desencripta un bloque de datos en memoria con una clave determinada. Los par&#225;metros necesarios son los siguientes:<br/><br/>
<strong>&lt;OFFSET de los datos&gt;</strong> - Direcci&#243;n de memoria en la que comienza el bloque que debe comprimirse, para obtener la esta direcci&#243;n se debe utilizar el operador <a href="#1085">OFFSET</a>.<br/><br/>
<strong>&lt;longitud&gt;</strong> - Longitud de los datos a comprimir, es decir, el n&#250;mero de posiciones de memoria ocupadas por los mismos, la longitud de cualquier dato se puede obtener con <a href="#1094">SIZEOF()</a>.<br/><br/>
<strong>&lt;clave&gt;</strong> - Un literal (texto entre comillas) con la clave de encriptaci&#243;n o desencriptaci&#243;n de los datos.<br/><br/>
El algoritmo es reversible por lo que, para desencriptar los datos, simplemente se tienen que volver a encriptar con la misma clave.<br/><br/>
El algoritmo de encriptaci&#243;n es muy complejo, por lo que cualquier dato encriptado con una clave &#250;nicamente se podr&#225; recuperar aplic&#225;ndole la misma clave de nuevo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_encode;

CONST
    clave=&quot;miclave&quot;;

GLOBAL
    tabla_original[14]  =0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;
    tabla_encriptada[14]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;
    contador;

BEGIN
    write(0,0,  0,0,&quot;Valores originales&quot;);
    write(0,160,0,0,&quot;Valores encriptados&quot;);
    write(0,0,190,0,&quot;[ESPACIO] para encriptar/desencriptar los valores&quot;);

    // Encripta los valores de la segunda tabla

    encode(OFFSET tabla_encriptada,sizeof(tabla_encriptada),clave);

    FOR (contador=0;contador&lt;15;contador++)
        write_int(0,0,  20+contador*8,0,OFFSET tabla_original[contador]);
        write_int(0,160,20+contador*8,0,OFFSET tabla_encriptada[contador]);
    END

    LOOP
        IF (scan_code==_space)

            // Encripta y desencripta los valores de la segunda tabla

            encode(OFFSET tabla_encriptada,sizeof(tabla_encriptada),clave);

        END
        FRAME;
    END
END
</pre>
Este programa tiene definidas dos tablas de datos globales, ambas con los mismos valores y permite, pulsando la <strong>barra espaciadora</strong>, encriptar y desencriptar una de las dos tablas (la denominada <strong>tabla_encriptada[]</strong>).<br/><br/>
Se puede observar como, al encriptar por segunda vez los datos, se recuperan en su estado original. Si se utiliza una clave distinta, el resultado ser&#225; totalmente diferente.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Existen otras dos funciones que permiten encriptar y desencriptar archivos de cualquier tipo, en este caso se debe utilizar una funci&#243;n para cada operaci&#243;n: <a href="#260">encode_file()</a> para encriptar y <a href="#261">decode_file()</a> para desencriptar.<br/><br/>
<hr/>
Ver: <a href="#260">encode_file()</a> - <a href="#261">decode_file()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="260">encode_file()</h2><br/><br/>
<strong>encode_file(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;clave&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Encripta uno o varios archivos del disco con una clave determinada. Los par&#225;metros necesarios son los siguientes:<br/><br/>
<strong>&lt;nombre de archivo&gt;</strong> - Descripci&#243;n del archivo que debe encriptarse, un literal (texto entre comillas) con el nombre del mismo. Pueden utilizarse los car&#225;cteres comod&#237;n &quot;?&quot; y &quot;*&quot; para especificar varios archivos (por ejemplo, &quot;*.BAK&quot; para encriptar todos los archivos con extensi&#243;n BAK).<br/><br/>
<strong>&lt;clave&gt;</strong> - Otro literal con la clave de encriptaci&#243;n del archivo o archivos.<br/><br/>
El algoritmo de encriptaci&#243;n es muy complejo, por lo que cualquier archivo encriptado con una clave &#250;nicamente se podr&#225; recuperar aplic&#225;ndole la misma mediante la funci&#243;n <a href="#261">decode_file()</a>. De no realizarse dicha operaci&#243;n, el archivo resultante ser&#225; totalmente in&#250;til, siendo imposible recuperar los datos contenidos en &#233;l.<br/><br/>
No podr&#225;n encriptarse por segunda vez los archivos que ya est&#225;n encriptados.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_encode_file;

CONST
    clave=&quot;miclave&quot;;

GLOBAL
    mitabla[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;

BEGIN
    save(&quot;help\help.enc&quot;,OFFSET mitabla,sizeof(mitabla));

    encode_file(&quot;help\help.enc&quot;,clave); // Encripta el archivo
END
</pre>
Este peque&#241;o programa utiliza la funci&#243;n <a href="#155">save()</a> para crear un archivo llamado <strong>help.enc</strong> con los datos contenidos en <strong>mitabla</strong>, y entonces lo encripta con la funci&#243;n <strong>encode_file()</strong>.<br/><br/>
Puede observarse como el contenido del archivo creado (dentro del directorio <strong>help\</strong>) no guarda ninguna relaci&#243;n con los datos originales (sea cual sea la clave de encriptaci&#243;n).<br/><br/>
<hr/>
<br/><br/>
Existe otra funci&#243;n denominada <a href="#259">encode()</a> que permite encriptar y desencriptar datos en memoria, en este caso la operaci&#243;n es reversible, por lo que se utiliza la misma funci&#243;n para ambas operaciones.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las funciones <a href="#262">compress_file()</a> y <a href="#263">uncompress_file()</a> permiten comprimir y descomprimir archivos del disco. Los archivos encriptados <strong>no podr&#225;n comprimirse</strong> con dichas funciones (debido a que su contenido es completamente aleatorio).<br/><br/>
<hr/>
Ver: <a href="#259">encode()</a> - <a href="#261">decode_file()</a> - <a href="#262">compress_file()</a> - <a href="#263">uncompress_file()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="261">decode_file()</h2><br/><br/>
<strong>decode_file(</strong>&lt;nombre de archivo&gt;<strong>,</strong> &lt;clave&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Desencripta uno o varios archivos del disco, con la misma clave con la que fueron encriptados con la funci&#243;n <a href="#260">encode_file()</a>. Los par&#225;metros necesarios son los siguientes:<br/><br/>
<strong>&lt;nombre de archivo&gt;</strong> - Descripci&#243;n del archivo que debe desencriptarse, un literal (texto entre comillas) con el nombre del mismo. Pueden utilizarse los car&#225;cteres comod&#237;n &quot;?&quot; y &quot;*&quot; para especificar varios archivos (por ejemplo, &quot;*.BAK&quot; para desencriptar todos los archivos con extensi&#243;n BAK).<br/><br/>
<strong>&lt;clave&gt;</strong> - Otro literal con la clave de desencriptaci&#243;n del archivo o archivos. Esta clave debe ser <strong>exacta</strong> a la clave con la que fueron encriptados originalmente los archivos, si <strong>se desencriptan con una clave diferente los archivos quedar&#225;n inservibles</strong>.<br/><br/>
No podr&#225;n desencriptarse los archivos que no est&#225;n encriptados.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_decode_file;

CONST
    clave=&quot;miclave&quot;;

GLOBAL
    mitabla[]=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14;

BEGIN
    save(&quot;help\help.enc&quot;,OFFSET mitabla,sizeof(mitabla));
    encode_file(&quot;help\help.enc&quot;,clave);
    // ...

    decode_file(&quot;help\help.enc&quot;,clave); // Desencripta el archivo

END
</pre>
Este peque&#241;o programa utiliza la funci&#243;n <a href="#155">save()</a> para crear un archivo llamado <strong>help.enc</strong> con los datos contenidos en <strong>mitabla</strong>, y lo encripta con la funci&#243;n <strong>encode_file()</strong>.<br/><br/>
Antes de finalizar el programa, se vuelve a recuperar el contenido del archivo al desencriptarlo con la funci&#243;n <strong>decode_file()</strong>. El archivo quedar&#225; finalmente con los datos contenidos en <strong>mitabla</strong>, en su forma original.<br/><br/>
<hr/>
<br/><br/>
Existe otra funci&#243;n denominada <a href="#259">encode()</a> que permite encriptar y desencriptar datos en memoria, en este caso la operaci&#243;n es reversible, por lo que se utiliza la misma funci&#243;n para ambas operaciones.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las funciones <a href="#262">compress_file()</a> y <a href="#263">uncompress_file()</a> permiten comprimir y descomprimir archivos del disco. Los archivos encriptados <strong>no podr&#225;n comprimirse</strong> con dichas funciones (debido a que su contenido es completamente aleatorio).<br/><br/>
<hr/>
Ver: <a href="#260">encode_file()</a> - <a href="#259">encode()</a> - <a href="#262">compress_file()</a> - <a href="#263">uncompress_file()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="262">compress_file()</h2><br/><br/>
<strong>compress_file(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Comprime uno o varios archivos del disco, como &#250;nico par&#225;metro se requiere el <strong>&lt;nombre de archivo&gt;</strong> que debe comprimirse, como un literal (texto entre comillas). Pueden utilizarse los car&#225;cteres comod&#237;n &quot;?&quot; y &quot;*&quot; para especificar varios archivos (por ejemplo, &quot;*.BAK&quot; para comprimir todos los archivos con extensi&#243;n BAK).<br/><br/>
Para descomprimir estos archivos se debe utilizar la funci&#243;n <a href="#263">uncompress_file()</a>. El formato de archivo encriptado es un formato propio de DIV Games Studio, por lo que no se podr&#225;n descomprimir con ninguna utilidad externa.<br/><br/>
El archivo se guarda comprimido con el mismo nombre y extensi&#243;n que ten&#237;a el original. No se podr&#225;n comprimir por segunda vez los archivos que ya est&#225;n comprimidos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_compress_file;

GLOBAL
    contador;
    mitabla[999];

BEGIN
    FOR (contador=0;contador&lt;1000;contador++)
        mitabla[contador]=contador;
    END

    save(&quot;help\help.cmp&quot;,OFFSET mitabla,sizeof(mitabla));

    compress_file(&quot;help\help.cmp&quot;); // Comprime el archivo
END
</pre>
Este peque&#241;o programa utiliza la funci&#243;n <a href="#155">save()</a> para crear un archivo llamado <strong>help.cmp</strong> con los datos contenidos en <strong>mitabla</strong>, siendo estos una serie de n&#250;meros consecutivos del 0 al 1000.<br/><br/>
Una vez creado el archivo, se comprime con la funci&#243;n <strong>compress_file()</strong>.<br/><br/>
En este caso, el tama&#241;o original del archivo es de 4000 bytes (1000 datos), y el tama&#241;o del archivo comprimido es de 1441 bytes (un 36% del tama&#241;o original).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las funciones <a href="#260">encode_file()</a> y <a href="#261">decode_file()</a> permiten encriptar y desencriptar archivos del disco.<br/><br/>
Los archivos encriptados generados con estas funciones <strong>no podr&#225;n comprimirse</strong> debido a que su contenido es completamente aleatorio. No obstante, <strong>los archivos comprimidos si que pueden encriptarse</strong>.<br/><br/>
<hr/>
Ver: <a href="#263">uncompress_file()</a> - <a href="#260">encode_file()</a> - <a href="#261">decode_file()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="263">uncompress_file()</h2><br/><br/>
<strong>uncompress_file(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Descomprime uno o varios archivos del disco que hubieran sido anteriormente comprimidos con la funci&#243;n <a href="#262">compress_file()</a>, como &#250;nico par&#225;metro se requiere el <strong>&lt;nombre de archivo&gt;</strong> que debe descomprimirse, como un literal (texto entre comillas). Pueden utilizarse los car&#225;cteres comod&#237;n &quot;?&quot; y &quot;*&quot; para especificar varios archivos (por ejemplo, &quot;*.BAK&quot; para descomprimir todos los archivos con extensi&#243;n BAK).<br/><br/>
El formato de archivo encriptado es un formato propio de DIV Games Studio, por lo que no se podr&#225;n descomprimir con ninguna utilidad externa.<br/><br/>
El archivo se descomprime con el mismo nombre y extensi&#243;n que ten&#237;a comprimido. No se podr&#225;n descomprimir archivos que no est&#225;n comprimidos con la funci&#243;n <a href="#262">compress_file()</a> del lenguaje.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_uncompress_file;

GLOBAL
    contador;
    mitabla[999];

BEGIN
    FOR (contador=0;contador&lt;1000;contador++)
        mitabla[contador]=contador;
    END

    save(&quot;help\help.cmp&quot;,OFFSET mitabla,sizeof(mitabla));

    compress_file(&quot;help\help.cmp&quot;); // Comprime el archivo

    // ...

    uncompress_file(&quot;help\help.cmp&quot;); // Descomprime el archivo

    load(&quot;help\help.cmp&quot;,OFFSET mitabla);
END
</pre>
Este peque&#241;o programa utiliza la funci&#243;n <a href="#155">save()</a> para crear un archivo llamado <strong>help.cmp</strong> con los datos contenidos en <strong>mitabla</strong>, siendo estos una serie de n&#250;meros consecutivos del 0 al 1000, entonces se comprime el archivo con la funci&#243;n <a href="#262">compress_file()</a>.<br/><br/>
Una vez creado el archivo comprido en disco, se descomprime con la funci&#243;n <strong>uncompress_file()</strong> y se vuelve a cargar sobre la tabla original con la funci&#243;n <a href="#130">load()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Las funciones <a href="#260">encode_file()</a> y <a href="#261">decode_file()</a> permiten encriptar y desencriptar archivos del disco.<br/><br/>
Los archivos encriptados generados con estas funciones <strong>no podr&#225;n comprimirse</strong> debido a que su contenido es completamente aleatorio. No obstante, <strong>los archivos comprimidos si que pueden encriptarse</strong>.<br/><br/>
<hr/>
Ver: <a href="#262">compress_file()</a> - <a href="#260">encode_file()</a> - <a href="#261">decode_file()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="264">find_color()</h2><br/><br/>
<strong>find_color(</strong>&lt;red&gt;<strong>,</strong> &lt;green&gt;<strong>,</strong> &lt;blue&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El <strong>n&#250;mero de color</strong> dentro de la paleta.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Busca el color de la paleta actual m&#225;s cercano al color indicado.<br/><br/>
Se requieren las tres componentes que con componen el color que se desea localizar dentro de la paleta, como <strong>&lt;red&gt;</strong> (rojo), <strong>&lt;green&gt;</strong> (verde) y <strong>&lt;blue&gt;</strong> (azul), todas ellas como valores entre 0 y 63.<br/><br/>
Como valor de retorno se devolver&#225; el <strong>n&#250;mero de color</strong> de la paleta que m&#225;s se acerca a las componentes indicadas.<br/><br/>
Por ejemplo, si se llama a la funci&#243;n como <strong>find_color(63,63,0)</strong>, devolver&#225; el n&#250;mero del color de la paleta que m&#225;s se acerca o parece al <strong>amarillo</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La funci&#243;n <strong>find_color()</strong> <strong>no modifica la paleta actual</strong>, &#250;nicamente busca colores determinados dentro de la misma, para modificar un color de la paleta se debe emplear la funci&#243;n <a href="#179">set_color()</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_find_color;

GLOBAL;
    azul;
    verde;
    amarillo;
    rojo;

BEGIN

    azul=find_color(0,0,63);      // Busca el color azul
    verde=find_color(0,63,0);     // Busca el color verde
    amarillo=find_color(63,63,0); // Busca el color amarillo
    rojo=find_color(63,0,0);      // Busca el color rojo

    draw(2,azul,15,0,0,0,79,79);
    draw(2,verde,15,0,80,0,159,79);
    draw(2,amarillo,15,0,160,0,239,79);
    draw(2,rojo,15,0,240,0,319,79);

    LOOP
        FRAME;
    END
END
</pre>
Este ejemplo utiliza la funci&#243;n <strong>find_color()</strong> para localizar los colores <strong>azul</strong>, <strong>verde</strong>, <strong>amarillo</strong> y <strong>rojo</strong> dentro de la paleta (sea cual sea esta), y entonces, mediante la funci&#243;n <a href="#249">draw()</a>, muestra cuatro cuadrados de estos colores.<br/><br/>
La ventaja de utilizar este sistema es que no importa que el programa cambie de paleta, ya que siempre se podr&#225;n localizar los colores dentro de la misma.<br/><br/>
<hr/>
<br/><br/>
Para modificar toda la paleta, se suele cargar la misma de un archivo del disco mediante al funci&#243;n <a href="#133">load_pal()</a>.<br/><br/>
Para realizar otros efectos de paleta, se puede utilizar la funci&#243;n <a href="#154">roll_palette()</a> que permite realizar ciclos de color, o la funci&#243;n <a href="#110">fade()</a> que permite realizar m&#250;ltiples fundidos y saturaciones de color a diferentes velocidades.<br/><br/>
<hr/>
Ver: <a href="#179">set_color()</a> - <a href="#154">roll_palette()</a> - <a href="#133">load_pal()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="265">load_screen()</h2><br/><br/>
<strong>load_screen(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga la imagen de fondo de la pantalla de un archivo <strong>MAP</strong> o <strong>PCX</strong>.<br/><br/>
Si el gr&#225;fico es de un tama&#241;o (en puntos) diferente al de la pantalla simplemente se imprimir&#225; centrado en la misma.<br/><br/>
Para borrar el fondo de la pantalla se debe utilizar la funci&#243;n <a href="#103">clear_screen()</a>.<br/><br/>
<hr/>
<br/><br/>
En realidad, se trata de una funci&#243;n que resume tres acciones en una:<br/><br/>
<strong>1 -</strong> Cargar un archivo que contiene un mapa con la imagen de fondo (con la funci&#243;n <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a>).<br/><br/>
<strong>2 -</strong> Establecer dicha imagen como fondo de pantalla (con <a href="#148">put_screen()</a>).<br/><br/>
<strong>3 -</strong> Descargar el archivo con la imagen de memoria (con <a href="#176">unload_map()</a> o <a href="#176">unload_pcx()</a>)<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_load_screen;
BEGIN
    load_screen(&quot;help\help.map&quot;);
    LOOP
        FRAME;
    END
END
</pre>
En el ejemplo se carga la imagen de fondo contenida en el archivo <strong>help.map</strong> con la funci&#243;n <strong>load_screen()</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Si se quiere imprimir un gr&#225;fico en una parte concreta de la pantalla o un gr&#225;fico <strong>que no aparezca centrado</strong>, se puede utilizar para ello la funci&#243;n <a href="#146">put()</a>. La funci&#243;n <a href="#173">xput()</a> permite, adem&#225;s, imprimir gr&#225;ficos rotados, escalados, espejados y/o transparentes en cualquier regi&#243;n de pantalla.<br/><br/>
<hr/>
Ver: <a href="#174">load_map/pcx()</a> - <a href="#148">put_screen()</a> - <a href="#176">unload_map/pcx()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="266">force_pal()</h2><br/><br/>
<strong>force_pal(</strong>&lt;nombre de archivo&gt;<strong>)</strong><br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
Carga una paleta de color de disco (de un archivo PAL, FPG, MAP, PCX o FNT) y <strong>la establece como paleta obligatoria</strong> para todos los gr&#225;ficos y fuentes que sean cargados en adelante.<br/><br/>
Es decir, el funcionamiento es muy similar a <a href="#133">load_pal()</a> (que simplemente carga y activa una paleta) pero, una vez cargada la paleta con <strong>force_pal()</strong>, <strong>todos los mapas, ficheros y fuentes</strong> cargados <strong>se adaptar&#225;n autom&#225;ticamente a la paleta activa</strong>.<br/><br/>
Los <strong>gr&#225;ficos que ya estuvieran cargados</strong> antes de llamar a <strong>force_pal()</strong> <strong>no ser&#225;n adaptados</strong>, por ello, si se quiere que todos los gr&#225;ficos se puedan visualizar con una paleta &#250;nica, se debe llamar a esta funci&#243;n al inicio del programa.<br/><br/>
Es <strong>importante</strong> resaltar que los mapas, ficheros y fuentes &#250;nicamente se adaptar&#225;n en la memoria del ordenador, los archivos originales permanecer&#225;n inalterados, cada uno con su paleta.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para que no se continuen adaptando los gr&#225;ficos cargados a la paleta, se debe llamar a la funci&#243;n como <strong>force_pal(0)</strong> (indicando un <strong>0</strong> como par&#225;metro, en lugar de un nombre de archivo.<br/><br/>
<hr/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_force_pal;
BEGIN

    force_pal(&quot;help\help.pal&quot;);

    // Ahora se pueden cargar todos los ficheros, mapas y fuentes
    // que se quiera, sea cual sea su paleta, todos se adaptar&#225;n
    // autom&#225;ticamente a la paleta activa

    // ...

END
</pre>
Este peque&#241;o ejemplo muestra como se pueden forzar todos los gr&#225;ficos a una sola paleta dentro de un programa, llamando a <strong>force_pal()</strong> al inicio del mismo.<br/><br/>
<hr/>
<br/><br/>
Una paleta no se puede descargar de la memoria del ordenador, ya que &#233;sta no ocupa espacio en la memoria.<br/><br/>
<hr/>
Ver: <a href="#133">load_pal()</a><br/><br/>
<hr/>
<h1>Informaci&#243;n extendida sobre los mensajes de error del compilador <hr/></h1>
<br/><br/>
<h2 id="500">Memoria insuficiente</h2><br/><br/>
No se dispone de <strong>memoria suficiente</strong> para compilar el programa.<br/><br/>
<hr/>
<br/><br/>
<h2 id="501">No se encontro ltobj.def</h2><br/><br/>
El archivo &lt;LTLEX.DEF&gt; no se ha encontrado en el directorio de DIV; este archivo resulta imprescindible para la compilaci&#243;n de los programas.<br/><br/>
Recupere el archivo original si dispone de una copia, en caso contrario deber&#225; volver a instalar la aplicaci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<h2 id="502">Archivo ltlex.def err&#243;neo</h2><br/><br/>
Los cambios efectuados en el archivo &lt;LTLEX.DEF&gt; <strong>no son v&#225;lidos</strong>; recupere el archivo original si dispone de una copia, en caso contrario deber&#225; volver a instalar la aplicaci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<h2 id="503">Archivo ltlex.def err&#243;neo</h2><br/><br/>
Se han definido <strong>demasiados s&#237;mbolos</strong> en el archivo &lt;LTLEX.DEF&gt;; recupere el archivo original si dispone de una copia, en caso contrario deber&#225; volver a instalar la aplicaci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<h2 id="504">Archivo ltlex.def err&#243;neo</h2><br/><br/>
Se ha definido un <strong>s&#237;mbolo no v&#225;lido</strong> en el archivo &lt;LTLEX.DEF&gt;; recupere el archivo original si dispone de una copia, si no deber&#225; volver a instalar la aplicaci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<h2 id="506">No se encontro ltobj.def</h2><br/><br/>
El archivo &lt;LTOBJ.DEF&gt; no se ha encontrado en el directorio de DIV; este archivo resulta imprescindible para la compilaci&#243;n de los programas.<br/><br/>
Recupere el archivo original si dispone de una copia, en caso contrario deber&#225; volver a instalar la aplicaci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<h2 id="507">Archivo ltobj.def err&#243;neo</h2><br/><br/>
Los cambios efectuados en el archivo &lt;LTOBJ.DEF&gt; <strong>no s&#243;n v&#225;lidos</strong>; por ello, tendr&#225; que recuperar el archivo original si dispone de una copia, en caso contrario deber&#225; volver a instalar la aplicaci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<h2 id="510">Car&#225;cter no reconocido</h2><br/><br/>
Se encontr&#243; en el programa un car&#225;cter que no forma parte de ning&#250;n s&#237;mbolo del lenguaje y que, adem&#225;s, <strong>no es v&#225;lido</strong> para construir un nuevo nombre.<br/><br/>
Si se trata de un <a href="#1002">comentario</a> debe indicarlo correctamente con un s&#237;mbolo // al comienzo de los comentarios de una l&#237;nea, o los s&#237;mbolos /* y */ para indicar el inicio y fin, respectivamente, de comentarios que ocupen m&#225;s de una l&#237;nea.<br/><br/>
En caso de que se pretenda construir un <a href="#1001">nombre</a> debe sustituir dicho car&#225;cter por otro dentro de los que se permiten en el lenguaje.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1002">Comentarios</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="511">Literal sin cerrar</h2><br/><br/>
Los literales son los <strong>textos entre comillas</strong>. En la posici&#243;n indicada del programa comienza un literal y no se cierra.<br/><br/>
Todos los literales deben cerrarse en la misma l&#237;nea en la que comenzaron, no pudi&#233;ndose definir literales de m&#225;s de una l&#237;nea.<br/><br/>
Los literales pueden comenzar y terminar con el car&#225;cter [<a href="#1047">&#39;</a>] o bien con el car&#225;cter [<a href="#1047">&quot;</a>] (pero deben comenzar y terminar con el mismo). Si se quiere incluir el car&#225;cter [<a href="#1047">&quot;</a>] en un literal se puede hacer de dos formas; sup&#243;ngase que se quiere definir un literal que contenga el texto: a&quot;B&quot;c<br/><br/>
- Duplicar el car&#225;cter: &quot;a&quot;&quot;B&quot;&quot;c&quot;<br/><br/>
- Definirlo con la comilla simple: &#39;a&quot;B&quot;c&#39;<br/><br/>
Lo mismo sucede con el car&#225;cter [<a href="#1047">&#39;</a>], que se puede incluir en un literal si se duplica, o bien si el literal se delimita con el car&#225;cter [<a href="#1047">&quot;</a>].<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="512">S&#237;mbolo no reconocido</h2><br/><br/>
En la posici&#243;n indicada del programa se encuentra un s&#237;mbolo no perteneciente al lenguaje; revise los s&#237;mbolos que hay disponibles en el lenguaje para construir correctamente la expresi&#243;n.<br/><br/>
Probablemente se trate de un error tipogr&#225;fico; revise la sintaxis.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="520">Esperando [PROGRAM]</h2><br/><br/>
Todos los programas deben comenzar con la palabra reservada <strong>PROGRAM</strong> seguida del nombre del programa; antes de dicha palabra s&#243;lo pueden aparecer <a href="#1002">comentarios</a> o las <a href="#1400">opciones de compilaci&#243;n</a>.<br/><br/>
Compruebe si ha escrito la palabra correctamente, ya que no se diferencia entre may&#250;sculas y min&#250;sculas, por lo que son v&#225;lidas <strong>PROGRAM</strong>, <strong>program</strong>, <strong>Program</strong>, ...<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
// -------------------
// Listado de mi juego
// -------------------

PROGRAM mi_juego;
BEGIN
    LOOP
        FRAME;
    END
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1002">Comentarios</a> - <a href="#1003">Cabecera de programa</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="521">Esperando el nombre del programa</h2><br/><br/>
Tras la palabra reservada <strong>PROGRAM</strong> se espera que venga el nombre del programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
BEGIN
    //...
END
</pre>
El nombre de este programa es <strong>nombre_del_programa</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1003">Cabecera de programa</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="522">El nombre no es nuevo</h2><br/><br/>
Como nombre de la estructura se ha utilizado uno que ya estaba relacionado con otro objeto anteriormente definido. Puede tratarse de un nombre, de una constante, una variable, una tabla, una estructura, un proceso o una funci&#243;n del programa.<br/><br/>
Tambi&#233;n puede que se haya pretendido utilizar el mismo nombre dentro del programa para identificar dos objetos diferentes, o bien <strong>que se haya utilizado un nombre predefinido para otro uso dentro del lenguaje</strong>. En dicho caso, se puede acceder al glosario para ver a qu&#233; objeto se refiere dicho nombre.<br/><br/>
De todas formas, <strong>debe sustituir dicho nombre por otro similar</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
GLOBAL
    posicion=0;
    STRUCT posicion[9] // Error: El nombre no es nuevo.
        x, y;
    END
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="523">Esperando [=]</h2><br/><br/>
Para definir una tabla se suele indicar entre corchetes la longitud de la misma; en caso de no especificar entre los corchetes el n&#250;mero de elementos de la tabla se espera que a continuaci&#243;n se inicialice para que el compilador pueda determinar su longitud.<br/><br/>
Se ha encontrado una tabla sin longitud definida, por lo que el compilador esperaba que, tras cerrarse los corchetes (<a href="#1079">[]</a>), viniera el s&#237;mbolo <a href="#1073">=</a> precediendo a la inicializaci&#243;n de la tabla.<br/><br/>
Indique la longitud de la tabla entre los corchetes, o as&#237;gnele valores a las diferentes posiciones de la tabla.<br/><br/>
Cuando una tabla no se inicializa todas sus posiciones ser&#225;n incializadas a cero.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
GLOBAL
    tabla1[3];
    tabla2[]=2, 4, 6, 8;
    tabla3[]; // Error: Esperando [=].
BEGIN
    //...
END
</pre>
En el ejemplo se han definido dos tablas de cuatro posiciones (0..3), tabla1 inicializada a (0, 0, 0, 0) y tabla2 inicializada a (2, 4, 6, 8).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1011">Declaracion de tabla</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="525">Esperando [)]</h2><br/><br/>
El compilador esperaba que en la posici&#243;n indicada se cerrara un par&#233;ntesis anteriormente abierto con el s&#237;mbolo <a href="#1053">)</a>.<br/><br/>
Este error se suele producir por uno de estos dos motivos:<br/><br/>
- En una expresi&#243;n se han abierto varios par&#233;ntesis y despu&#233;s no se han cerrado todos; en este caso debe cerrar los que falten.<br/><br/>
- Dentro de una expresi&#243;n entre par&#233;ntesis se ha omitido alg&#250;n operador apareciendo, entonces, dos operandos seguidos, por ejemplo <strong>(2*3 4)</strong>, debiendo, en este caso, indicar el operador que falte.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="526">Esperando []]</h2><br/><br/>
El compilador esperaba que en la posici&#243;n indicada se cerrara un corchete anteriormente abierto, con el s&#237;mbolo <a href="#1079">]</a>.<br/><br/>
Este error se suele producir por uno de estos dos motivos:<br/><br/>
- En una tabla o estructura se ha indicado la apertura de corchete (<strong>[</strong>) y despu&#233;s de indicar la longitud o &#237;ndice de la misma no se ha cerrado; en este caso se debe a&#241;adir en la posici&#243;n indicada el s&#237;mbolo <strong>]</strong>.<br/><br/>
- Al se&#241;alar el &#237;ndice de una tabla o estructura se ha omitido alg&#250;n operador apareciendo, entonces, dos operandos seguidos, por ejemplo <strong>tabla[2*3 4]</strong>, debiendo indicar, ahora, el operador que falte.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="527">Se esperaba un operando</h2><br/><br/>
La posici&#243;n indicada en el programa est&#225; dentro del contexto de una expresi&#243;n, y en ese punto de la expresi&#243;n se esperaba un operando (un valor sobre el que se puedan realizar c&#225;lculos) pero, en su lugar, ha venido otro elemento diferente sobre el que no se pueden realizar c&#225;lculos.<br/><br/>
Hay varias causas que pueden provocar este error; las m&#225;s comunes son:<br/><br/>
- Se ha utilizado una palabra reservada del lenguaje como si fuera una variable, por ejemplo <strong>x=global*2;</strong>. En este caso se puede comprobar si se trata de una palabra reservada accediendo al glosario.<br/><br/>
- Se ha omitido un operando dentro de una expresi&#243;n, por ejemplo <strong>x=2+ /y;</strong>.<br/><br/>
- Se ha cerrado dentro de una expresi&#243;n un corchete o par&#233;ntesis que no habia sido abierto anteriormente, por ejemplo <strong>x=);</strong>.<br/><br/>
En cualquier caso debe revisar la <a href="#1000">sintaxis</a> de la expresi&#243;n indicada para construirla de forma correcta.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="528">Nombre desconocido</h2><br/><br/>
En la posici&#243;n indicada del programa se utiliza una constante, una variable, una tabla o una estructura con el fin de acceder a ella antes de haberla declarado.<br/><br/>
El compilador no puede resolver el problema dado que no conoce de qu&#233; tipo de objeto se trata.<br/><br/>
Todas las constantes se deben definir al comienzo del programa, dentro de la secci&#243;n <a href="#1004">CONST</a>.<br/><br/>
Las variables, tablas y estructuras se pueden definir dentro de las secciones <a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a> seg&#250;n su alcance, pero siempre tienen que estar definidas antes de ser usadas.<br/><br/>
Los casos m&#225;s frecuentes en los que se da este error son:<br/><br/>
- Se ha tecleado incorrectamente un nombre, por ejemplo;<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    centro=160;
BEGIN
    x=cenrto; // Error: Nombre desconocido.
    //...
END
</pre>
- Un objeto se usa antes y se declara despu&#233;s, por ejemplo:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    doble=simple*2; // Error: Nombre desconocido.
    simple=1;
BEGIN
    //...
END
</pre>
En este caso se deber&#237;an intercambiar las dos declaraciones anteriores.<br/><br/>
- Al inicializar una tabla o estructura, se ha colocado una coma accidentalmente tras la lista de valores.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla[]=0, 1, 2, 3,
    a=0; // Error: Nombre desconocido.
BEGIN
    //...
END
</pre>
En este caso el compilador avisar&#225; de este error en la variable <strong>a</strong>, ya que interpreta que es el siguiente valor en la lista de inicializaci&#243;n de tabla, y es un nombre que todav&#237;a se ha definido.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1004">Declaraci&#243;n de constantes</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="529">Esperando [BEGIN]</h2><br/><br/>
Este error se produce cuando se realiza una declaraci&#243;n incorrecta dentro de las secciones <a href="#1004">CONST</a>, <a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a>.<br/><br/>
Tras la sentencia inicial <a href="#1003">PROGRAM nombre_de_programa;</a> se espera que aparezca alguna de las secciones anteriormente citadas (siempre en ese mismo orden) y al final la palabra <a href="#1086">BEGIN</a>.<br/><br/>
Tras el inicio de un proceso (<a href="#1016">PROCESS</a> <strong>nombre_de_proceso(</strong>...<strong>)</strong>) o funci&#243;n (<a href="#1408">FUNCTION</a> <strong>nombre_de_funci&#243;n(</strong>...<strong>)</strong>) que se muestre la secci&#243;n <a href="#1008">PRIVATE</a> o la palabra <a href="#1086">BEGIN</a>.<br/><br/>
El error puede producirse bajo las siguientes circunstancias:<br/><br/>
- Se ha escrito incorrectamente el nombre de alguna secci&#243;n.<br/><br/>
- Se han puesto varias secciones en un orden incorrecto:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
LOCAL
    a=0;
GLOBAL // Error: Esperando [BEGIN]
    b=0;
BEGIN
    //...
END
</pre>
Se recuerda que las secciones deben ir en el siguiente orden:<br/><br/>
<strong>CONST</strong><br/>
<a href="#1006">GLOBAL</a><br/>
<a href="#1007">LOCAL</a><br/>
<a href="#1008">PRIVATE</a><br/>
<br/><br/>
- Dentro de cualquiera de las secciones antes mencionadas ha venido un elemento que no es una declaraci&#243;n v&#225;lida dentro de dicha secci&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    +variable=0; // Error: Esperando [BEGIN]
BEGIN
    //...
END
</pre>
En este ejemplo, al llegar al s&#237;mbolo <a href="#1056">+</a> el compilador determina que la secci&#243;n <a href="#1006">GLOBAL</a> ya ha finalizado y, por lo tanto, como el siguiente elemento no es el inicio de las secciones <a href="#1007">LOCAL</a> ni <a href="#1008">PRIVATE</a>, espera que venga la palabra reservada <a href="#1086">BEGIN</a> marcando el inicio del c&#243;digo del programa.<br/><br/>
- Al comienzo del programa o al definir un proceso se ha omitido la palabra <strong>BEGIN</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
END

PROCESS mi_proceso()
    FRAME; // Error: Esperando [BEGIN]
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1086">BEGIN</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="530">Se esperaba una expresi&#243;n constante</h2><br/><br/>
Para inicializar <a href="#1004">constantes</a>, variables, tablas y estructuras se deben utilizar valores num&#233;ricos o expresiones cuyo valor pueda ser determinado cuando se compila el programa.<br/><br/>
En la posici&#243;n indicada comienza una expresi&#243;n cuyo valor no ha podido ser resuelto en tiempo de compilaci&#243;n, probablemente porque use algun dato global, local o privado, o bien porque se llame a alguna funci&#243;n.<br/><br/>
En las expresiones constantes se pueden utilizar &#250;nicamente:<br/><br/>
- <a href="#1004">Constantes</a> definidas con anterioridad.<br/>
- <strong>Valores num&#233;ricos</strong>.<br/>
- <strong>Operadores</strong> aritm&#233;ticos o l&#243;gicos.<br/>
- <strong>Literales</strong> (textos entre comillas).<br/>
- La funci&#243;n <a href="#1094">sizeof()</a>.<br/>
<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    mi_variable=4;
    posici&#243;n=2*mi_variable; // Error: Se esperaba una expresi&#243;n constante.
BEGIN
    //...
END
</pre>
En este ejemplo no se puede inicializar <strong>posici&#243;n</strong>, ya que se est&#225; utilizando para ello la variable local <strong>x</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1005">Definici&#243;n de constantes</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="531">Se excedi&#243; la tabla</h2><br/><br/>
La expresi&#243;n constante que comienza en la posici&#243;n indicada del programa no puede ser calculada, pues en ella se accede a una tabla o estructura fuera de su rango de posiciones.<br/><br/>
Revise el rango de la tabla o estructura en su definici&#243;n. Se recuerda que una tabla definida, por ejemplo, como <strong>tabla[10]</strong> tiene <strong>11</strong> posiciones (desde tabla[0] hasta tabla[10]).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla[]=1, 3, 5;
    valor=tabla[3]; // Error: Se excedi&#243; la tabla.
BEGIN
    //...
END
</pre>
En este ejemplo no se puede inicializar la variable <strong>valor</strong> dado que se est&#225; utilizando, para ello, una posici&#243;n de tabla inexistente.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1011">Declaraci&#243;n de tabla</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="532">No se puede calcular el offset</h2><br/><br/>
En la expresi&#243;n indicada en el programa se utiliza el operador <a href="#1085">offset</a> (o el s&#237;mbolo sin&#243;nimo <a href="#1085">&amp;</a>) con el fin de obtener la direcci&#243;n (desplazamiento) de un objeto. Dicho objeto no tiene direcci&#243;n, pues no es una variable, una tabla o una estructura, por lo que el compilador no puede resolver la expresi&#243;n.<br/><br/>
Probablemente se haya pretendido obtener la direcci&#243;n de una expresi&#243;n constante o una que involucre varios operandos.<br/><br/>
A continuaci&#243;n se muestra un programa con varios ejemplos de uso v&#225;lido del operador <a href="#1085">offset</a>, y otros tantos inv&#225;lidos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    mi_constante=0;
GLOBAL
    mi_offset=0;
    mi_variable=0;
    mi_tabla[10];
    STRUCT mi_estructura[10]
        variable;
    END
BEGIN
    // Ejemplos correctos
    mi_offset=offset mi_variable;
    mi_offset=offset mi_tabla;
    mi_offset=offset mi_tabla[mi_variable];
    mi_offset=offset mi_estructura[0].variable;
    mi_offset=offset id.x;

    // Ejemplos err&#243;neos
    mi_offset=offset (mi_variable*2);
    mi_offset=offset mi_constante;
    mi_offset=offset 0;
    write_int(0, 0, 0, 0, offset (mi_variable+1));
END
</pre>
No hay ninguna diferencia entre el uso de la palabra reservada <a href="#1085">offset</a> o el s&#237;mbolo <strong>&amp;</strong>.<br/><br/>
Las <a href="#1005">constantes</a> como <strong>mi_constante</strong> no tiene una direcci&#243;n pues son simples sin&#243;nimos del valor num&#233;rico que representan.<br/><br/>
La sentencia <strong>mi_offset=offset (mi_variable*2);</strong> es err&#243;nea debido a que la multiplicaci&#243;n se realiza en primer lugar y, una vez realizada, el valor <strong>mi_variable*2</strong> se convierte en un resultado num&#233;rico que no tiene ninguna direcci&#243;n asignada.<br/><br/>
En cambio, la expresi&#243;n <strong>offset mi_variable*2</strong> s&#237; es correcta pues, en este caso, se obtiene primero la direcci&#243;n de <strong>mi_variable</strong> y luego ser&#225; esta direcci&#243;n la que se multiplique por <strong>2</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1085">offset</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="533">Demasiados valores para la tabla</h2><br/><br/>
Se ha inicializado una tabla con m&#225;s valores de los que puede contener.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[3]=0, 1,2 , 3, 4; // Error: Demasiados valores para la tabla.
BEGIN
    //...
END
</pre>
Para inicializar una tabla se debe tener en cuenta que, como m&#225;ximo, puede tener tantos valores como indique el n&#250;mero que va entre los corchetes m&#225;s 1.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[3]=2, 4, 6, 8;
BEGIN
    //...
END
</pre>
En este caso la tabla <strong>tabla1</strong> puede contener cuatro valores (tabla1[0]=2, tabla1[1]=4, tabla1[2]=6 y tabla1[3]=8).<br/><br/>
Otra opci&#243;n es <strong>no indicar el tama&#241;o de la tabla</strong>, por lo que el compilador lo deducir&#225; a partir de su inicializaci&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[]=2, 4, 6, 8;
BEGIN
    //...
END
</pre>
En este caso, si dentro del programa se necesitase hacer referencia a la longitud de la tabla, se deber&#237;a utilizar la expresi&#243;n <strong>sizeof(tabla1)</strong> que, en este ejemplo, valdr&#237;a <strong>4</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1011">Declaraci&#243;n de tabla</a> - <a href="#1094">sizeof()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="534">Desbordamiento en divisi&#243;n</h2><br/><br/>
En la posici&#243;n indicada del programa aparece una <a href="#1005">expresi&#243;n constante</a> que no ha podido ser resuelta por contener dentro de sus operaciones una divisi&#243;n entre cero.<br/><br/>
Al dividir un n&#250;mero entre cero resulta &#177; infinito y como en el lenguaje de programaci&#243;n s&#243;lo se pueden manejar n&#250;meros enteros, dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>) no es posible guardar el resultado de dicha operaci&#243;n en ninguna variable o relacionarlo con una constante.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    infinito=1/0; // Error: Desbordamiento en divisi&#243;n.
BEGIN
    //...
END
</pre>
Probablemente se trate de un error involuntario, de ah&#237; que deba evitarse que se realice alguna divisi&#243;n por cero al evaluar la expresi&#243;n.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Sentencia de asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="535">Tabla de longitud negativa</h2><br/><br/>
Para definir una tabla indicando entre corchetes su longitud se debe emplear un n&#250;mero entero positivo (0, 1, 2, 3, ...), teniendo en cuenta que todas las tablas comienzan en la posici&#243;n cero y terminan en la posici&#243;n que indicada en el &#237;ndice.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[9];
    tabla2[-9]; // Error: Tabla de longitud negativa.
BEGIN
    //...
END
</pre>
El compilador ha detectado una tabla definida con una longitud negativa como <strong>tabla2</strong>; en este ejemplo se debe definir la tabla como <strong>tabla1</strong> que, en este caso, ser&#225; una tabla de 10 posiciones (desde tabla1[0] hasta tabla1[9]).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1011">Declaraci&#243;n de tabla</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="536">Esperando [(]</h2><br/><br/>
El compilador espera que en la posici&#243;n del programa indicada se abra un par&#233;ntesis con el s&#237;mbolo <a href="#1053">(</a>.<br/><br/>
Hay varios casos en los que es obligada la apertura de un <a href="#1053">par&#233;ntesis</a>:<br/><br/>
- <strong>Tras un nombre de un proceso o una funci&#243;n</strong> se deben indicar siempre sus par&#225;metros de llamada entre par&#233;ntesis; incluso cuando el proceso o la funci&#243;n no tengan par&#225;metros se debe abrir un par&#233;ntesis, cerr&#225;ndolo a continuaci&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    mi_proceso();
    //...
END
PROCESS mi_proceso()
BEGIN
  //...
END
</pre>
- <strong>En las sentencias de control que requieran una condici&#243;n</strong> para controlar el flujo del programa, se debe poner entre par&#233;ntesis dicha condici&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    IF (x&lt;10)
        //...
    END

    WHILE (x&lt;10)
        //...
    END

    REPEAT
        //...
    UNTIL (x&lt;10)

    SWITCH (x)
        //...
    END

    FOR (x=0;x&lt;10;x++)
        //...
    END
END
</pre>
En este ejemplo se puede ver c&#243;mo las diferentes sentecias de control indican entre par&#233;ntesis la condici&#243;n. Hay dos excepciones:<br/><br/>
- La sentencia <a href="#1021">SWITCH</a> no requiere una condici&#243;n sino una simple expresi&#243;n; a&#250;n as&#237;, la requiere entre par&#233;ntesis.<br/><br/>
- La sentencia <a href="#1025">FOR</a> tiene tres partes dentro de los par&#233;ntesis, separadas por puntos y coma, siendo estas partes las siguientes: inicializaci&#243;n (<strong>x=0</strong>), condici&#243;n (<strong>x&lt;10</strong>) e incremento (<strong>x++</strong>).<br/><br/>
- <strong>Tras el operador <a href="#1089">DUP</a></strong> (utilizado para inicializar tablas y estructuras) tambi&#233;n es obligada la apertura de un par&#233;ntesis.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[]=10 dup (1, 2, 3);
BEGIN
    //...
END
</pre>
En este ejemplo, tabla1 ser&#237;a una tabla de 30 posiciones (desde tabla1[0] hasta tabla1[29]) inicializada de la siguiente forma: 1, 2, 3, 1, 2, 3, ...<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1053">( )</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="538">No se puede duplicar 0 o menos veces</h2><br/><br/>
El operador <a href="#1089">DUP</a> utilizado para inicializar tablas y estructuras permite repetir (duplicar) una secuencia de valores un determinado n&#250;mero de veces: desde una sola vez (en cuyo caso el operador no tiene n&#237;nguna utilidad) hasta un n&#250;mero positivo indeterminado de veces.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[]=10 dup (1, 2, 3);
    tabla2[]=-10 dup (1, 2, 3); // Error: No se puede duplicar 0 o menos veces.
BEGIN
    //...
END
</pre>
En este ejemplo, tabla1 ser&#237;a una tabla de 30 posiciones (desde tabla1[0] hasta tabla1[29]) inicializada de la siguiente forma: 1, 2, 3, 1, 2, 3, ...<br/><br/>
Es posible, adem&#225;s, omitir el operador <a href="#1089">DUP</a> quedando entonces la declaraci&#243;n de tabla1 de la siguiente forma:<br/><br/>
<strong>tabla1[]=10(1, 2, 3);</strong><br/><br/>
El efecto es exactamente el mismo que en el ejemplo anterior, es decir, cuando el compilador se encuentra en una inicializaci&#243;n de tabla la secuencia <strong>n&#250;mero ( secuencia_de_valores ... )</strong> interpreta que se pretende repetir la <strong>secuencia_de_valores</strong> el <strong>n&#250;mero</strong> de veces que se indica.<br/><br/>
Por tanto, es imposible repetir una secuencia de valores cero o un n&#250;mero negativo de veces.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1089">DUP</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="539">Asignaci&#243;n incorrecta</h2><br/><br/>
No se puede realizar la asignaci&#243;n indicada en esta posici&#243;n del programa. En una sentencia de asignaci&#243;n s&#243;lo est&#225; permitido asignar valores a objetos tales como variables (sean del tipo que sean) a una posici&#243;n de una tabla, o a un elemento de una estructura.<br/><br/>
No es posible asignar un valor a una <a href="#1004">constante</a>, a una funci&#243;n o a un proceso, o, en general, a cualquier expresi&#243;n num&#233;rica o l&#243;gica.<br/><br/>
En el siguiente programa se muestran ejemplos de varios tipos de asignaciones incorrectas:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    mi_constante=0;
BEGIN
    mi_constante=1;  // Error: Asignaci&#243;n incorrecta.
    type mi_juego=2; // Error: Asignaci&#243;n incorrecta.
    sizeof(mouse)=3; // Error: Asignaci&#243;n incorrecta.
    4+5=6;           // Error: Asignaci&#243;n incorrecta.
    //...
END
</pre>
Todas estas asignaciones no son v&#225;lidas porque no se puede modificar con una asignaci&#243;n el resultado de una expresi&#243;n, que es s&#243;lo un valor num&#233;rico; por ello, es como poner una sentencia del tipo <strong>2=4;</strong> que, por supuesto, es imposible de realizar.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Definici&#243;n de expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="540">Esperando [END]</h2><br/><br/>
Dentro de las palabras reservadas <a href="#1086">BEGIN</a> y <a href="#1091">END</a> se espera un bloque de sentencias, as&#237; como dentro de sentencias como las que siguen:<br/><br/>
<a href="#1020">IF</a> ... <a href="#1090">ELSE</a> ... <a href="#1091">END</a><br/>
<a href="#1024">LOOP</a> ... <a href="#1091">END</a><br/>
<a href="#1022">WHILE</a> ... <a href="#1091">END</a><br/>
<a href="#1025">FOR</a> ... <a href="#1091">END</a><br/>
<a href="#1043">FROM</a> ... <a href="#1091">END</a><br/>
<a href="#1021">SWITCH</a> ... <a href="#1091">END</a><br/>
<br/><br/>
Un bloque de sentencias acaba (y s&#243;lo puede acabar) con cualquiera de estas tres palabras reservadas: <a href="#1091">END</a>, <a href="#1097">UNTIL</a> o <a href="#1090">ELSE</a>.<br/><br/>
En el programa hay un bloque que se esperaba que acabara con la palabra reservada <a href="#1091">END</a> pero finaliza con otra palabra; los dos casos m&#225;s probables son:<br/><br/>
- Que se haya perdido un <a href="#1023">REPEAT</a> o un <a href="#1020">IF</a> acabando el bloque de sentencias con un <a href="#1097">UNTIL</a> o un <a href="#1090">ELSE</a>; en este caso, se debe buscar el <a href="#1023">REPEAT</a> o <a href="#1020">IF</a> asociado.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
//  REPEAT
    //...
    UNTIL (key(_esc)); // Error: Esperando [END].
END
</pre>
En este ejemplo el bloque de sentencias que comenz&#243; con el <a href="#1086">BEGIN</a> del programa principal ha acabado con un <a href="#1097">UNTIL</a> (puesto que se ha comentado accidentalmente el <a href="#1023">REPEAT</a>), y el compilador esperaba que este bloque acabara con un <a href="#1091">END</a>.<br/><br/>
- Que se haya perdido un <a href="#1091">END</a> de alguna sentencia y llegue el siguiente <a href="#1016">PROCESS</a>, <a href="#1408">FUNCTION</a> o el final del programa esperando el END que se ha perdido.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    IF (x&lt;0) x++;
END
PROCESS mi_proceso() // Error: Esperando [END].
BEGIN
    //...
END
</pre>
En este caso no se ha puesto el <a href="#1091">END</a> del <a href="#1020">IF</a> interpretando el compilador que el <a href="#1020">IF</a> acaba al llegar el siguiente <a href="#1091">END</a> (el del <a href="#1086">BEGIN</a>) y por tanto, al llegar el nuevo <a href="#1016">PROCESS</a> o <a href="#1408">FUNCTION</a>, se sigue esperando el <a href="#1091">END</a> del <a href="#1086">BEGIN</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1091">END</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="541">Expresi&#243;n incorrecta</h2><br/><br/>
En la posici&#243;n indicada del programa hay una expresi&#243;n incorrectamente construida, de forma que el compilador no puede interpretarla.<br/><br/>
- Revise la <a href="#1000">sintaxis</a> de la expresi&#243;n.<br/><br/>
- En caso de no encontrar el error, intente expresarla de otra forma.<br/><br/>
- Intente dividir la expresi&#243;n en varias subexpresiones realizando secuencialmente y de forma separada los distintos c&#225;lculos que se realizan en la expresi&#243;n original. Por ejemplo, la expresi&#243;n:<br/><br/>
<strong>x=(x*4+1)/2;</strong><br/><br/>
se puede expresar como tres expresiones diferentes, que son:<br/><br/>
<strong>x=x*4;</strong><br/>
<strong>x=x+1;</strong><br/>
<strong>x=x/2;</strong><br/>
<br/><br/>
De esta forma podr&#225; localizar en qu&#233; punto exacto del c&#225;lculo se haya la operaci&#243;n que no es posible realizar.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Definici&#243;n de Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="542">Esperando [UNTIL]</h2><br/><br/>
Un bloque de sentencias que comenz&#243; con la palabra reservada <a href="#1023">REPEAT</a> debe acabar necesariamente con la palabra <a href="#1097">UNTIL</a>; en la posici&#243;n indicada del programa se ha finalizado el bloque de sentencias con otra palabra diferente, lo m&#225;s probable es:<br/><br/>
- Que se ha finalizado un <a href="#1023">REPEAT</a> con un <a href="#1091">END</a> en cuyo caso, si lo que se prentende es realizar un bucle indefinidamente, se debe utilizar la sentencia <a href="#1024">LOOP</a> ... <a href="#1091">END</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    REPEAT
    //...
    END // Error: Esperando [UNTIL]
END
</pre>
- Que dentro del bucle <a href="#1023">REPEAT</a> ... <a href="#1097">UNTIL</a> aparezca una palabra como <a href="#1091">END</a> o <a href="#1090">ELSE</a> de m&#225;s y, por lo tanto, sin su correspondiente inicio (<a href="#1020">IF</a>, <a href="#1022">WHILE</a>, ...).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    REPEAT
        IF (x&lt;0) x++; END
            y++;
        END // Error: Esperando [UNTIL]
    UNTIL (x&gt;=0);
END
</pre>
En este caso, se ha puesto el <a href="#1091">END</a> del <a href="#1020">IF</a> dos veces, interpretando el compilador que el segundo <a href="#1091">END</a> pretende cerrar el <a href="#1023">REPEAT</a>.<br/><br/>
- O, por &#250;ltimo, que se haya olvidado poner el <a href="#1097">UNTIL</a> del <a href="#1023">REPEAT</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1023"> Sentencia REPEAT</a> - <a href="#1020">IF</a> - <a href="#1022">WHILE</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="543">Local no se puede acceder</h2><br/><br/>
En la posici&#243;n indicada en el programa se pretende acceder a un dato de otro proceso, siendo imposible ya que dicho dato no es local del otro proceso.<br/><br/>
Debe comprobarse que el dato que se pretende acceder est&#225; definido dentro de la secci&#243;n <a href="#1007">LOCAL</a> del programa, o bien un dato local predefinido en el lenguaje (como <a href="#1123">x</a>, <a href="#1124">y</a>, <a href="#1126">graph</a>, <a href="#1128">size</a>, ...).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    id_mi_proceso;
    puntos=0;
BEGIN
    id_mi_proceso=mi_proceso();
    id_mi_proceso.x=0;
    id_mi_proceso.puntos=0; // Error: Local no se puede acceder.
END
PROCESS mi_proceso()
BEGIN
    //...
END
</pre>
En este caso se prentende acceder a los <strong>puntos</strong> de <strong>mi_proceso</strong>, pero <strong>puntos</strong> es una &#250;nica variable <a href="#1006">GLOBAL</a> y no una variable <a href="#1007">LOCAL</a> de cada proceso. Esto tambi&#233;n puede suceder intentando acceder a una constante (definida en <a href="#1005">CONST</a>) o a una expresi&#243;n como:<br/><br/>
<strong>x=id_mi_proceso.(x+1);</strong><br/><br/>
En este &#250;ltimo ejemplo la expresi&#243;n carece de sentido por completo; probablemente fuera la siguiente expresi&#243;n la que se prentendiera formular:<br/><br/>
<strong>x=id_mi_proceso.x+1;</strong><br/><br/>
(equivalente a <strong>x=(id_mi_proceso.x)+1;</strong>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1007">Declaracion datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="544">Par&#225;metro no v&#225;lido</h2><br/><br/>
Los procesos pueden recibir par&#225;metros en los siguientes tipos de datos:<br/><br/>
- Un dato local predefinido (como <a href="#1123">x</a>, <a href="#1128">size</a>, <a href="#1127">flags</a>, ...).<br/><br/>
- Un dato local definido dentro de la secci&#243;n <a href="#1007">LOCAL</a>.<br/><br/>
- Un dato global definido dentro de la secci&#243;n <a href="#1006">GLOBAL</a>.<br/><br/>
- Un dato privado del proceso declarado dentro de la secci&#243;n <a href="#1008">PRIVATE</a> del propio proceso.<br/><br/>
- Un dato privado que <strong>no est&#233; declarado</strong> dentro de la secci&#243;n <a href="#1008">PRIVATE</a>.<br/><br/>
Entendi&#233;ndose en todos estos casos que un dato puede referirse a una variable, a una posici&#243;n concreta de una tabla o a un elemento dentro de una estructura.<br/><br/>
En la posici&#243;n indicada del programa se pretende recibir un par&#225;metro en un objeto diferente de los arriba indicados, o bien indicar una expresi&#243;n en lugar de un simple dato. Estos son algunos ejemplos de declaraciones de par&#225;metros inv&#225;lidas:<br/><br/>
<strong>PROCESS mi_proceso(mi_constante)</strong><br/>
No se puede recibir un par&#225;metro en una constante.<br/><br/>
<strong>PROCESS mi_proceso(x*2)</strong><br/>
No se puede recibir un par&#225;metro en una expresi&#243;n.<br/><br/>
<strong>PROCESS mi_proceso(x=0)</strong><br/>
No se puede recibir un par&#225;metro en una asignaci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="545">Se esperaba otro par&#225;metro</h2><br/><br/>
En las llamadas a procesos o funciones se deben poner tantos valores o expresiones como p&#225;rametros se requieran, todos dentro del mismo <a href="#1053">par&#233;ntesis</a> y separados por <a href="#1059">comas (,)</a>. Este error se produce cuando se cierra el par&#233;ntesis tras una <a href="#1059">coma</a>, como en el siguiente ejemplo:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    signal(id, ); // Error: Se esperaba otro par&#225;metro.
END
</pre>
Puede haber pasado dos cosas; se ha puesto una coma accidentalmente tras el &#250;ltimo par&#225;metro, o bien se ha omitido el &#250;ltimo par&#225;metro (como en el ejemplo anterior).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="546">N&#250;mero de par&#225;metros incorrecto</h2><br/><br/>
El proceso o funci&#243;n tiene un n&#250;mero diferente de par&#225;metros a los que aparecen en la posici&#243;n se&#241;alada en el programa.<br/><br/>
Si se trata de una funci&#243;n, acceda al <strong>glosario</strong> para consultar los par&#225;metros que requiere o bien sit&#250;e el cursor sobre el nombre de la funci&#243;n en el programa y entonces pulse <strong>F1</strong>.<br/><br/>
Si se trata de un proceso, entonces puede que en la posici&#243;n se&#241;alada el n&#250;mero de par&#225;metros sea correcto pero haya aparecido una llamada a dicho proceso anteriormente en el programa con un n&#250;mero diferente de par&#225;metros.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    mi_proceso();
END
PROCESS mi_proceso(x, y) // Error: N&#250;mero de par&#225;metros incorrecto.
BEGIN
    //...
END
</pre>
En este ejemplo el error no est&#225; en la definici&#243;n del proceso como se indica, sino en la llamada anterior a dicho proceso (<strong>mi_proceso();</strong>); esto es as&#237; porque el compilador, cuando se encuentra una llamada a un proceso que no conoce, lo registra como un nuevo proceso y apunta su n&#250;mero de par&#225;metros. Si la pr&#243;xima vez que se encuentre dicho proceso no coincide el n&#250;mero de par&#225;metros con los que ten&#237;a registrados, entonces se emite el error.<br/><br/>
Por tanto, en caso de ser correcta la llamada o definici&#243;n del proceso se&#241;alada en el programa, utilice la opci&#243;n de b&#250;squeda (<strong>ALT-F</strong>) para revisar el n&#250;mero de par&#225;metros en las anteriores llamadas a dicho proceso.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="547">Esperando [;]</h2><br/><br/>
La sentencia <a href="#1024">FOR</a> tiene tres partes dentro de los par&#233;ntesis separadas por puntos y coma, siendo estas partes las siguientes:<br/><br/>
FOR (<strong>inicializaci&#243;n</strong>; <strong>condici&#243;n</strong>; <strong>incremento</strong>)<br/><br/>
- La <strong>inicializaci&#243;n</strong> suele ser una <a href="#1019">asignaci&#243;n</a> que fija el valor de un dato cuando se comienza a ejecutar la sentencia <a href="#1025">FOR</a>.<br/><br/>
- La condici&#243;n que se establece en segundo lugar determina la permanencia dentro del bucle; cada iteraci&#243;n se mirar&#225; primero si se cumple dicha condici&#243;n y, en caso contrario, se finalizar&#225; la ejecuci&#243;n de la sentencia <a href="#1025">FOR</a>.<br/><br/>
- El <strong>incremento</strong> actualiza el valor del dato que sirve como contador tras cada iteraci&#243;n del bucle.<br/><br/>
Ninguna de las tres partes son obligatorias, pero s&#237; lo son los par&#233;ntesis y los dos s&#237;mbolos <a href="#1068">punto y coma (;)</a> que separan las partes.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FOR ( graph=10 ; graph&lt;20 ; graph=graph+1 )
        //...
    END
    FOR ( graph=10 ; graph&lt;20 graph=graph+1) // Error: Esperando [;]
        //...
    END
END
</pre>
Dentro de cada una de las tres partes se pueden poner varias sentencias siempre que se separen por <a href="#1059">comas (,)</a> (varias inicializaciones, condiciones o incrementos).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1068"> Punto y coma (;)</a> - <a href="#1025">Sentencia FOR</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="548">[BREAK] no aparece dentro de un bucle</h2><br/><br/>
La sentencia <a href="#1026">BREAK</a> provoca que el programa contin&#250;e tras el bucle que se est&#233; ejecutando.<br/><br/>
Esta sentencia sirve para salir de los siguientes bucles:<br/><br/>
<a href="#1024">LOOP</a> ... <a href="#1091">END</a><br/>
<a href="#1043">FROM</a> .. <a href="#1096">TO</a> .. <a href="#1095">STEP</a> .. ... <a href="#1091">END</a><br/>
<a href="#1023">REPEAT</a> ... <a href="#1097">UNTIL</a> <a href="#1053">(</a> .. <a href="#1053">)</a><br/>
<a href="#1022">WHILE</a> <a href="#1053">(</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
<a href="#1025">FOR</a> <a href="#1053">(</a> .. <a href="#1068">;</a> .. <a href="#1068">;</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
<br/><br/>
Un <a href="#1026">BREAK</a> provocar&#225; que el programa contin&#250;e ejecut&#225;ndose tras el <a href="#1091">END</a> o <a href="#1097">UNTIL</a> del bucle m&#225;s cercano a la sentencia. <a href="#1026">BREAK</a> s&#243;lo puede aparecer dentro de uno de estos bucles}.<br/><br/>
En caso de haber varios bucles anidados (unos dentro de otros) la sentencia <a href="#1026">BREAK</a> saldr&#225; unicamente del bucle m&#225;s interior de todos ellos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    LOOP
        REPEAT
            IF (key(_esc)) BREAK; END
            //...
        UNTIL (x==0);
        //...
    END
    BREAK; // Error: [BREAK] no aparece dentro de un bucle.
END
</pre>
En este ejemplo la sentencia <a href="#1026">BREAK</a> saldr&#225; del <a href="#1023">REPEAT</a> ... <a href="#1097">UNTIL</a> (cuando se pulse la tecla <strong>ESC</strong>) pero no del <a href="#1024">LOOP</a> ... <a href="#1091">END</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1026">Sentencia BREAK</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="549">[CONTINUE] no aparece dentro de un bucle</h2><br/><br/>
La sentencia <a href="#1027">CONTINUE</a> provoca que el programa finalice la iteraci&#243;n actual del bucle que se est&#233; ejecutando.<br/><br/>
Esta sentencia sirve para ir al inicio/final de los siguientes bucles:<br/><br/>
<a href="#1024">LOOP</a> ... <a href="#1091">END</a><br/>
Un <a href="#1027">CONTINUE</a> dentro de este bucle saltar&#225; al <a href="#1024">LOOP</a>.<br/><br/>
<a href="#1043">FROM</a> .. <a href="#1096">TO</a> .. <a href="#1095">STEP</a> .. ... <a href="#1091">END</a><br/>
Un <a href="#1027">CONTINUE</a> dentro de este bucle realizar&#225; el incremento (<a href="#1095">STEP</a>) y, si no se ha pasado el valor indicado en el <a href="#1096">TO</a>, continuar&#225; el programa al inicio del bucle.<br/><br/>
<a href="#1023">REPEAT</a> ... <a href="#1097">UNTIL</a> <a href="#1053">(</a> .. <a href="#1053">)</a><br/>
Un <a href="#1027">CONTINUE</a> dentro de este bucle saltar&#225; al <a href="#1097">UNTIL</a>.<br/><br/>
<a href="#1022">WHILE</a> <a href="#1053">(</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
Un <a href="#1027">CONTINUE</a> dentro de este bucle saltar&#225; al <a href="#1022">WHILE</a>.<br/><br/>
<a href="#1025">FOR</a> <a href="#1053">(</a> .. <a href="#1068">;</a> .. <a href="#1068">;</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
Un <a href="#1027">CONTINUE</a> dentro de este bucle realizar&#225; el incremento y la comparaci&#243;n; si &#233;sta &#250;ltima resulta cierta continuar&#225; el programa al inicio del bucle, pero si resulta falsa el programa continuar&#225; tras el <a href="#1091">END</a> del <a href="#1025">FOR</a>.<br/><br/>
<a href="#1027">CONTINUE</a> <strong>debe aparecer obligatoriamente dentro de uno de estos bucles</strong>.<br/><br/>
En caso de haber varios bucles anidados (unos dentro de otros) la sentencia <a href="#1027">CONTINUE</a> tendr&#225; efecto &#250;nicamente en el bucle m&#225;s interior de ellos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FOR (x=0, y=0;x&lt;10;x++)
        IF (x&lt;5) CONTINUE; END
        y++;
    END
END
</pre>
En este ejemplo tras ejecutarse el bucle completo <strong>x</strong> valdr&#225; <strong>10</strong> e <strong>y</strong> valdr&#225; <strong>5</strong>, pues mientras <strong>x</strong> es menor que 5 la sentencia <a href="#1027">CONTINUE</a> impide que se ejecute la sentencia <strong>y++;</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1027">Sentencia CONTINUE</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="550">Esperando [CASE], [DEFAULT] o [END]</h2><br/><br/>
La sintaxis de la sentencia <a href="#1021">SWITCH</a> es, a grandes rasgos, como sigue:<br/><br/>
<a href="#1021">SWITCH</a> <a href="#1053">( </a>expresi&#243;n<a href="#1053"> )</a><br/>
<a href="#1087">CASE</a> valor<a href="#1067"> :</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
<a href="#1087">CASE</a> valor<a href="#1064"> .. </a>valor<a href="#1067"> :</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
<a href="#1087">CASE</a> valor, valor, valor<a href="#1067"> :</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
//...<br/>
<a href="#1088">DEFAULT</a> <a href="#1067">:</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
<a href="#1091">END</a><br/><br/>
La posici&#243;n se&#241;alada en el programa est&#225; dentro de una sentencia <a href="#1021">SWITCH</a>, pero fuera de una secci&#243;n <a href="#1087">CASE</a> o <a href="#1088">DEFAULT</a>; por eso el compilador esperaba que en dicha posici&#243;n apareciera una de estas tres sentencias:<br/><br/>
- La palabra reservada <a href="#1087">CASE</a> iniciando una nueva secci&#243;n a ejecutar cuando la expresi&#243;n coincidiera con el valor indicado.<br/><br/>
- La palabra reservada <a href="#1088">DEFAULT</a> iniciando una secci&#243;n por defecto a ejecutar cuando la expresi&#243;n no coincidiera con ninguno de los valores indicados en las diferentes secciones <a href="#1087">CASE</a>.<br/><br/>
- La palabra reservada <a href="#1091">END</a> dando por finalizada la sentencia <a href="#1021">SWITCH</a>.<br/><br/>
Para ver una descripci&#243;n m&#225;s detallada de la sentencia <a href="#1021">SWITCH</a> consulte la sintaxis del lenguaje.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1021">Sentencia SWITCH</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="551">Esperando [END]</h2><br/><br/>
Se esperaba un <a href="#1091">END</a> del <a href="#1087">CASE</a> o <a href="#1088">DEFAULT</a> dentro de la sentencia <a href="#1021">SWITCH</a>.<br/><br/>
Dentro de las palabras reservadas <a href="#1021">SWITCH</a> y <a href="#1091">END</a> se espera una o m&#225;s secciones del tipo:<br/><br/>
<a href="#1087">CASE</a> ... <a href="#1091">END</a><br/>
<a href="#1088">DEFAULT</a> ... <a href="#1091">END</a><br/>
<br/><br/>
En el programa hay una de estas secciones que se esperaba que acabe con la palabra reservada <a href="#1091">END</a> pero acaba con otra palabra; el caso m&#225;s probable es:<br/><br/>
- Que se haya perdido un <a href="#1023">REPEAT</a> o un <a href="#1020">IF</a> acabando el bloque de sentencias con un <a href="#1097">UNTIL</a> o un <a href="#1090">ELSE</a>; en este caso se debe buscar el <a href="#1023">REPEAT</a> o <a href="#1020">IF</a> asociado.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    SWITCH (x)
        CASE 0:
            //REPEAT
            //...
            UNTIL (key(_esc)); // Error: Esperando [END]
        END
    END
END
</pre>
En este ejemplo la secci&#243;n que comenz&#243; con el <a href="#1087">CASE</a> ha acabado con un <a href="#1097">UNTIL</a> (puesto que se ha comentado accidentalmente el <a href="#1023">REPEAT</a>), y el compilador esperaba que esta secci&#243;n acabara con un <a href="#1091">END</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="552">Esperando [PROCESS] o [FUNCTION]</h2><br/><br/>
El compilador ha interpretado que, en la posici&#243;n se&#241;alada en el programa, ha finalizado el programa principal (<a href="#1015">PROGRAM</a> ... <a href="#1086">BEGIN</a> ... <a href="#1091">END</a>), o el &#250;ltimo proceso (<a href="#1016">PROCESS</a>) o funci&#243;n (<a href="#1408">FUNCTION</a>) y, a continuaci&#243;n, se esperaba que continuara otro proceso o bien que acabara el programa.<br/><br/>
Lo m&#225;s frecuente es haber duplicado un <a href="#1091">END</a> dentro del &#250;ltimo bloque de sentencias <a href="#1086">BEGIN</a> ... <a href="#1091">END</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    IF (x&lt;0) x++; END
    END
    FRAME; // Error: Esperando [PROCESS] o [FUNCTION].
END
</pre>
En este ejemplo se ha puesto accidentalmente dos veces el <a href="#1091">END</a> del <a href="#1020">IF</a>, interpretando el compilador que el segundo es el <a href="#1091">END</a> del <a href="#1086">BEGIN</a>, por lo tanto, tras este &#250;ltimo <a href="#1091">END</a> s&#243;lo puede venir el final del programa o las palabras reservadas <a href="#1016">PROCESS</a> o <a href="#1408">FUNCTION</a> marcando el inicio de un nuevo bloque. Al encontrarse en esa posici&#243;n una sentencia <a href="#1029">FRAME</a>, el compilador emite el error.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="553">No se puede especificar una tabla como par&#225;metro</h2><br/><br/>
No es necesario declarar dentro de la secci&#243;n <a href="#1008">PRIVATE</a> los <a href="#1018">par&#225;metros del proceso</a>, pues &#233;stos se declaran de forma autom&#225;tica; pero en caso de declararlos se deben declarar como variables no como tablas o estructuras, y no se deben inicializar.<br/><br/>
Lo m&#225;s probable es que se haya pretendido utilizar el mismo nombre para dos objetos diferentes; por un lado, para uno de los par&#225;metros del proceso y, por otro, para una tabla <a href="#1008">PRIVATE</a> del mismo proceso.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
END
PROCESS mi_proceso(a)
PRIVATE
    a[9]; // Error: No se puede especificar una tabla como par&#225;metro.
BEGIN
    //...
END
</pre>
El compilador interpreta que se est&#225; tipificando el par&#225;metro <strong>a</strong> como una tabla de 10 posiciones y como no se puede pasar una tabla como par&#225;metro, emite el error.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="554">No se puede inicializar un par&#225;metro</h2><br/><br/>
No es necesario declarar dentro de la secci&#243;n <a href="#1008">PRIVATE</a> los <a href="#1018">par&#225;metros del proceso</a>, ya que &#233;stos se declaran de forma autom&#225;tica, si bien en caso de declararlos se deben declarar como variables no como tablas o estructuras, y no se deben inicializar.<br/><br/>
Lo m&#225;s probable es que se haya pretendido utilizar el mismo nombre para dos objetos diferentes, por un lado, para uno de los par&#225;metros del proceso y, por otro, para una variable <a href="#1008">PRIVATE</a> del mismo proceso.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
END
PROCESS mi_proceso(a)
PRIVATE
    a=0; // Error: No se puede inicializar un par&#225;metro.
BEGIN
    //...
END
</pre>
El compilador interpreta que se est&#225; inicializando el par&#225;metro <strong>a</strong> a <strong>0</strong>, y como no est&#225; permitido inicializar un par&#225;metro (pues su valor lo tomar&#225; en funci&#243;n de la llamada al proceso), se emite el error.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="555">Lleg&#243; el final dentro de un comentario</h2><br/><br/>
Ha llegado el final del programa dentro de un comentario de varias l&#237;neas (los definidos entre los s&#237;mbolos<a href="#1002"> /*</a> y<a href="#1002"> */</a>).<br/><br/>
Este error se debe a que alg&#250;n comentario no se ha cerrado, por ello se debe revisar que todos los comentarios abiertos con el s&#237;mbolo<a href="#1002"> /*</a> tengan su correspondiente s&#237;mbolo<a href="#1002"> */</a> cerr&#225;ndolos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    /* Inicio del comentario
    FRAME;
END // Error: Lleg&#243; el final dentro de un comentario.
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1002">Definici&#243;n de comentarios</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="556">No se puede acceder a datos PRIVATE externos</h2><br/><br/>
En la posici&#243;n indicada del programa se intenta acceder a un dato de tipo <a href="#1008">PRIVATE</a> de otro proceso; no est&#225; permitido.<br/><br/>
Si se quiere acceder desde un proceso a un dato de otro proceso, &#233;ste se debe declarar dentro de la secci&#243;n <a href="#1007">LOCAL</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE n;
BEGIN
    mi_proceso();
    //...
END
PROCESS mi_proceso()
PRIVATE n;
BEGIN
    father.n=0; // No se puede acceder a datos PRIVATE externos.
END
</pre>
Es imposible acceder a datos <a href="#1008">PRIVATE</a> incluso cuando el proceso accedido es del mismo tipo que el proceso que est&#225; intentando acceder al dato.<br/><br/>
La forma correcta en la que se debe declarar la variable <strong>n</strong> en el ejemplo anterior es como se muestra a continuaci&#243;n:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
LOCAL n;
BEGIN
    mi_proceso();
    //...
END
PROCESS mi_proceso()
BEGIN
    father.n=0;
END
</pre>
Se recuerda que los datos declarados dentro de la secci&#243;n <a href="#1007">LOCAL</a> los tendr&#225;n todos los procesos del programa (todos los procesos del ejemplo anterior tendr&#225;n una variable propia de nombre <strong>n</strong>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1008">Declaraci&#243;n de datos PRIVATE</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="557">Una estructura debe contener, al menos, un elemento</h2><br/><br/>
En la posici&#243;n resaltada del programa se pretende cerrar con <a href="#1091">END</a> la declaraci&#243;n de una estructura sin ning&#250;n elemento (campo) definido en la misma.<br/><br/>
Una estructura (<a href="#1012">STRUCT</a>) es como una lista de fichas (registros) con varias informaciones (campos) en cada ficha.<br/><br/>
<strong>STRUCT nombre_estructura[10]</strong><br/>
<strong>x, y;</strong><br/>
<strong>END</strong><br/><br/>
En este ejemplo la estructura (conjunto de fichas) se llama <strong>nombre_estructura</strong> y tiene <strong>10 registros</strong> (diez fichas) con <strong>2 campos</strong> cada una (con dos informaciones; <strong>x</strong> e <strong>y</strong>).<br/><br/>
Por lo tanto, no tiene ning&#250;n sentido definir una estructura sin campos (ya que es como definir un conjunto de fichas sin ninguna informaci&#243;n).<br/><br/>
Para acceder despu&#233;s a la informaci&#243;n de las fichas se utiliza la estructura como sigue (sup&#243;ngase que se quiere poner en la variable global <strong>n</strong> el valor <strong>y</strong> de la ficha n&#250;mero <strong>5</strong>).<br/><br/>
<strong>n=nombre_estructura[5].y;</strong><br/><br/>
A continuaci&#243;n se muestra un programa err&#243;neo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT mi_estructura[10]

    END // Error: Una estructura debe contener, al menos, un elemento.
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1012">Declaraci&#243;n de Estructura</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="558">Esperando un elemento de la estructura</h2><br/><br/>
En la posici&#243;n se&#241;alada del programa se pretende declarar un elemento (campo) de la estructura no v&#225;lido.<br/><br/>
Una estructura puede tener &#250;nicamente campos de los siguientes tipos:<br/><br/>
- Una variable, en cuyo caso se deber&#225; indicar en la declaraci&#243;n el nombre de la misma, sin inicializar.<br/><br/>
- Una tabla, indicando el nombre de la misma y, a continuaci&#243;n, entre corchetes, la longitud de la misma (se recuerda que una tabla declarada como <strong>mi_tabla[9];</strong> es una tabla de <strong>10</strong> posiciones, desde mi_tabla[0] hasta mi_tabla[10]). Tampoco se deben inicializar.<br/><br/>
- Otra estructura. Es posible incluir estructuras dentro de otras estructuras, sin ning&#250;n l&#237;mite de anidamiento, hasta donde sea necesario. A continuaci&#243;n se muestra un ejemplo de anidamiento de estructuras.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT mi_estructura[9]
        elementos;
        STRUCT datos[9]
            x, y;
        END
    END
    a, b;
BEGIN
    FROM a=0 TO 9;
        mi_estructura[a].elementos=-1;
        FROM b=0 TO 9;
            mi_estructura[a].datos[b].x=-1;
            mi_estructura[a].datos[b].y=-1;
        END
    END
    //...
END
</pre>
En este ejemplo, cada registro de <strong>mi_estructura</strong> tendr&#225; una variable denominada <strong>elementos</strong> y otra estructura con 10 elementos cada uno con dos variables: <strong>x</strong> e <strong>y</strong>.<br/><br/>
M&#225;s adelante, en el mismo ejemplo, se puede observar un ejemplo de acceso a dicha estrucutra con dos bucles anidados que inicializan todos los valores de la estructura a<strong> -1</strong>.<br/><br/>
Para ver c&#243;mo se debe inicializar en propia definici&#243;n los valores de una estructura acceda al t&#243;pico <a href="#1000">sintaxis</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1012">Declaraci&#243;n de Estructura</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="560">No es un tipo de proceso</h2><br/><br/>
El operador <a href="#1042">TYPE</a> puede utilizarse &#250;nicamente si precede a un nombre de proceso del programa o a la palabra <a href="#1100">mouse</a> (para la detecci&#243;n de colisiones con el puntero del rat&#243;n).<br/><br/>
En la posici&#243;n se&#241;alada del programa no est&#225; precediendo a un nombre de proceso; es probable que se haya escrito el nombre del proceso incorrectamente o bien que se intente obtener el tipo de un proceso a partir de su <a href="#1039">c&#243;digo identificador</a>.<br/><br/>
Hay una forma de obtener el tipo de un proceso disponiendo de su <a href="#1039">c&#243;digo identificador</a>, como se muestra a continuaci&#243;n (sup&#243;ngase que el identificador se tiene en la variable <strong>id2</strong>).<br/><br/>
<strong>id2.reserved.process_type</strong><br/><br/>
En lugar de <strong>TYPE id2</strong> que no est&#225; permitido (pues no hay ning&#250;n proceso con el nombre <strong>id2</strong>, ya que <strong>id2</strong> es una variable).<br/><br/>
A continuaci&#243;n se muestra un ejemplo de uso correcto del operador <a href="#1042">TYPE</a> (con el fin de obtener el <a href="#1039">c&#243;digo identificador</a> de un proceso).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE
    id2;
BEGIN
    //...
    id2=get_id(TYPE mi_proceso);
    //...
    id2=get_id(TYPE id2); // Error: No es un tipo de proceso.
    //...
END
PROCESS mi_proceso()
BEGIN
    //...
END
</pre>
Como se puede observar, el operador <a href="#1042">TYPE</a> requiere el nombre de un proceso del programa sin par&#233;ntesis ni par&#225;metros.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1042">Tipos de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="561">No se puede calcular el tama&#241;o</h2><br/><br/>
La funci&#243;n <a href="#1094">sizeof()</a> se puede utilizar para obtener el n&#250;mero de elementos de una tabla o de una estructura; para ello requiere, entre <a href="#1053">par&#233;ntesis</a>, el nombre de la tabla o estructura (sin corchetes ni &#237;ndice).<br/><br/>
Tambi&#233;n se puede utilizar con el nombre de una variable pero, en este caso, la funci&#243;n devolver&#225; siempre 1.<br/><br/>
Se puede utilizar indistintamente con datos globales, locales o privados.<br/><br/>
En la posici&#243;n se&#241;alada del programa se pretende obtener el tama&#241;o de un objeto que no es una variable, tabla o estructura. Por ejemplo, este error se producir&#225; si se intenta obtener el tama&#241;o de una constante, funci&#243;n, proceso, etc.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    mi_constante=99;
GLOBAL
    a=sizeof(mi_constante); // Error: No se puede calcular el tama&#241;o.
BEGIN
    //...
END
</pre>
Este ejemplo provocar&#225; el error al intentar obtener el n&#250;mero de elementos de una <a href="#1004">constante</a>, pues una constante no es un objeto que tenga un tama&#241;o sino que, simplemente, es un s&#237;nonimo del valor num&#233;rico que representa.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1094">sizeof</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="562">Uso: IMPORT &quot;nombre.dll&quot;</h2><br/><br/>
El compilador esperaba que, tras la palabra reservada <a href="#1014">IMPORT</a>, apareciera entre comillas el nombre del archivo.<br/><br/>
Para declarar el uso de una librer&#237;a externa se debe poner una declaraci&#243;n como en el siguiente ejemplo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
IMPORT &quot;libreria.dll&quot;;
BEGIN
    //...
END
</pre>
Este programa declara el uso de la librer&#237;a denominada <strong>libreria.dll</strong> (supuesto nombre de una hipot&#233;tica librer&#237;a de funciones externas).<br/><br/>
La declaraci&#243;n debe hacerse justo <strong>tras la cabecera del programa</strong>, es decir, tras la declaraci&#243;n <strong>PROGRAM nombre_de_programa;</strong>. Pudiendo hacerse varias declaraciones <a href="#1014">IMPORT</a> seguidas, para declarar el uso de m&#225;s de una librer&#237;a.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1014">Declaraci&#243;n de librer&#237;as</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="563">Uso de una DLL externa no v&#225;lida</h2><br/><br/>
En la posici&#243;n indicada del programa se pretende cargar una <strong>DLL</strong> que no es v&#225;lida; esto puede deberse a uno de estos motivos:<br/><br/>
- El archivo con la <strong>DLL</strong> se ha corrompido al almacenarse en alg&#250;n medio defectuoso.<br/><br/>
- No se trata de una <strong>DLL</strong> espec&#237;ficamente dise&#241;ada para DIV Games Studio.<br/><br/>
- No se encuetra el archivo con extensi&#243;n <strong>DLL</strong> en la ruta especificada por la sentencia <a href="#1014">IMPORT</a>.<br/><br/>
No se pueden utilizar <strong>DLL</strong> de otros lenguajes, pues no son compatibles con este lenguaje aunque los archivos tengan todos la extension <strong>DLL</strong>.<br/><br/>
En caso de tratarse de una <strong>DLL</strong> preparada para este lenguaje, revise sus instrucciones de instalaci&#243;n y compruebe que el archivo con extensi&#243;n <strong>DLL</strong> se encuentra en el directorio de DIV Games Studio, o bien que la sentencia <a href="#1014">IMPORT</a> especifica la ruta completa de acceso a dicho archivo.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1014">Declaraci&#243;n de librer&#237;as</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="564">Expresi&#243;n sin sentido</h2><br/><br/>
En la posici&#243;n se&#241;alada en el programa el compilador ha supuesto que comenzaba una sentencia de uno de estos tipos:<br/><br/>
Asignaciones, ej.:<br/>
&lt;dato&gt;<strong> = </strong>&lt;expresi&#243;n&gt;<strong> ; </strong><br/><br/>
Incrementos o decrementos, ej.:<br/>
&lt;dato&gt;<strong> ++ ;</strong><br/><br/>
Llamada a un proceso o funci&#243;n, ej.:<br/>
&lt;nombre_proceso&gt;<strong> ( </strong>...<strong> ) ;</strong><br/><br/>
Pero, en su lugar, se ha encontrado con una expresi&#243;n que parece carecer de sentido, ya que una vez efectuadas sus operaciones no se utiliza el resultado de la misma con ning&#250;n prop&#243;sito.<br/><br/>
Es probable que se trate de alg&#250;n operador suelto que se ha dejado fuera de una sentencia, por ejemplo, por haberse perdido un operador.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x+1; // Error: Expresi&#243;n sin sentido.
    //...
END
</pre>
En este ejemplo se advierte de este error, pues la sentencia <strong>x+1;</strong> carece de utilidad, suma la variable <strong>x</strong> y la constante <strong>1</strong>, pero, desp&#250;es, no se utiliza este resultado para ning&#250;n fin. Si lo que se quiere es sumarle <strong>1</strong> a la variable <strong>x</strong> se debe hacer con la siguiente sentencia:<br/><br/>
<strong>x=x+1;</strong><br/><br/>
Aqu&#237; se suma la variable <strong>x</strong> y la constante <strong>1</strong> y despu&#233;s se utiliza este resultado para asign&#225;rselo a la variable <strong>x</strong>; esto tamb&#237;en se podr&#237;a haber hecho con la sentencia <strong>x++;</strong> (incrementar x).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Sentencia de asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="565">Esperando [:]</h2><br/><br/>
La posici&#243;n se&#241;alada en el programa est&#225; dentro de una sentencia <a href="#1021">SWITCH</a>, tras el comienzo de una secci&#243;n con &quot;<a href="#1087">CASE</a> valor&quot;, por eso el compilador esperaba que, en dicha posici&#243;n, apareciera el s&#237;mbolo<a href="#1067"> :</a> precediendo a las sentencias de dicha secci&#243;n.<br/><br/>
La sintaxis de la sentencia <a href="#1021">SWITCH</a> es, a grandes rasgos, como sigue:<br/><br/>
<a href="#1021">SWITCH</a> <a href="#1053">( </a>expresi&#243;n<a href="#1083"> )</a><br/>
<a href="#1087">CASE</a> valor<a href="#1067"> :</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
<a href="#1087">CASE</a> valor<a href="#"> .. </a>valor<a href="#1067"> :</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
<a href="#1087">CASE</a> valor, valor, valor<a href="#1067"> :</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
//...<br/>
<a href="#1088">DEFAULT</a> <a href="#1067">:</a><br/>
sentencias<a href="#1068">;</a><br/>
<a href="#1091">END</a><br/>
<a href="#1091">END</a><br/><br/>
Para ver una descripci&#243;n m&#225;s detallada de la sentencia <a href="#1021">SWITCH</a> consulte la sintaxis del lenguaje.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1021">Sentencia SWITCH</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="566">Esperando [;]</h2><br/><br/>
El compilador espera un <a href="#1068">punto y coma (;)</a> en la posici&#243;n indicada en el programa.<br/><br/>
En el lenguaje se deben indicar con puntos y coma los siguientes puntos del programa:<br/><br/>
- El final de las <a href="#1400">opciones de compilaci&#243;n</a>.<br/><br/>
- El final de la <a href="#1003">declaraci&#243;n PROGRAM</a>.<br/><br/>
- El final de una <a href="#1009">declaraci&#243;n de un dato</a>.<br/><br/>
- El final de una <a href="#1014">declaraci&#243;n IMPORT</a>.<br/><br/>
- El final de las siguientes sentencias:<br/>
<a href="#1019">Asignaciones o incrementos de datos</a>.<br/>
<a href="#1033">Llamadas a procesos</a>.<br/>
<a href="#1032">Llamadas a funciones</a>.<br/>
<a href="#1029">FRAME</a>, <a href="#1028">RETURN</a>, <a href="#1031">DEBUG</a>, <a href="#1026">BREAK</a> y <a href="#1027">CONTINUE</a>.<br/>
<br/><br/>
- El final de un inicio de bucle <a href="#1043">FROM</a>.<br/><br/>
- Y como separador de las diferentes partes de una sentencia <a href="#1025">FOR</a>.<br/><br/>
El compilador indicar&#225; cu&#225;ndo falta el s&#237;mbolo <strong>;</strong> en cualquiera de estos puntos.<br/><br/>
Pudiendo, adem&#225;s, ponerse dicho s&#237;mbolo en otros puntos determinados de los programas, como detr&#225;s de cualquier otro tipo de sentencia, aunque en este caso ser&#225; opcional y, por tanto, el compilador no advertir&#225; de su ausencia.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1068"> ; </a><br/><br/>
<hr/>
<br/><br/>
<h2 id="567">Esperando variable</h2><br/><br/>
El compilador esperaba una variable global, local o privada del proceso en la posici&#243;n indicada en el programa.<br/><br/>
La sintaxis de la sentencia de bucle <a href="#1043">FROM</a> es la siguiente:<br/><br/>
<strong>FROM</strong> &lt;variable&gt;<strong>=</strong><a href="#1005">&lt;constante&gt;</a> <a href="#1096">TO</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1095">STEP</a> <a href="#1005">&lt;constante&gt;</a><strong>;</strong><br/>
<a href="#1017">&lt;sentencia&gt;</a> <strong>;</strong><br/>
...<br/>
<strong>END</strong><br/><br/>
Siendo la declaraci&#243;n <strong>STEP &lt;constante&gt;</strong> opcional.<br/><br/>
Tras la palabra reservada <a href="#1043">FROM</a> debe aparecer directamente el <a href="#1001">nombre</a> de una variable (normalmente local o privada del proceso).<br/><br/>
Si se quiere utilizar como contador una variable de otro proceso, una tabla o un elemento de una estructura, se debe utilizar la sentencia <a href="#1025">FOR</a> en lugar de <a href="#1043">FROM</a>, ya que &#233;sta permite mayor libertad a la hora de definir las condiciones del bucle.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="568">Esperando [=]</h2><br/><br/>
El compilador esperaba un s&#237;mbolo <a href="#1073">=</a> (asignaci&#243;n) en la posici&#243;n indicada en el programa.<br/><br/>
La sintaxis de la sentencia de bucle <a href="#1043">FROM</a> es la siguiente:<br/><br/>
<strong>FROM</strong> &lt;variable&gt;<strong>=</strong><a href="#1005">&lt;constante&gt;</a> <a href="#1096">TO</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1095">STEP</a> <a href="#1005">&lt;constante&gt;</a><strong>;</strong><br/>
<a href="#1017">&lt;sentencia&gt;</a> <strong>;</strong><br/>
...<br/>
<strong>END</strong><br/><br/>
Siendo la declaraci&#243;n <a href="#1095">STEP &lt;constante&gt;</a> opcional.<br/><br/>
Tras la palabra reservada <a href="#1043">FROM</a> debe aparecer directamente el <strong>nombre</strong> de una variable (normalmente local o privada del proceso) y, tras &#233;ste, el s&#237;mbolo <a href="#1073">=</a> (asignaci&#243;n).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    id2;
BEGIN
    //...
    FROM id2.x=0 TO 9; // Error: Esperando [=].
        //...
    END
END
</pre>
En este ejemplo el error se produce al detectarse tras el <strong>primer nombre</strong> que aparece (<strong>id2</strong>) el s&#237;mbolo<a href="#1063"> . (punto)</a> en lugar de <a href="#1073">=</a>. Esto sucede porque no se puede utilizar como contador de un bucle <a href="#1043">FROM</a> una variable de otro proceso.<br/><br/>
Si se quiere utilizar como contador una variable de otro proceso, una tabla o un elemento de una estructura, se debe utilizar la sentencia <a href="#1025">FOR</a>, en lugar de <a href="#1043">FROM</a>, ya que &#233;sta permite mayor libertad a la hora de definir las condiciones del bucle.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="569">Esperando [TO]</h2><br/><br/>
El compilador esperaba la palabra reservada <a href="#1096">TO</a> de la sentencia <a href="#1043">FROM</a> en la posici&#243;n indicada en el programa.<br/><br/>
La sintaxis de la sentencia de bucle <a href="#1043">FROM</a> es la siguiente:<br/><br/>
<a href="#1043">FROM</a> &lt;variable&gt;<strong>=</strong><a href="#1005">&lt;constante&gt;</a> <a href="#1096">TO</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1095">STEP</a> <a href="#1005">&lt;constante&gt;</a><strong>;</strong><br/>
<a href="#1017">&lt;sentencia&gt;</a> <strong>;</strong><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
Siendo la declaraci&#243;n <a href="#1095">STEP &lt;constante&gt;</a> opcional.<br/><br/>
Tras la palabra reservada <a href="#1043">FROM</a> debe aparecer directamente el <strong>nombre</strong> de una variable (normalmente local o privada del proceso) y, tras &#233;ste, el s&#237;mbolo <a href="#1073">=</a> (asignaci&#243;n) precediendo a una constante. {Tras este valor constante s&#243;lo puede aparecer la palabra reservada <a href="#1096">TO</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    id2;
BEGIN
    //...
    FROM id2.x=0 STEP 9; // Error: Esperando [TO].
        //...
    END
END
</pre>
En una sentencia <a href="#1043">FROM</a> siempre deben aparecer los valores <strong>inicial</strong> y <strong>final</strong> de la variable contador del bucle a ambos lados de la palabra <a href="#1096">TO</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="570">El valor STEP no es v&#225;lido</h2><br/><br/>
En una sentencia <a href="#1043">FROM</a>:<br/><br/>
- Si el valor inicial <strong>es menor</strong> que el valor final, no se puede especificar un valor negativo en la declaraci&#243;n <a href="#1095">STEP</a>.<br/><br/>
- Si el valor inicial <strong>es mayor</strong> que el valor final, no se puede especificar un valor positivo en la declaraci&#243;n <a href="#1095">STEP</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FROM x=0 TO 10 STEP -1; // Error: El valor STEP no es v&#225;lido.
        //...
    END
END
</pre>
Este bucle no es v&#225;lido pues si a <strong>x</strong>, que originalmente valdr&#225; <strong>0</strong>, se le resta <strong>1</strong> en cada iteraci&#243;n, no llegar&#225; nunca a <strong>10</strong>. Si lo que se pretende es hacer un bucle que se repita siempre, se debe utilizar la sentencia <a href="#1024">LOOP</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="571">Sentencia FROM incorrecta</h2><br/><br/>
En una sentencia <a href="#1043">FROM</a>:<br/><br/>
- Los valores <strong>inicial</strong> y <strong>final</strong> de un bucle <a href="#1043">FROM</a> deben ser diferentes.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FROM x=0 TO 0; // Error: Sentencia FROM incorrecta.
        //...
    END
END
</pre>
Realizar este bucle no tiene sentido, pues no se va a repetir el grupo interior de sentencias m&#225;s que una sola vez, lo que ser&#237;a equivalente a inicializar <strong>x</strong> a <strong>0</strong> (con la sentencia <strong>x=0;</strong>) y, despu&#233;s, poner directamente las sentencias interiores, omitiendo el bucle <a href="#1043">FROM</a>.<br/><br/>
Si lo que se pretende es hacer un bucle que se repita siempre, se debe utilizar la sentencia <a href="#1024">LOOP</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="599">Compilaci&#243;n correcta</h2><br/><br/>
El programa no tiene errores de compilaci&#243;n, pulse:<br/><br/>
<strong>Men&#250; programas\Ejecutar</strong> o <strong>F10</strong>.<br/>
Para grabar, compilar y ejecutar el programa.<br/><br/>
<strong>Men&#250; programas\Trazar</strong> o <strong>F12</strong>.<br/>
Para grabar, compilar y trazar paso a paso el programa.<br/><br/>
<hr/>
<br/><br/>
<h2 id="600">Excedida la capacidad del vector de nombres</h2><br/><br/>
Se excedi&#243; el buffer para almacenar los <a href="#1001">nombres</a> del programa; este error puede deberse &#250;nicamente a que se han utilizado nombres de datos y procesos demasiado largos.<br/><br/>
La &#250;nica soluci&#243;n para poder compilar el programa es sustituir algunos de estos nombres por otros m&#225;s peque&#241;os.<br/><br/>
<hr/>
<br/><br/>
<h2 id="601">Excedida la capacidad de la versi&#243;n demo</h2><br/><br/>
Esta versi&#243;n DEMO de DIV Games Studio no permite crear programas tan grandes como este, s&#243;lo puede compilar programas de un determinado n&#250;mero de variables y procesos.<br/><br/>
En la versi&#243;n completa de DIV GAMES STUDIO no existe esta limitaci&#243;n, pudi&#233;ndose crear programas de cualquier tama&#241;o.<br/><br/>
La &#250;nica opci&#243;n para poder compilar este programa es eliminando primero todos los procesos y datos que ya no se requieran y/o no sean imprescindibles.<br/><br/>
<hr/>
<br/><br/>
<h2 id="602">Excedida la capacidad de la tabla de objetos</h2><br/><br/>
Se excedi&#243; el espacio disponible para guardar registros de los datos y los procesos del programa.<br/><br/>
Este error no deber&#237;a suceder nunca pero si ha sucedido tiene dif&#237;cil soluci&#243;n; el programa es demasiado grande para esta versi&#243;n del compilador.<br/><br/>
Si existe una nueva versi&#243;n del compilador o alg&#250;n &#39;patch&#39; que actualice esta limitaci&#243;n, debe actualizarse.<br/><br/>
En caso contrario la &#250;nica opci&#243;n es eliminar del programa todos los procesos y <a href="#1034">datos</a> que ya no se requieran y/o no sean imprescindibles.<br/><br/>
<hr/>
<br/><br/>
<h2 id="610">Esperando el nombre de la estructura</h2><br/><br/>
Para definir una estructura de datos se debe especificar el nombre de la misma tras la palabra reservada <a href="#1012">STRUCT</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT posiciones[9]
        x, y;
    END
BEGIN
    //...
END
</pre>
Esta estructura se ha definido con el nombre <strong>posiciones</strong> y contiene <strong>diez registros</strong> (del 0 al 9) cada uno con dos valores <strong>x</strong> e <strong>y</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1012">Declaraci&#243;n Estructuras</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="611">Esperando el nombre del proceso o funci&#243;n</h2><br/><br/>
Para definir un proceso o funci&#243;n se debe especificar el nombre del mismo tras las palabras reservadas <a href="#1016">PROCESS</a> o <a href="#1408">FUNCTION</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
END

PROCESS mi_proceso()
BEGIN
    //...
END
</pre>
Este proceso se ha declarado con el nombre <strong>mi_proceso</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="612">Esperando el nombre de un proceso</h2><br/><br/>
Tras la palabra reservada <a href="#1042">TYPE</a> se debe especificar el nombre de uno de los procesos definidos en el programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
    signal(TYPE mi_proceso, s_kill);
    //...
END

PROCESS mi_proceso()
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1042">Tipos de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="613">Esperando un nombre</h2><br/><br/>
La funci&#243;n <a href="#1094">sizeof()</a> requiere como par&#225;metro el nombre de un dato, pudiendo ser el nombre de una variable, una tabla o una estructura del programa.<br/><br/>
Esta funci&#243;n devuelve el numero de datos (o elementos) que tiene el objeto cuyo nombre se le pasa como argumento; por lo tanto, si dicho objeto era una variable, la funci&#243;n siempre devolver&#225; 1.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla[]=0, 1, 2, 3;
    longitud_tabla;
BEGIN
    longitud_tabla=sizeof(tabla);
END
</pre>
En este ejemplo <strong>longitud_tabla</strong> valdr&#225; <strong>4</strong> tras ejecutarse la sentencia, ya que la tabla contiene cuatro datos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1094">sizeof</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="614">El nombre no es nuevo</h2><br/><br/>
Se ha utilizado un nombre para un campo de la estructura dos veces. Debe sustituir dicho nombre por otro similar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
GLOBAL
    STRUCT posicion[9]
        x0, x0; // Error: El nombre no es nuevo.
    END
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1012">Declaraci&#243;n de estructura</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="615">El nombre no es nuevo</h2><br/><br/>
Se ha utilizado un <a href="#1001">nombre</a> de programa no v&#225;lido pues &#233;ste ya estaba predefinido como nombre de otro objeto. Debe sustituir dicho nombre por otro similar.<br/><br/>
Para saber a qu&#233; objeto est&#225; identificado con dicho <a href="#1001">nombre</a> puede acceder al <strong>glosario</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM x; // Error: El nombre no es nuevo.
BEGIN
    //...
END
</pre>
En este ejemplo se pretend&#237;a utilizar como nombre del programa <strong>x</strong>, que est&#225; predefinido como nombre de la variable local que indica la coordenada x de los procesos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="616">El nombre no es nuevo</h2><br/><br/>
Se ha utilizado para definir una <a href="#1004">constante</a> un <a href="#1001">nombre</a> no v&#225;lido, pues &#233;ste ya estaba predefinido como nombre de otro objeto. Puede tratarse de un nombre de una constante, una variable, una tabla, una estructura, un proceso o una funci&#243;n del programa.<br/><br/>
Puede ser, tambi&#233;n, que se haya pretendido utilizar el mismo <a href="#1001">nombre</a> dentro del programa para identificar dos objetos diferentes, o bien <strong>puede que se haya utilizado un nombre predefinido para otro uso dentro del lenguaje</strong>. En dicho caso se puede acceder al <strong>glosario</strong> para ver a qu&#233; objeto se refiere dicho nombre.<br/><br/>
Debe sustituir dicho nombre por otro similar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    x=0; // Error: El nombre no es nuevo.
BEGIN
    //...
END
</pre>
En este ejemplo se pretend&#237;a utilizar como nombre de una constante <strong>x</strong> que est&#225; predefinido como variable local que indica la coordenada <a href="#1123">x</a> de los procesos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="617">El nombre no es nuevo</h2><br/><br/>
Se ha utilizado para definir un nuevo dato un <a href="#1001">nombre</a> no v&#225;lido, pues &#233;ste ya estaba predefinido como nombre de otro objeto. Puede tratarse de un nombre de una <a href="#1004">constante</a>, una variable, una tabla, una estructura, un proceso o una funci&#243;n del programa.<br/><br/>
Asimismo, puede ser que se haya pretendido utilizar el mismo nombre dentro del programa para identificar dos objetos diferentes, o bien <strong>que se haya utilizado un nombre predefinido para otro uso dentro del lenguaje</strong>. En dicho caso se puede acceder al <strong>glosario</strong> para ver a qu&#233; objeto se refiere dicho nombre.<br/><br/>
Debe sustituir dicho nombre por otro similar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    x[3]=0, 1, 2, 3; // Error: El nombre no es nuevo.
BEGIN
    //...
END
</pre>
En este ejemplo se pretend&#237;a utilizar como nombre de una tabla global <strong>x</strong> que est&#225; predefinido como variable local que indica la coordenada <a href="#1123">x</a> de los procesos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="618">El nombre no es nuevo</h2><br/><br/>
Se ha utilizado un <a href="#1001">nombre</a> de un proceso no v&#225;lido pues &#233;ste ya estaba predefinido como nombre de otro objeto. Puede tratarse de un nombre de una <a href="#1004">constante</a>, una variable, una tabla, una estructura, un proceso o una funci&#243;n del programa.<br/><br/>
Puede ser que se haya pretendido utilizar el mismo nombre dentro del programa para identificar dos objetos diferentes, o bien <strong>puede que se haya utilizado un nombre predefinido para otro uso dentro del lenguaje</strong>. En dicho caso puede acceder al <strong>glosario</strong> para ver a que objeto se refiere dicho nombre.<br/><br/>
Debe sustituir dicho nombre por otro similar.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
END

PROCESS mi_juego() // Error: El nombre no es nuevo.
BEGIN
    //...
END
</pre>
En este ejemplo se pretend&#237;a utilizar como nombre de un proceso el nombre que anteriormente se hab&#237;a empleado para identificar el programa principal.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="619">Esperando [=]</h2><br/><br/>
Para definir una constante se debe poner un s&#237;mbolo <a href="#1073">=</a> tras el nombre de la constante.<br/><br/>
El compilador ha entendido que la &#250;ltima palabra definida era el nombre de una nueva <a href="#1004">constante</a> y, en la posici&#243;n que se indica, se esperaba que se mostrara el s&#237;mbolo de asignaci&#243;n (<a href="#1073">=</a>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    a=0;
    b=1;
    c,d; // Error: Esperando [=].
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="620">Demasiados valores para la estructura</h2><br/><br/>
Se ha inicializado una estructura con m&#225;s valores de los que puede contener.<br/><br/>
Para inicializar una estructura se debe tener en cuenta el n&#250;mero de valores m&#225;ximo que puede contener; este n&#250;mero ser&#225;:<br/><br/>
<strong>N&#186; de registros</strong> X <strong>N&#186; de campos</strong><br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT posiciones[9]
        x, y;
    END = 10 dup (-99, 99);
BEGIN
    //...
END
</pre>
En este caso la estructura <strong>posiciones</strong> tiene <strong>10 registros</strong> (desde posiciones[0] hasta posiciones[9]) y <strong>2 campos</strong> (x e y); luego, el n&#250;mero m&#225;ximo de valores que puede contener es <strong>20</strong>. En el ejemplo se inicializan todos los campos <strong>x</strong> a<strong> -99</strong> y todos los campos <strong>y</strong> a <strong>99</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1012">Declaraci&#243;n de estructura</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="621">Nombre desconocido</h2><br/><br/>
En la posici&#243;n indicada del programa se hace referencia a un bloque <a href="#1016">PROCESS</a> o <a href="#1408">FUNCTION</a> inexistente; puede tratarse de uno de los siguientes casos:<br/><br/>
- Se ha tecleado incorrectamente el nombre de un proceso o funci&#243;n; revise el nombre original pues puede que sea en su definici&#243;n donde el nombre no aparece correctamente.<br/><br/>
- Se ha pretendido utilizar una funci&#243;n del lenguaje y no se ha escrito su nombre correctamente; en este caso puede acceder a la ayuda para buscar el nombre exacto de la funci&#243;n.<br/><br/>
- Se hace referencia a un proceso o funci&#243;n cuyo c&#243;digo a&#250;n no se ha definido, por ello si se quiere compilar el programa se debe definir el bloque, al menos, como sigue:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    mi_proceso();
END

PROCESS mi_proceso()
BEGIN
END
</pre>
Indicando en el nuevo bloque los par&#225;metros que recibe (en el ejemplo anterior no recibe ning&#250;n par&#225;metro).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="622">No se puede realizar el incremento</h2><br/><br/>
En la expresi&#243;n indicada en el programa se utiliza el operador <a href="#1057"> ++</a> (o el operador<a href="#1061"> --</a>) incorrectamente, con el fin de incrementar (o decrementar) un objeto. Dicho objeto no tiene direcci&#243;n, pues no es una variable, tabla o estructura, por lo que el compilador no puede realizar un incremento (o decremento) sobre el mismo.<br/><br/>
Probablemente se haya pretendido incrementar o decrementar una expresi&#243;n constante o una que involucre varios operandos.<br/><br/>
A continuaci&#243;n, se muestra un programa con varios ejemplos de uso v&#225;lido de los operadores<a href="#1057"> ++</a> y<a href="#1061"> --</a>, y otros tantos inv&#225;lidos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    mi_constante=0;
GLOBAL
    mi_variable=0;
    mi_tabla[10];
    STRUCT mi_estructura[10]
        variable;
    END
BEGIN
    // Ejemplos correctos
    mi_variable++;
    mi_tabla--;
    ++mi_tabla[mi_variable];
    --mi_estructura[0].variable;
    id.x++;

    // Ejemplos err&#243;neos
    (mi_variable*2)++;
    mi_constante--;
    ++0;
    --(mi_variable+1);
END
</pre>
Las constantes como <strong>mi_constante</strong> no se pueden incrementar pues son simples sin&#243;nimos del valor num&#233;rico que representan.<br/><br/>
La sentencia <strong>(mi_variable*2)++;</strong> es err&#243;nea debido a que la multiplicaci&#243;n se realiza en primer lugar y, una vez realizada, el valor <strong>mi_variable*2</strong> se convierte en un resultado num&#233;rico que no tiene direcci&#243;n y, por lo tanto, no se puede acceder a ella para incrementarlo.<br/><br/>
En este caso, probablemente, la sentencia correcta que se deber&#237;a haber utilizado habr&#237;a sido <strong>mi_variable=mi_variable*2+1;</strong><br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1057">++</a> - <a href="#1061">--</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="623">Estructura de longitud negativa</h2><br/><br/>
Para definir una estructura indicando entre <a href="#1079">corchetes</a> su n&#250;mero de registros se debe emplear un n&#250;mero entero positivo (0, 1, 2, 3, ...), teniendo en cuenta que todas las estructuras comienzan en el registro cero y terminan en el registro que se indique en el &#237;ndice.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT e1[9]
      x, y;
    END
    STRUCT e2[-9] // Error: Estructura de longitud negativa.
      x, y;
    END
BEGIN
    //...
END
</pre>
El compilador ha detectado una estructura definida con un n&#250;mero negativo de registros como <strong>e2</strong>; en este ejemplo se debe definir la estructura como <strong>e1</strong> que, en este caso, ser&#225; una estructura de 10 registros (desde e1[0] hasta e1[9]) y dos campos (x e y).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1012">Declaraci&#243;n de estructura</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="624">Se esperaba una sentencia</h2><br/><br/>
La posici&#243;n indicada en el programa est&#225; dentro del contexto de un bloque de sentencias, por lo que se esperaba que comenzara una sentencia en la posici&#243;n indicada. &#201;stos son los posibles tipos de sentencias:<br/><br/>
sentencias de asignaci&#243;n<br/>
&lt;expresi&#243;n&gt;<a href="#1035">=</a>&lt;expresi&#243;n&gt;;<br/><br/>
sentencias de control<br/>
<a href="#1020">IF</a> y <a href="#1021">SWITCH</a>.<br/><br/>
sentencias de bucles<br/>
<a href="#1043">FROM</a>, <a href="#1022">WHILE</a>, <a href="#1023">REPEAT</a>, <a href="#1024">LOOP</a> y <a href="#1025">FOR</a>.<br/><br/>
sentencias de ruptura<br/>
<a href="#1026">BREAK</a>, <a href="#1027">CONTINUE</a> y <a href="#1028">RETURN</a>.<br/><br/>
sentencias especiales<br/>
<a href="#1029">FRAME</a>, <a href="#1030">CLONE</a> y <a href="#1031">DEBUG</a>.<br/><br/>
Siendo posible que en esta posici&#243;n apareciera una de las palabras reservadas que pueden marcar el final de un bloque de sentencias, como son:<br/><br/>
<a href="#1091">END</a>, <a href="#1090">ELSE</a> y <a href="#1097">UNTIL</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    CASE 0: // Error: Se esperaba una sentencia.
        //...
    END
END
</pre>
Este ejemplo provocar&#225; el error, dado que la palabra reservada <a href="#1087">CASE</a> no es v&#225;lida para comenzar una sentencia; s&#243;lo es v&#225;lida dentro de una sentencia <a href="#1021">SWITCH</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1017">Declaraci&#243;n de sentencia</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="625">Esperando el nombre de la cadena</h2><br/><br/>
Para definir una cadena de texto se debe especificar el nombre de la misma tras la palabra reservada <strong>STRING</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING jugador[32];
    STRING mensaje;
BEGIN
    //...
END
</pre>
En este ejemplo se han definido dos cadenas de texto globales. La primera con el nombre <strong>jugador</strong> que puede almacenar hasta 32 car&#225;cteres y la segunda con el nombre <strong>mensaje</strong> que, como no declara su longitud, podr&#225; almacenar hasta 256 car&#225;cteres (ya que este es el tama&#241;o establecido por defecto a las cadenas de texto).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="626">El nombre no es nuevo</h2><br/><br/>
Como nombre de la cadena de texto se ha utilizado uno que ya estaba relacionado con otro objeto anteriormente definido. Puede tratarse de un nombre, de una constante, una variable, una tabla, una estructura, un proceso o una funci&#243;n del programa.<br/><br/>
Tambi&#233;n puede que se haya pretendido utilizar el mismo nombre dentro del programa para identificar dos objetos diferentes, o bien <strong>que se haya utilizado un nombre predefinido para otro uso dentro del lenguaje</strong>. En dicho caso, se puede acceder al glosario para ver a qu&#233; objeto se refiere dicho nombre.<br/><br/>
De todas formas, <strong>debe sustituir dicho nombre por otro similar</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
GLOBAL
    jugador=0;
    STRING jugador; // Error: El nombre no es nuevo.
BEGIN
  //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="627">Cadena de texto de longitud negativa</h2><br/><br/>
Para definir una cadena de texto indicando entre corchetes su longitud se debe emplear un n&#250;mero entero positivo (0, 1, 2, 3, ...), teniendo en cuenta que todas las cadenas comienzan en la posici&#243;n cero y terminan en la posici&#243;n que indicada en el &#237;ndice.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[9];
    STRING cadena2[-9]; // Error: Cadena de texto de longitud negativa.
BEGIN
    //...
END
</pre>
El compilador ha detectado una cadena de texto definida con una longitud negativa como <strong>cadena2</strong>; en este ejemplo se debe definir la cadena como <strong>cadena1</strong> que, en este caso, ser&#225; una cadena de hasta 10 car&#225;cteres (desde cadena1[0] hasta cadena1[9]).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="628">Se esperaba un literal</h2><br/><br/>
Los literales son los <strong>textos entre comillas</strong>. En la posici&#243;n indicada del programa se esperaba un literal como valor inicial de una cadena de texto.<br/><br/>
Las cadenas de texto se pueden inicializar como se muestra en el siguiente ejemplo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING cadena=&quot;Texto inicial en la cadena&quot;;
BEGIN
    //...
END
</pre>
No siendo obligatoria la inicializaci&#243;n de las cadenas de texto de un programa. En caso de no inicializarse, la cadena contendr&#237;a un texto vac&#237;o (&quot;&quot;) al inicio del programa, es decir, que la siguientes dos declaraciones ser&#225;n id&#233;nticas:<br/><br/>
<strong>STRING</strong> cadena;<br/>
<strong>STRING</strong> cadena<strong>=</strong>&quot;&quot;<strong>;</strong><br/><br/>
En estos casos, al no declarar su longitud, ambas cadenas podr&#225;n almacenar hasta un m&#225;ximo de 256 car&#225;cteres (ya que este es el tama&#241;o establecido por defecto a las cadenas de texto).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="629">Literal demasiado largo</h2><br/><br/>
Se ha inicializado una cadena de texto con un literal con m&#225;s car&#225;cteres de los que la cadena puede contener.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[3]=&quot;ABCDE&quot;; // Error: Literal demasiado largo
BEGIN
    //...
END
</pre>
Para inicializar una cadena de texto se debe tener en cuenta que, como m&#225;ximo, puede tener tantos car&#225;cteres como indique el n&#250;mero que va entre los corchetes m&#225;s 1.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[3]=&quot;ABCD&quot;;
BEGIN
    //...
END
</pre>
En este caso la cadena de texto <strong>cadena1</strong> puede contener cuatro car&#225;cteres (cadena1[0]=char(&quot;A&quot;), cadena1[1]=char(&quot;B&quot;), cadena1[2]=char(&quot;C&quot;) y cadena1[3]=char(&quot;D&quot;)).<br/><br/>
Otra opci&#243;n es <strong>no indicar el tama&#241;o de la cadena de texto</strong>, asign&#225;ndose en este caso a la cadena de texto un tama&#241;o m&#225;ximo de 256 car&#225;cteres.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING cadena1=&quot;ABCDEF&quot;;
BEGIN
    //...
END
</pre>
En este caso, <strong>cadena1</strong> contendr&#237;a inicialmente los seis car&#225;cteres indicados (&quot;ABCDEF&quot;), pero podr&#237;a llegar a contener hasta 256 durante la ejecuci&#243;n del programa.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="630">Se esperaba una coma</h2><br/><br/>
Se est&#225; accediendo una tabla indicando menos dimensiones de las requeridas.<br/><br/>
Es decir, que una tabla de dos dimensiones se prentende utilizar como si fuera de s&#243;lo una dimension, o bien que una tabla de tres dimensiones se prentende utilizar como si fuera de dos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    tabla1[9,9];
BEGIN
    //...
    tabla1[0]=0; // Error: Se esperaba una coma.
END
</pre>
Revise la declaraci&#243;n anterior en el programa de dicha tabla de datos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="631">Se esperaba una coma</h2><br/><br/>
Se est&#225; accediendo una estructura indicando menos dimensiones de las requeridas.<br/><br/>
Es decir, que una estructura de dos dimensiones se prentende utilizar como si fuera de s&#243;lo una dimensi&#243;n, o bien que una estructura de tres dimensiones se prentende utilizar como si fuera de dos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT estructura1[9,9];
      n;
      //...
    END
BEGIN
    //...
    estructura1[0].n=0; // Error: Se esperaba una coma.
END
</pre>
Revise la declaraci&#243;n anterior en el programa de dicha estructura de datos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="632">No se puede calcular el offset del dato</h2><br/><br/>
En la expresi&#243;n indicada en el programa se utiliza el operador <a href="#1085">offset</a> (o el s&#237;mbolo sin&#243;nimo <a href="#1085">&amp;</a>) con el fin de obtener la direcci&#243;n (desplazamiento) de un <a href="#1406">car&#225;cter</a>, <a href="#1404">byte</a> o <a href="#1403">word</a> perteneciente a una tabla.<br/><br/>
Esto no est&#225; permitido, &#250;nicamente es posible obtener la direcci&#243;n del inicio de la tabla, pero no de un dato de la misma (excepto con datos de tipo <a href="#1402">int</a>).<br/><br/>
A continuaci&#243;n se muestra un programa con dos ejemplos del uso del operador <a href="#1085">offset</a> (o bien el s&#237;mbolo <strong>&amp;</strong>) para tablas de tipo <a href="#1404">byte</a>; uno v&#225;lido y otro no.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    BYTE mi_tabla[99];
    offset_dato;
BEGIN
    // Ejemplo correcto
    offset_dato=offset mi_tabla;

    // Ejemplo err&#243;neo
    offset_dato=offset mi_tabla[1];
END
</pre>
<hr/>
<br/><br/>
Esto es tambi&#233;n aplicable a <strong>cadenas de texto</strong> (datos de tipo <a href="#1406">string</a>), es decir, que tampoco se puede obtener la direcci&#243;n de un car&#225;cter de dentro de la cadena.<br/><br/>
Adem&#225;s, el operador <a href="#1085">offset</a> no es necesario para obtener el desplazamiento de una cadena de texto (puede ser omitido). Es decir, que estas dos sentencias ser&#237;an igualmente v&#225;lidas:<br/><br/>
offset_cadena<strong>=</strong>offset mi_cadena<strong>;</strong><br/>
offset_cadena<strong>=</strong>mi_cadena<strong>;</strong><br/><br/>
<strong>Nota:</strong> Para operar con las cadenas de texto debe utilizar las funciones del lenguaje que han sido dise&#241;adas con tal fin (v&#233;ase por ejemplo <a href="#202">strcpy()</a>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1085">offset</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="633">Asignaci&#243;n a cadena incorrecta</h2><br/><br/>
Con las cadenas de texto &#250;nicamente se pueden realizar asignaciones de tres tipos:<br/><br/>
- Asignaciones convencionales (=), se har&#225; una copia de la cadena.<br/><br/>
- Suma y asignaci&#243;n (+=), se a&#241;adir&#225; la subcadena.<br/><br/>
- Resta y asignaci&#243;n (-=), se eliminar&#225;n car&#225;cteres de la cadena.<br/><br/>
En la posici&#243;n se&#241;alada del programa se ha intentado probablemente alg&#250;n otro tipo de asignaci&#243;n operativa con una <strong>cadena de texto</strong>. Dicha operaci&#243;n no es posible, ya que carece de sentido alguno.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Definici&#243;n de expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="635">Cadena de texto demasiado larga</h2><br/><br/>
Para definir una cadena de texto indicando entre corchetes su longitud se debe emplear un n&#250;mero entero <strong>menor que 1048576</strong>, teniendo en cuenta que todas las cadenas comienzan en la posici&#243;n cero y terminan en la posici&#243;n que indicada en el &#237;ndice.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRING cadena1[29999999]; // Error: Cadena de texto demasiado larga.
BEGIN
    //...
END
</pre>
El compilador ha detectado una cadena de texto definida con una longitud excesiva, como <strong>cadena1</strong>; como m&#225;ximo se podr&#237;a haber declarado una cadena de texto de 1 Megabyte, con la siguiente declaraci&#243;n:<br/><br/>
<strong>STRING</strong> cadena1<strong>[</strong>1048575<strong>];</strong><br/><br/>
Pudiendo contener <strong>cadena1</strong> hasta <strong>1024*1024</strong> car&#225;cteres, es decir, desde cadena1[0] hasta cadena1[1048575].<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="636">Inicializaci&#243;n incorrecta</h2><br/><br/>
El n&#250;mero de valores indicados en la inicializaci&#243;n no coincide con la declaraci&#243;n previa de la estructura.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT mi_estructura[9];
        STRING nombre;
        x,y;
    END = 10 dup (&quot;AAA&quot;,0); // Error: Inicializaci&#243;n incorrecta.
BEGIN
    //...
END
</pre>
En el ejemplo anterior se declara una estructura de tres campos, y despu&#233;s se inicializa como si &#250;nicamente tuviera dos.<br/><br/>
Debe revisar la declaraci&#243;n previa, recordando siempre que una estructura como <strong>mi_estructura[9]</strong> tiene <strong>10</strong> registros (del <strong>0</strong> al <strong>9</strong>). Por ejemplo, una inicializaci&#243;n v&#225;lida para la estructura anterior ser&#237;a la siguiente:<br/><br/>
10 <strong>dup (</strong>&quot;AAA&quot;<strong>,</strong> 0<strong>,</strong> 0<strong>);</strong><br/><br/>
Ya que inicializa <strong>10 registros</strong> de <strong>3  campos</strong>, acorde a la declaraci&#243;n de <strong>mi_estructura</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="637">Esperando [;]</h2><br/><br/>
El compilador espera un <a href="#1068">punto y coma (;)</a> en la posici&#243;n indicada en el programa.<br/><br/>
En el lenguaje se debe indicar con un punto y coma el final de una declaraci&#243;n de un dato.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1068"> ; </a><br/><br/>
<hr/>
<br/><br/>
<h2 id="638">Esperando una opci&#243;n de compilaci&#243;n</h2><br/><br/>
El compilador esperaba una opci&#243;n de compilaci&#243;n en la posici&#243;n indicada del programa.<br/><br/>
Ver las <a href="#1400">opciones de compilaci&#243;n</a> disponibles en esta versi&#243;n del lenguaje.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1003">Cabecera de programa</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="639">Esperando [=]</h2><br/><br/>
Para establecer un n&#250;mero m&#225;ximo de procesos se debe utilizar la sentencia <a href="#1400">compiler_options</a> como se muestra en el siguiente programa:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
COMPILER_OPTIONS _max_process = 100;

PROGRAM mi_juego;
BEGIN
    //...
END
</pre>
En este caso, se ha establecido que, durante la ejecuci&#243;n del programa, podr&#225; existir <strong>un m&#225;ximo de 100 procesos</strong> ejecut&#225;ndose de forma simult&#225;nea.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="640">Asignaci&#243;n dentro de una condici&#243;n</h2><br/><br/>
El compilador ha detectado, en la posici&#243;n resaltada en el programa, una sentencia de asignaci&#243;n dentro de una condici&#243;n.<br/><br/>
Probablemente haya intentado comparar dos valores utilizando para ello el s&#237;mbolo de asignaci&#243;n <a href="#1073">=</a>, en lugar del s&#237;mbolo de comparaci&#243;n <a href="#1074">==</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota para nuevos usuarios:</strong> Si desea poder <strong>comparar</strong> dos valores con el s&#237;mbolo <strong>=</strong>, debe incluir la opci&#243;n <a href="#1400">_simple_conditions</a> en el programa. Para ello deber&#225; incluir en la primera l&#237;nea (antes de <strong>PROGRAM ...</strong>) la siguiente sentencia:<br/><br/>
<strong>COMPILER_OPTIONS _simple_conditions;</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Nota para usuarios de la versi&#243;n anterior:</strong> En esta nueva versi&#243;n del lenguaje se prohiben inicialmente las <strong>asignaciones dentro de una condici&#243;n</strong>, para facilitar la programaci&#243;n a usuarios no experimentados. No obstante esto puede cambiarse con las opciones de compilaci&#243;n (ver <a href="#1400">_extended_conditions y _simple_conditions</a>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1400">Compiler_options</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="641">La longitud no coincide con la declaraci&#243;n anterior</h2><br/><br/>
Se ha declarado una cadena de texto o puntero <strong>dos veces</strong>, como par&#225;metro y como dato privado, y en ambas declaraciones se ha especificado una longitud diferente.<br/><br/>
No es necesario volver a declarar este dato como privado, pudiendo especificar su longitud en los mismos par&#225;metros del proceso.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
BEGIN
  //...
END

PROCESS mi_proceso(string mi_cadena[16])
BEGIN
  //...
END
</pre>
El proceso de este ejemplo recibe un par&#225;metro en una cadena <strong>privada</strong> (aunque no se indique en esta secci&#243;n) de hasta <strong>17</strong> car&#225;cteres de longitud (desde mi_cadena[0] hasta mi_cadena[16]).<br/><br/>
El proceso anterior podr&#237;a haber vuelto a declarar esta cadena en la secci&#243;n <a href="#1008">PRIVATE</a> (por ejemplo, para a&#241;adir un comentario explicativo), pero debiendo coincidir, en este caso, la longitud con la anteriormente especificada. Es decir, que <strong>mi_cadena</strong> se declarar&#237;a como se muestra en el siguiente ejemplo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM nombre_del_programa;
BEGIN
  //...
END

PROCESS mi_proceso(string mi_cadena[16])

PRIVATE
  string mi_cadena[16]; // Aqu&#237; me pasar&#225;n un texto.

BEGIN
  //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1008">Declaraci&#243;n de datos privados</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="642">Esperando un nombre</h2><br/><br/>
Para definir una tabla de bytes se debe especificar el nombre de la misma tras la palabra reservada <strong>BYTE</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    BYTE mi_byte;
    BYTE mi_tabla1[127];
    BYTE mi_tabla2[255,255];
BEGIN
    //...
END
</pre>
En este ejemplo se han definido tres datos de este tipo. El primero con el nombre <strong>mi_byte</strong> podr&#225; contener un &#250;nico valor (entre 0 y 255), el segundo con el nombre <strong>mi_tabla1</strong> podr&#225; contener hasta 128 de estos valores (desde mi_tabla1[0] hasta mi_tabla1[127]), y el tercero, que ser&#225; una tabla de bytes de dos dimensiones, pudiendo contener un total de 65536 valores (ya que este es el resultado de multiplicar 256 por 256).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="643">Valor de BYTE fuera del rango (0...255)</h2><br/><br/>
Se ha inicializado un <strong>BYTE</strong> con un valor demasiado grande o negativo. Este tipo de datos &#250;nicamente pueden contener valores dentro del rango <strong>0</strong> ... <strong>255</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    BYTE mi_valor=300; // Error: Valor de byte fuera del rango (0...255).
BEGIN
    //...
END
</pre>
Si quiere asignar este valor al dato, quiz&#225; sea conveniente no declarar un dato de tipo <strong>BYTE</strong>, como se muestra en el siguiente programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    mi_valor=300;
BEGIN
    //...
END
</pre>
Ya que de esta forma se crea un dato que podr&#225; contener valores num&#233;ricos enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="644">Valor de WORD fuera del rango (0...65535)</h2><br/><br/>
Se ha inicializado un <strong>WORD</strong> con un valor demasiado grande o negativo. Este tipo de datos &#250;nicamente pueden contener valores dentro del rango <strong>0</strong> ... <strong>65535</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    WORD mi_valor=70000; // Error: Valor de word fuera del rango (0...65535).
BEGIN
    //...
END
</pre>
Si quiere asignar este valor al dato, quiz&#225; sea conveniente no declarar un dato de tipo <strong>WORD</strong>, como se muestra en el siguiente programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    mi_valor=70000;
BEGIN
    //...
END
</pre>
Ya que de esta forma se crea un dato que podr&#225; contener valores num&#233;ricos enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="645">Esperando un nombre</h2><br/><br/>
Para definir una tabla de bytes se debe especificar el nombre de la misma tras la palabra reservada <strong>WORD</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    WORD mi_word;
    WORD mi_tabla1[127];
    WORD mi_tabla2[255,255];
BEGIN
    //...
END
</pre>
En este ejemplo se han definido tres datos de este tipo. El primero con el nombre <strong>mi_word</strong> podr&#225; contener un &#250;nico valor (entre 0 y 65535), el segundo con el nombre <strong>mi_tabla1</strong> podr&#225; contener hasta 128 de estos valores (desde mi_tabla1[0] hasta mi_tabla1[127]), y el tercero, que ser&#225; una tabla de words de dos dimensiones, pudiendo contener un total de 65536 valores (ya que este es el resultado de multiplicar 256 por 256).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="646">No se puede especificar una tabla como par&#225;metro</h2><br/><br/>
Los <a href="#1018">par&#225;metros del proceso</a> se deben declarar como variables, no como tablas o estructuras, y no se deben inicializar (ya que recibir&#225;n su valor en cada llamada).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    //...
END
PROCESS mi_proceso(a[9]) // Error: No se puede especificar una tabla como par&#225;metro.
BEGIN
    //...
END
</pre>
El compilador interpreta que se est&#225; tipificando el par&#225;metro <strong>a</strong> como una tabla de 10 posiciones, y como no se puede pasar una tabla como par&#225;metro, emite el error.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="647">Sentencia IMPORT incorrecta (ver la ayuda al respecto)</h2><br/><br/>
La declaraci&#243;n de librerias externas debe hacerse justo <strong>tras la cabecera del programa</strong>, es decir, tras la declaraci&#243;n <strong>PROGRAM nombre_de_programa;</strong>. Pudiendo hacerse varias declaraciones <a href="#1014">IMPORT</a> seguidas, para declarar el uso de m&#225;s de una librer&#237;a, como en el siguiente ejemplo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
// Cabecera del programa

PROGRAM mi_juego;

// Declaraci&#243;n de librerias

IMPORT &quot;lib1.dll&quot;;
IMPORT &quot;lib2.dll&quot;;
//...

// Y a continuaci&#243;n (opcionalmente) el resto de secciones.

CONST
   //...
GLOBAL
   //...
LOCAL
   //...
PRIVATE
   //...

BEGIN
    //...
END
</pre>
Este programa declara el uso de las librer&#237;as denominadas <strong>lib1.dll</strong> y <strong>lib2.dll</strong> (supuestos nombres de unas hipot&#233;ticas librer&#237;as de funciones externas).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> En la primera versi&#243;n del lenguaje de programaci&#243;n DIV, esta declaraci&#243;n se deb&#237;a hacer entre las secciones <strong>LOCAL</strong> y <strong>PRIVATE</strong> del programa.<br/><br/>
<strong>Nota 2:</strong> Las librer&#237;as preparadas para la primera versi&#243;n del lenguaje <strong>no funcionar&#225;n correctamente</strong> en versiones posteriores, debi&#233;ndose recompilar previamente estas librer&#237;as con los nuevos archivos de declaraciones. Es decir, que el c&#243;digo fuente de las librer&#237;as sigue siendo v&#225;lido, pero antes debe compilarse nuevamente con los nuevos archivos de cabecera (ya que estos contienen las declaraciones de los nuevos datos y estructuras existentes en el lenguaje).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1014">Declaraci&#243;n de librer&#237;as</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="648">Esperando un nombre</h2><br/><br/>
Para declarar un puntero se debe especificar el nombre del mismo tras la palabra reservada <a href="#1405">POINTER</a> (o el s&#237;mbolo <strong>*</strong>).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    POINTER ptr;
    WORD POINTER mis_words[15];
    BYTE POINTER mis_bytes;
BEGIN
    //...
END
</pre>
En este ejemplo se han definido tres datos de este tipo. El primero con el nombre <strong>ptr</strong> es un puntero a datos enteros convencionales, y no tiene limitaci&#243;n de rango en su acceso (se puede acceder a ptr[<strong>n</strong>], siendo <strong>n</strong> cualquier valor). El segundo es un puntero a datos de tipo <strong>WORD</strong> (enteros entre 0 y 65535) con una limitaci&#243;n de acceso a los primeros 16 valores. Y el tercero es un puntero a datos de tipo <strong>BYTE</strong> (enteros entre 0 y 255) y sin limitaci&#243;n de rango.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="649">Esperando un nombre</h2><br/><br/>
Para declarar un dato entero se debe especificar el nombre del mismo tras la palabra reservada <strong>INT</strong> siendo, en todo caso, prescindible dicha palabra (ya que todos los datos son de tipo entero por defecto).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    INT a,b;  // Declara dos datos enteros
    c,d;      // Declara otros dos datos enteros
BEGIN
    //...
END
</pre>
En este ejemplo se puede ver como se declaran 4 datos de tipo entero, para los dos primeros (<strong>a</strong> y <strong>b</strong>) se ha especificado que su tipo sera <strong>INT</strong> (de &quot;integer&quot;, entero en ingl&#233;s), pero no existe ninguna diferencia, a nivel de declaraci&#243;n, con los dos &#250;ltimos (<strong>c</strong> y <strong>d</strong>), ya que estos tambi&#233;n ser&#225;n datos de tipo entero.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="650">Declaraci&#243;n incorrecta de puntero a una estructura</h2><br/><br/>
El compilador esperaba, en la posici&#243;n indicada del programa, el nombre de una estructura declarada anteriormente, para poder declarar un puntero a la misma.<br/><br/>
Para definir un puntero a una estructura de datos se debe utilizar la siguiente sintaxis:<br/><br/>
<strong>STRUCT POINTER nombre_estructura nombre_puntero;</strong><br/><br/>
Siendo <strong>nombre_estructura</strong> el nombre de una estructura de datos declarada en una posici&#243;n anterior del programa, y <strong>nombre_puntero</strong> nombre del puntero la estructura que se est&#225; declarando.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1012">Declaraci&#243;n Estructuras</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="651">No se puede recibir una estructura como par&#225;metro</h2><br/><br/>
Un proceso no puede recibir una estructura como par&#225;metro, si se quiere acceder desde un proceso a una estructura externa, se debe recibir como par&#225;metro un puntero a la misma.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT posiciones[9]
        x, y;
    END
BEGIN
    mi_proceso(OFFSET posiciones);
    //...
END

PROCESS mi_proceso(STRUCT POINTER posiciones pos[9]);
BEGIN
    //pos[ ... ].x = ... ;
    //...
END
</pre>
En este ejemplo se podr&#225; acceder a la estructura dentro de <strong>mi_proceso</strong> utilizando el puntero <strong>pos</strong>, como si fuera la propia estructura <strong>posiciones</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1001">Nombres</a> - <a href="#1012">Declaraci&#243;n Estructuras</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="652">Esperando un nombre de estructura</h2><br/><br/>
La funci&#243;n indicada requiere como par&#225;metro, en la posici&#243;n indicada, el nombre de una estructura de datos del programa.<br/><br/>
No se debe utilizar el operador <a href="#1085">offset</a>, simplemente se debe indicar el nombre de la estructura.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT records[9]
        STRING iniciales[2];
        puntos;
    END
BEGIN
    //...
    qsort(offset records,puntos,1); // Error: Esperando un nombre.
END
</pre>
En este ejemplo se utiliza la funci&#243;n <strong>qsort</strong>, que requiere el nombre de una estructura como primer par&#225;metro. En este caso, la instrucci&#243;n adecuada para ordenar la tabla <strong>records</strong> ser&#237;a la siguiente:<br/><br/>
qsort(records,puntos,1);<br/><br/>
Esta instrucci&#243;n indicar&#237;a que se quiere ordenar esta estructura, en funci&#243;n del campo <strong>puntos</strong> y en orden descendente.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> Tambi&#233;n es probable que el nombre indicado no se refiera a una estructura de datos, sino a otro tipo de objeto diferente (por ejemplo, que se haya especificado el nombre de una tabla de datos).<br/><br/>
<strong>Nota 2:</strong> Esta estructura de datos no puede pertenecer a su vez a otra estructura, es decir, que no se puede especificar el nombre de una estructura dentro de otra.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="653">Esperando un campo de estructura</h2><br/><br/>
La funci&#243;n indicada requiere como par&#225;metro, en la posici&#243;n indicada, el nombre de <strong>un campo perteneciente a la estructura indicada anteriormente</strong>.<br/><br/>
No se debe utilizar el operador <a href="#1085">offset</a>, simplemente se debe indicar el nombre del campo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    STRUCT records[9]
        STRING iniciales[2];
        puntos;
    END
BEGIN
    //...
    qsort(records,&amp;puntos,1); // Error: Esperando un campo de estructura.
END
</pre>
En este ejemplo se utiliza la funci&#243;n <strong>qsort</strong>, que requiere el nombre de un campo de la estructura como segundo par&#225;metro. En este caso, la instrucci&#243;n adecuada para ordenar la tabla <strong>records</strong> ser&#237;a la siguiente:<br/><br/>
qsort(records,puntos,1);<br/><br/>
Esta instrucci&#243;n indicar&#237;a que se quiere ordenar esta estructura, en funci&#243;n del campo <strong>puntos</strong> y en orden descendente.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Tambi&#233;n es probable que el nombre indicado no se refiera a un campo perteneciente a dicha estructura.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<hr/>
<h1>Temas de inter&#233;s relacionados con los errores de compilaci&#243;n <hr/></h1>
<br/><br/>
<h2 id="1000">Sintaxis de un programa</h2><br/><br/>
A continuaci&#243;n se muestra la estructura general de un programa en el lenguaje; pulse con el rat&#243;n sobre la secci&#243;n de inter&#233;s para ver la definici&#243;n sint&#225;ctica correspondiente.<br/><br/>
<a href="#1400">&lt;Opciones de compilaci&#243;n&gt;</a><br/>
<a href="#1003">&lt;Cabecera del programa&gt;</a><br/>
<a href="#1014">&lt;Declaraci&#243;n de librer&#237;as&gt;</a><br/>
<a href="#1004">&lt;Declaraci&#243;n de constantes&gt;</a><br/>
<a href="#1006">&lt;Declaraci&#243;n de datos globales&gt;</a><br/>
<a href="#1007">&lt;Declaraci&#243;n de datos locales&gt;</a><br/>
<a href="#1008">&lt;Declaraci&#243;n de datos privados&gt;</a><br/>
<a href="#1015">&lt;C&#243;digo principal&gt;</a><br/>
<a href="#1016">&lt;Declaraci&#243;n de procesos&gt;</a><br/>
<a href="#1408">&lt;Declaraci&#243;n de funciones&gt;</a><br/>
<br/><br/>
Todos los programas deben respetar la estructura anterior con una &#250;nica excepci&#243;n, y es que pueden ponerse <a href="#1002">comentarios explicativos</a> en cualquier punto del programa.<br/><br/>
<hr/>
<br/><br/>
<h2 id="1001">Definici&#243;n de un nombre</h2><br/><br/>
Un nombre es una secuencia de car&#225;cteres alfanum&#233;ricos que se utiliza para <strong>identificar</strong> un objeto del programa, como puede ser el nombre de un proceso, de una <a href="#1004">constante</a> o de una variable.<br/><br/>
Estos nombres pueden formarse con los siguientes car&#225;cteres:<br/><br/>
S&#237;mbolos:<br/>
<strong>_ # &#170; &#186; $ ₧ ƒ &#163; &#165; &#162;</strong><br/>
D&#237;gitos:<br/>
<strong>0123456789</strong><br/>
Letras:<br/>
<strong>abcdefghijklmnopqrstuvwxyz</strong><br/>
Letras (extendido):<br/>
<strong>&#241; &#231; &#230; &#226;&#228;&#224;&#229;&#225; &#234;&#235;&#232;&#233; &#238;&#239;&#236;&#237; &#244;&#246;&#242;&#243; &#251;&#252;&#249;&#250; &#255;</strong><br/>
<br/><br/>
Siempre que se respeten las siguientes reglas para construir nuevos nombres:<br/><br/>
- La secuencia de car&#225;cteres no debe contener car&#225;cteres que no est&#233;n en la relaci&#243;n anterior (excepto las letras <strong>may&#250;sculas</strong> correspondientes a las min&#250;sculas de la lista).<br/><br/>
- Dentro de la secuencia no se pueden poner espacios en blanco, es decir, no es v&#225;lido como nombre <strong>nave enemiga</strong>, pues para el compilador se tratar&#237;a de dos nombres; en este caso se puede declarar el nombre como <strong>nave_enemiga</strong>.<br/><br/>
- Un nombre no puede comenzar por un d&#237;gito num&#233;rico, es decir, <strong>0a</strong> no es un nombre v&#225;lido. No obstante tras el primer car&#225;cter, pueden incluirse en el nombre todos los d&#237;gitos necesarios (<strong>a0</strong> si es un nombre v&#225;lido).<br/><br/>
- El nombre no debe coincidir con ninguna de las palabras reservadas del lenguaje ni con ninguno de los objetos (constantes, variables, etc.) predefinidos en el lenguaje. Para comprobar esto, ver la lista de palabras reservadas y objetos predefinidos, pudi&#233;ndose acceder al glosario en cualquier momento. Las palabras reservadas aparecen en may&#250;sculas y los objetos predefinidos en min&#250;sculas.<br/><br/>
- No se diferencian las letras may&#250;sculas de las m&#237;nusculas (<strong>ABc</strong> y <strong>abC</strong> son el mismo nombre para el compilador).<br/><br/>
- No se puede utilizar un mismo nombre para dos objetos diferentes, por ejemplo, no se puede llamar a una constante <strong>valor</strong> y, despu&#233;s, declarar un proceso como <strong>PROCESS valor(x, y);</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1002">Definici&#243;n de comentarios</h2><br/><br/>
Un comentario es una nota aclaratoria sobre el programa. Los comentarios no son necesarios para el correcto funcionamiento del programa.<br/><br/>
Hay dos tipos de comentarios:<br/><br/>
- De una sola l&#237;nea, comienzan con el s&#237;mbolo<strong> //</strong> y terminan al final de la l&#237;nea en la que se definen.<br/><br/>
- De varias l&#237;neas, comienzan con el s&#237;mbolo<strong> /*</strong> y terminan con el s&#237;mbolo <strong>*/</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
/*
    Esto es un ejemplo de un comentario
    de varias l&#237;neas, en el que se pueden
    realizar aclaraciones sobre el programa
*/

PROGRAM mi_juego; // Ejemplo de un comentario de una l&#237;nea.
BEGIN             // Comienza el programa principal.
    FRAME;
END               // Termina el programa principal.
</pre>
Todos los textos incluidos en un comentario son ignorados por el compilador. Se pueden poner tantos comentarios en un programa como sean necesarios y en cualquier punto del programa.<br/><br/>
Los comentarios que comienzan con<strong> /*</strong> y terminan con<strong> */</strong> (denominados de varias l&#237;neas) pueden tambi&#233;n comenzar y terminar en la misma l&#237;nea.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1003">Cabecera del programa</h2><br/><br/>
<strong>PROGRAM</strong> <a href="#1001">&lt;nombre&gt;</a> <strong>;</strong><br/><br/>
Todos los programas deben comenzar con la palabra reservada <strong>PROGRAM</strong> seguida del nombre del programa y un s&#237;mbolo <a href="#1068">; (punto y coma)</a>. Esta cabecera es obligatoria en todos los programas (antes de la misma &#250;nicamente pueden aparecer las (<a href="#1400">opciones de compilaci&#243;n</a>).<br/><br/>
En los nombres y las palabras reservadas no se diferencia entre may&#250;sculas y min&#250;sculas, por lo que son v&#225;lidas <strong>PROGRAM</strong>, <strong>program</strong>, <strong>Program</strong>, ...<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
// -------------------
// Listado de mi juego
// -------------------

PROGRAM nombre_de_mi_juego;
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1004">Declaraci&#243;n de constantes</h2><br/><br/>
<strong>CONST</strong><br/>
<a href="#1001">&lt;nombre&gt;</a> <strong>=</strong> <a href="#1005">&lt;constante&gt;</a> <strong>;</strong><br/>
...<br/><br/>
Esta secci&#243;n de los programas es opcional, pues su utilidad consiste en establecer una serie de sin&#243;nimos para unos valores num&#233;ricos.<br/><br/>
Por ejemplo, si en un juego se establece en uno o varios puntos del programa el n&#250;mero 3 como el m&#225;ximo de vidas del protagonista, cuando se quiera modificar para aumentarlo o disminuirlo habr&#225; que buscar y sustituir ese n&#250;mero en el programa. Con el consiguiente riesgo de sustituir otros &#39;3&#39; que aparezcan en el programa con otros fines.<br/><br/>
Una alternativa es declarar una constante denominada, por ejemplo, <strong>m&#225;ximo_vidas</strong> como un sin&#243;nimo del valor num&#233;rico 3 y utilizar en el programa dicha constante en lugar del n&#250;mero; ahora, cuando se quiera cambiar este valor por otro, simplemente habr&#225; que hacerlo en la declaraci&#243;n de la constante <strong>m&#225;ximo_vidas</strong>.<br/><br/>
Esta secci&#243;n establece entonces una relaci&#243;n de nombres que van a representar una serie de constantes num&#233;ricas.<br/><br/>
Esta secci&#243;n debe comenzar obligatoriamente con la palabra reservada <strong>CONST</strong> y, a continuaci&#243;n, por cada constante declarada debe aparecer su nombre seguido del s&#237;mbolo <a href="#1073">= (s&#237;mbolo de asignaci&#243;n)</a> y una expresi&#243;n constante (valor num&#233;rico). Tras la declaraci&#243;n de cada constante debe venir el s&#237;mbolo <a href="#1068">;</a> (punto y coma).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
CONST
    m&#225;ximo_vidas=3;
BEGIN
    //...
END
</pre>
Una vez que se ha asignado un valor a una constante, &#233;ste no podr&#225; ser modificado en el programa m&#225;s adelante.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1005">Definici&#243;n de una constante</h2><br/><br/>
Una constante es un valor o una expresi&#243;n num&#233;rica constante.<br/><br/>
Como valores se pueden utilizar &#250;nicamente n&#250;meros enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
Las expresiones n&#250;mericas constantes son f&#243;rmulas matem&#225;ticas en las que se puede utilizar:<br/><br/>
- <strong>Constantes</strong> definidas con anterioridad.<br/>
- <strong>Valores num&#233;ricos</strong>.<br/>
- <strong>Operadores</strong> aritm&#233;ticos o l&#243;gicos.<br/>
- <strong>Literales</strong> (textos entre comillas).<br/>
- La funci&#243;n <a href="#1094">sizeof()</a>.<br/>
<br/><br/>
Estas expresiones ser&#225;n evaluadas cuando el programa sea compilado y ser&#225; el resultado de las mismas el que sea utilizado en la ejecuci&#243;n del programa.<br/><br/>
Los <strong>operadores</strong> que se pueden utilizar en una expresi&#243;n constante son (entre par&#233;ntesis se muestran los sin&#243;nimos del operador, en caso de tenerlos).<br/><br/>
<a href="#1056"> +</a>    Suma<br/>
<a href="#1060"> -</a>    Resta (o negaci&#243;n de signo)<br/>
<a href="#1054"> *</a>    Multiplicaci&#243;n<br/>
<a href="#1065"> /</a>    Divisi&#243;n<br/>
<a href="#1048"> MOD</a>  M&#243;dulo (<a href="#1048">%</a>)<br/>
<a href="#1070"> &lt;&lt;</a>   Rotaci&#243;n a la derecha<br/>
<a href="#1077"> &gt;&gt;</a>   Rotaci&#243;n a la izquierda<br/>
<a href="#1045"> NOT</a>  Negaci&#243;n binaria y l&#243;gica (<strong>!</strong>)<br/>
<a href="#1051"> AND</a>  AND binario y l&#243;gico (<strong>&amp;</strong>,<strong>&amp;&amp;</strong>)<br/>
<a href="#1083"> OR</a>   OR binario y l&#243;gico (<strong>|</strong>,<strong>||</strong>)<br/>
<a href="#1082"> XOR</a>  OR exclusivo (<strong>^^</strong>)<br/>
<a href="#1074"> ==</a>   Comparaci&#243;n<br/>
<a href="#1046"> &lt;&gt;</a>   Distinto (<strong>!=</strong>)<br/>
<a href="#1076"> &gt;</a>    Mayor<br/>
<a href="#1075"> &gt;=</a>   Mayor o igual (<strong>=&gt;</strong>)<br/>
<a href="#1069"> &lt;</a>    Menor<br/>
<a href="#1072"> &lt;=</a>   Menor o igual (<strong>=&lt;</strong>)<br/>
<a href="#1085"> OFFSET</a> Direcci&#243;n o desplazamiento (<strong>&amp;</strong>)<br/>
<a href="#1053"> ( )</a>  Par&#233;ntesis<br/>
<br/><br/>
A continuaci&#243;n se muestran algunos ejemplos de constantes v&#225;lidas:<br/><br/>
<strong> 0</strong><br/>
<strong> -1000</strong><br/>
<strong> 2+2</strong><br/>
<strong> &quot;Hola!&quot;</strong><br/>
<strong> 4*(2+1)</strong><br/>
...<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1006">Declaraci&#243;n de datos globales</h2><br/><br/>
<strong>GLOBAL</strong><br/>
<a href="#1009">&lt;declaraci&#243;n de dato&gt;</a> <a href="#1068">;</a><br/>
...<br/><br/>
Esta secci&#243;n de los programas es opcional; es donde se declaran los datos de &#225;mbito global, es decir, los <strong>datos que pueden utilizarse desde cualquier punto del programa</strong>.<br/><br/>
La secci&#243;n debe comenzar obligatoriamente con la palabra reservada GLOBAL seguida de una serie de <a href="#1009">declaraciones de datos</a> terminadas con un s&#237;mbolo <a href="#1068">;</a> (punto y coma).<br/><br/>
En general, se declaran como datos globales todos aquellos que establecen condiciones generales del juego que afecten a varios procesos; un ejemplo puede ser los puntos obtenidos por el jugador, que podr&#237;an almacenarse en la variable global <strong>puntuaci&#243;n</strong>, de modo que cualquier proceso del juego pudiera incrementarla cuando fuera necesario.<br/><br/>
Una declaraci&#243;n de dato global definir&#225; un &#250;nico dato que podr&#225; ser utilizado por todos los procesos del programa; en cambio una declaraci&#243;n de dato local definir&#225; un dato de ese tipo y con ese nombre, para cada uno de los procesos del programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    puntuaci&#243;n=0;
BEGIN
    //...
END
</pre>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1007">Declaraci&#243;n de datos locales</h2><br/><br/>
<strong>LOCAL</strong><br/>
<a href="#1009">&lt;declaraci&#243;n de dato&gt;</a> <a href="#1068">;</a><br/>
...<br/><br/>
Esta secci&#243;n de los programas es opcional, ya que es donde se declaran los datos de &#225;mbito local, es decir, los <strong>datos que tendr&#225;n todos los procesos del programa</strong>, cada uno con sus propios valores (como las variables locales predefinidas <a href="#1123">x</a> e <a href="#1124">y</a> determinan las coordenadas de todos los procesos).<br/><br/>
La secci&#243;n debe comenzar obligatoriamente con la palabra reservada <strong>LOCAL</strong> seguida de una serie de <a href="#1009">declaraciones de datos</a> terminadas con un s&#237;mbolo <a href="#1068">;</a> (punto y coma).<br/><br/>
En general, se declaran como datos locales todos aquellos que se consideren informaciones importantes de los procesos, o sea, aquellos que pueda interesar consultar o modificar desde otros procesos.<br/><br/>
Un ejemplo puede ser la energ&#237;a que le queda a un proceso (puede ser una nave, un disparo, el protagonista, etc.); esta informaci&#243;n podr&#237;a almacenarse en la variable local <strong>energ&#237;a</strong> de modo que cualquier proceso pudiera acceder o modificar la energ&#237;a de los dem&#225;s (por ejemplo, cuando colisionara con ellos les podr&#237;a quitar energ&#237;a).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
LOCAL
    energ&#237;a=0;
BEGIN
    //...
END
</pre>
Si un dato declarado como local va a utilizarse &#250;nicamente dentro de un proceso, entonces se puede definir como un dato privado (dentro de la secci&#243;n <a href="#1008">PRIVATE</a> de dicho proceso).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1008">Declaraci&#243;n de datos privados</h2><br/><br/>
<strong>PRIVATE</strong><br/>
<a href="#1009">&lt;declaraci&#243;n de dato&gt;</a> <a href="#1068">;</a><br/>
...<br/><br/>
Estas secciones de los programas son opcionales; en ellas se pueden declarar datos de &#225;mbito privado, es decir, <strong>datos que van a ser utilizados exclusivamente dentro de un proceso</strong>.<br/><br/>
Dicha secci&#243;n se define justo antes del <a href="#1086">BEGIN</a> del proceso que va a utilizar esos datos y debe comenzar, obligatoriamente, con la palabra reservada PRIVATE seguida de una serie de <a href="#1009">declaraciones de datos</a> terminadas con un s&#237;mbolo <a href="#1068">;</a> (punto y coma).<br/><br/>
El programa principal tambi&#233;n se considera como un proceso, pudiendo tener su declaraci&#243;n de datos privados justo antes del <a href="#1086">BEGIN</a> del mismo.<br/><br/>
En general, se declaran como datos privados todos aquellos que vayan a contener informaci&#243;n necesaria &#250;nicamente para un proceso e, igualmente, que no van a poder ser accedidos desde ning&#250;n otro proceso.<br/><br/>
T&#237;picamente se definen como datos privados aquellas variables que van a ser utilizadas como contadores en un bucle, las variables para contener &#225;ngulos o c&#243;digos identificadores secundarios, etc.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE
    n;
BEGIN
    FROM n=0 TO 9;
        //...
    END
    //...
END

PROCESS mi_proceso()
PRIVATE
    id2;
    angle2;
BEGIN
    id2=get_id(TYPE mi_proceso);
    IF (id2&lt;&gt;0)
        angle2=id2.angle;
        //...
    END
    //...
END
</pre>
Si un dato declarado como privado necesita consultarse o modificarse desde otro proceso (identificador.dato), entonces se deber&#225; declarar dicho dato como local (dentro de la secci&#243;n <a href="#1007">LOCAL</a> del programa); de esta forma, todos los procesos poseer&#225;n el dato, pudiendo acceder cada uno a su valor o al valor que tenga dicho dato en otro proceso.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1009">Declaraci&#243;n de un dato</h2><br/><br/>
En una declaraci&#243;n de dato pueden manifestarse tres tipos diferentes de objetos:<br/><br/>
<a href="#1010">&lt;Declaraci&#243;n de una variable&gt;</a><br/>
<a href="#1011">&lt;Declaraci&#243;n de una tabla&gt;</a><br/>
<a href="#1012">&lt;Declaraci&#243;n de una estructura&gt;</a><br/>
<br/><br/>
En general, una variable almacenar&#225; un simple valor num&#233;rico, una tabla una lista de valores num&#233;ricos, mientras que una estructura almacenar&#225; una lista de registros de varios campos (como una lista de fichas con diversa informaci&#243;n).<br/><br/>
Todos los datos se declaran con un nombre propio que, a partir de ese momento, ser&#225; el medio por el cual se acceda o se modifique la informaci&#243;n que dicho dato contiene.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> En esta versi&#243;n del lenguaje se han incluido diferentes <a href="#1401">tipos de datos</a>, aunque contin&#250;an siendo v&#225;lidas las declaraciones de datos de la versi&#243;n anterior.<br/><br/>
<hr/>
<br/><br/>
Cada dato pertenecer&#225; a un &#225;mbito determinado, seg&#250;n su declaraci&#243;n se haga dentro de la secci&#243;n <a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a>..<br/><br/>
<a href="#1006">&lt;Declaraci&#243;n de datos globales&gt;</a><br/>
<a href="#1007">&lt;Declaraci&#243;n de datos locales&gt;</a><br/>
<a href="#1008">&lt;Declaraci&#243;n de datos privados&gt;</a><br/>
<br/><br/>
A los datos globales se puede acceder desde cualquier punto del programa; los locales son aquellos que tienen todos los procesos (cada proceso tiene su propio valor en ellos) mientras que los privados son los que pertenecen a un s&#243;lo proceso determinado.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1401">Tipos de datos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1010">Declaraci&#243;n de una variable</h2><br/><br/>
<a href="#1401">&lt;tipo&gt;</a> <a href="#1001">&lt;nombre&gt;</a><br/><br/>
(o bien, si se quiere inicializar)<br/><br/>
<a href="#1401">&lt;tipo&gt;</a> <a href="#1001">&lt;nombre&gt;</a> <a href="#1073">=</a> <a href="#1005">&lt;constante&gt;</a><br/><br/>
Se pueden declarar variables num&#233;ricas de varios tipos, en cualquiera de las secciones de declaraci&#243;n <a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a>.<br/><br/>
Para declarar una variable debe indicarse el tipo (<a href="#1402">INT</a>, <a href="#1403">WORD</a> o <a href="#1404">BYTE</a>) seguido del nombre para la variable y, en caso de quererse inicializar, un s&#237;mbolo de asignaci&#243;n (<a href="#1073">=</a>) precediendo al valor de la variable.<br/><br/>
<hr/>
<br/><br/>
<strong>Tipos de variables:</strong><br/><br/>
<a href="#1402">INT</a> - Variables num&#233;ricas enteras entre -2147483648 y +2147483647 (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>). La palabra reservada <strong>INT</strong> puede omitirse, ya que todos los datos ser&#225;n de este tipo por defecto (enteros de 32 bit con signo).<br/><br/>
<a href="#1403">WORD</a> - Variables num&#233;ricas enteras entre 0 y 65535 (enteros de 16 bit sin signo).<br/><br/>
<a href="#1404">BYTE</a> - Variables num&#233;ricas enteras entre 0 y 255 (enteros de 8 bit sin signo).<br/><br/>
<a href="#1405">POINTER</a> - Punteros a diferentes tipos de datos.<br/><br/>
<strong>Nota:</strong> Las cadenas de texto (datos de tipo <a href="#1406">STRING</a> se consideran tablas de datos (de car&#225;cteres), en lugar de simples variables (ver la <a href="#1011">declaraci&#243;n de una tabla</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Ejemplos de declaraci&#243;n de variables:</strong><br/><br/>
<strong>Mi_dato=-1;</strong> -  Variable tipo INT, inicializada a -1.<br/><br/>
<strong>INT a=0,b;</strong> - Dos variables tipo INT, inicializadas a 0.<br/><br/>
<strong>WORD conta=10;</strong> - Variable tipo WORD, inicializada a 10.<br/><br/>
<strong>BYTE b1,b2=32;</strong> - Variables tipo BYTE, b1 a 0 y b2 a 32.<br/><br/>
<hr/>
<br/><br/>
<strong>Consideraciones finales:</strong><br/><br/>
<strong>1.</strong> Si no se indica el tipo de la variable, esta ser&#225; INT.<br/>
<strong>2.</strong> Si no se indica el valor de la variable, esta ser&#225; inicializada a 0.<br/>
<strong>3.</strong> Se debe poner el s&#237;mbolo punto y coma tras cada declaraci&#243;n.<br/>
<strong>4.</strong> Se pueden separar varios nombres de dato (del mismo tipo) por comas.<br/>
<br/><br/>
<strong>Nota:</strong> Siguen siendo v&#225;lidas las declaraciones de datos seg&#250;n se hacian en la primera versi&#243;n del lenguaje (sin indicar nunca el tipo). En este caso, todas las variables ser&#225;n de tipo <a href="#1402">INT</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1011">Declaraci&#243;n de una tabla</h2><br/><br/>
<a href="#1401">&lt;tipo&gt;</a> <a href="#1001">&lt;nombre&gt;</a> <a href="#1079">[</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1079">]</a><br/><br/>
(o bien, si se quiere inicializar la tabla)<br/><br/>
<a href="#1401">&lt;tipo&gt;</a> <a href="#1001">&lt;nombre&gt;</a> <a href="#1079">[</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1079">]</a> <a href="#1073">=</a> <a href="#1013">&lt;lista de constantes&gt;</a><br/><br/>
(o bien, si se inicializar sin definir su longitud)<br/><br/>
<a href="#1401">&lt;tipo&gt;</a> <a href="#1001">&lt;nombre&gt;</a> <a href="#1079">[</a> <a href="#1079">]</a> <a href="#1073">=</a> <a href="#1013">&lt;lista de constantes&gt;</a><br/><br/>
Tambi&#233;n se pueden declarar tablas de varios tipos y en cualquier secci&#243;n (<a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a>). Para declarar una tabla debe indicarse el tipo (<a href="#1402">INT</a>, <a href="#1403">WORD</a>, <a href="#1404">BYTE</a> o <a href="#1406">STRING</a>) el nombre, la longitud entre corchetes ((s&#237;mbolos <a href="#1079">[</a> <a href="#1079">]</a>)) y, en caso de quererse inicializar, un s&#237;mbolo de asignaci&#243;n (<a href="#1073">=</a>) precediendo a la <a href="#1013">lista de constantes</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La longitud de la tabla se expresa como el valor m&#225;ximo de su &#237;ndice, es decir, todas las tablas van de la <strong>posici&#243;n 0</strong> a la <strong>posici&#243;n indicada entre los corchetes</strong>. Por ejemplo, una tabla declarada como <strong>mi_tabla[9]</strong>, ser&#225; una tabla de <strong>longitud 10</strong> (de 10 posiciones, desde mi_tabla[0] hasta mi_tabla[9]).<br/><br/>
<hr/>
<br/><br/>
<strong>Varios ejemplos de declaraci&#243;n de tablas:</strong><br/><br/>
<strong>Mitabla[3];</strong> - Tabla INT de 4 elementos (de Mitabla[0] a Mitabla[3]).<br/><br/>
<strong>INT tab[]=1,2,3,4,5;</strong> - Tabla INT de 5 elementos (de tab[0] a tab[4]).<br/><br/>
<strong>WORD tword[1];</strong> - Tabla WORD de 2 elementos.<br/><br/>
<strong>BYTE tbyte[3]=11,22;</strong> - Tabla BYTE de 4 elementos (inicializada a 11,22,0,0).<br/><br/>
<strong>STRING p;</strong> - Cadena de texto de hasta 256 caracteres (inicializada a &quot;&quot;).<br/><br/>
<strong>STRING q[32]= &quot;hola&quot;;</strong> - Cadena de texto de hasta 33 caracteres (inicializada a &quot;hola&quot;).<br/><br/>
<hr/>
<br/><br/>
<strong>Consideraciones sobre las tablas:</strong><br/><br/>
<strong>1.</strong> Si no se indica el tipo de la tabla, esta ser&#225; de tipo <a href="#1402">INT</a>.<br/>
<strong>2.</strong> Si se inicializa la tabla (con una <a href="#1013">lista de constantes</a>), puede omitirse la longitud entre corchetes.<br/>
<strong>3.</strong> Se debe poner un punto y coma tras cada declaraci&#243;n.<br/>
<strong>4.</strong> Si no se define la longitud de la tablas tipo <a href="#1406">STRING</a>, estas ser&#225;n de <strong>256 elementos</strong> (del <strong>[0]</strong> al <strong>[255]</strong>).<br/>
<strong>5.</strong> Si no se define la lista de constantes, los elementos estar&#225;n <strong>inicializados a 0</strong>.<br/>
<br/><br/>
Se permite acceder al <strong>elemento 0</strong> simplemente con el nombre de la tabla, como si fuera una variable; es decir, para el compilador <strong>mi_tabla[0]</strong> ser&#225; lo mismo que <strong>mi_tabla</strong>.<br/><br/>
<strong>Nota:</strong> No ser&#225; posible obtener el <a href="#1085">OFFSET</a> de un elemento de una tabla <a href="#1404">BYTE</a>, <a href="#1403">WORD</a> o <a href="#1406">STRING</a> (como <strong>OFFSET tbyte[1]</strong>), para acceder a este elemento externamente se deber&#225; utilizar, en todo caso, los datos de tipo <a href="#1405">POINTER</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Las tablas multidimensionales.</strong><br/><br/>
Se pueden declarar tablas <a href="#1402">INT</a>, <a href="#1403">WORD</a> o <a href="#1404">BYTE</a> de <strong>1, 2 o 3 dimensiones</strong>. Tanto la declaraci&#243;n de estas como el acceso a las mismas se debe hacer <strong>separando las dimensiones con comas</strong>. Por ejemplo, la siguiente declaraci&#243;n:<br/><br/>
<strong>BYTE tabla[255,255];</strong><br/><br/>
Definir&#237;a tabla de tipo <a href="#1404">BYTE</a> (para todos sus elementos) de <strong>2 dimensiones</strong>, con un total de 65536 elementos (256*256).<br/><br/>
<strong>Nota:</strong> Las tablas de tipo <a href="#1403">WORD</a> y <a href="#1404">BYTE</a> pueden significar un importante ahorro de memoria, respecto a las tablas de tipo <a href="#1402">INT</a> (ocupan 2 y 4 veces menos, respectivamente). Pero <strong>ser&#225;n m&#225;s r&#225;pidas las operaciones con datos de tipo</strong> <a href="#1402">INT</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1012">Declaraci&#243;n de una estructura</h2><br/><br/>
<strong>STRUCT</strong> <a href="#1001">&lt;nombre&gt;</a> <a href="#1079">[</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1079">]</a><br/>
<a href="#1009">&lt;declaraci&#243;n de dato&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
(o bien, si se inicializa la estructura)<br/><br/>
<strong>STRUCT</strong> <a href="#1001">&lt;nombre&gt;</a> <a href="#1079">[</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1079">]</a><br/>
<a href="#1009">&lt;declaraci&#243;n de dato&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a> <a href="#1073">=</a> <a href="#1013">&lt;lista de constantes&gt;</a><br/><br/>
Para declarar una estructura dentro de una secci&#243;n <a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a> se debe poner la palabra reservada <strong>STRUCT</strong> precediendo a su nombre; tras &#233;ste, y entre corchetes, (s&#237;mbolos <a href="#1079">[ ]</a>) se deber&#225; indicar el <strong>n&#250;mero de registros</strong> de la estructura.<br/><br/>
Tras la cabecera se declarar&#225;n todos los datos pertenecientes a la estructura, que conformar&#225;n los campos de la misma. Y, por &#250;ltimo, para finalizar la declaraci&#243;n debe aparecer la palabra reservada <strong>END</strong>.<br/><br/>
A continuaci&#243;n se muestra un ejemplo de estructura:<br/><br/>
<strong>STRUCT enemigo[9]</strong><br/>
<strong>    INT energia;</strong><br/>
<strong>    WORD x_inicial,y_inicial;</strong><br/>
<strong>    WORD x_final,y_final;</strong><br/>
<strong>    STRING nombre[15];</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Al igual que con las tablas, el <strong>n&#250;mero de registros</strong> se expresa como el <strong>n&#250;mero de registro m&#225;ximo</strong> de la estructura, es decir, todas las estructuras tienen desde el registro 0 hasta el indicado entre los corchetes (por ejemplo, la declaraci&#243;n anterior definie una estructura de <strong>10 registros</strong>).<br/><br/>
Se permite acceder al <strong>resgistro 0</strong> de la estructura simplemente con el nombre de la estructura, es decir, que para el compilador <strong>enemigo[0].y_final</strong> ser&#225; lo mismo que <strong>enemigo.y_final</strong>.<br/><br/>
<strong>Nota:</strong> Cada campo de la estructura puede ser una variable o tabla (de cualquier tipo, ver los <a href="#1401">tipos de datos</a>) u otra estructura completa, con sus diferentes registros y campos.<br/><br/>
<hr/>
<br/><br/>
<strong>Inicializaci&#243;n de la estructura.</strong><br/><br/>
Si se quiere inicializar la estructura (fijar los valores iniciales de sus campos en los diferentes registros), se deber&#225; poner el s&#237;mbolo <a href="#1073">=</a> (asignaci&#243;n) tras la palabra reservada <strong>END</strong> seguida de una lista de valores.<br/><br/>
Si no se inicializa la estructura, todos los campos ser&#225;n puestos a 0 por defecto. Por ejemplo, si se hace la siguiente declaraci&#243;n:<br/><br/>
<strong>STRUCT a[2]</strong><br/>
<strong>    b;</strong><br/>
<strong>    c[1];</strong><br/>
<strong>END = 1,2,3,4,5,6,7,8,9;</strong><br/>
<br/><br/>
Primero se debe tener en cuenta que la estructura <strong>a[]</strong> tiene <strong>3 registros</strong> (desde <strong>a[0]</strong> hasta <strong>a[2]</strong>) y en cada registro <strong>3 campos</strong> (b,c[0] y c[1]), luego la anterior declaraci&#243;n inicializar&#225; la estructura de la siguiente forma:<br/><br/>
<strong>a[0].b=1;</strong><br/>
<strong>a[0].c[0]=2;</strong><br/>
<strong>a[0].c[1]=3;</strong><br/>
<strong>a[1].b=4;</strong><br/>
<strong>a[1].c[0]=5;</strong><br/>
<strong> ...</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Inicializaci&#243;n global de los campos.</strong><br/><br/>
Si se quiere que todos los registros de la estructura tengan inicialmente los mismos valores para cada campo, se puede inicializar la estructura globalmente.<br/><br/>
<strong>STRUCT a[2]</strong><br/>
<strong>    b=1;</strong><br/>
<strong>    c[1]=2,3;</strong><br/>
<strong>END</strong><br/>
<br/><br/>
En el ejemplo anterior, todos los registros de la estructura tendr&#237;an inicializado el campo <strong>b</strong> a <strong>1</strong>, <strong>c[0]</strong> a <strong>2</strong> y <strong>c[1]</strong> a <strong>3</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Ver la <a href="#1407">alineaci&#243;n de datos en memoria</a>, donde se muestra la ocupaci&#243;n de memoria de los diferentes tipos de datos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1013">Definici&#243;n de una lista de constantes</h2><br/><br/>
Una constante es un valor o una expresi&#243;n num&#233;rica constante (ver <a href="#1005">&lt;definici&#243;n de constante&gt;</a>).<br/><br/>
Las listas de constantes son b&#225;sicamente una serie de constantes separadas por <a href="#1059">comas (,)</a> y se utilizan para inicializar los valores de tablas o estructuras.<br/><br/>
Un ejemplo de una lista de constantes podr&#237;a ser el siguiente:<br/><br/>
1, 2, 3, 4, 5;<br/><br/>
Pero, adem&#225;s de esta forma b&#225;sica de definici&#243;n, se permite el uso del operador <a href="#1089">DUP</a> para repetir un n&#250;mero determinado de veces una serie de constantes. Por ejemplo la siguiente lista:<br/><br/>
0, 100 DUP (1, 2, 3), 0;<br/><br/>
Es una lista de 302 constantes (0, 1, 2, 3, 1, 2, 3, ..., 1, 2, 3, 0), es decir, que el operador <a href="#1089">DUP</a> (de duplicar) permite repetir la secuencia que aparece tras &#233;l, entre par&#233;ntesis, el n&#250;mero de veces indicadas.<br/><br/>
Es posible anidar operaciones <a href="#1089">DUP</a>, por ejemplo la lista siguiente:<br/><br/>
2 <strong>DUP</strong> (88, 3 DUP (0, 1), 99);<br/><br/>
equivaldr&#237;a a:<br/><br/>
88, 0, 1, 0, 1, 0, 1, 99, 88, 0, 1, 0, 1, 0, 1, 99;<br/><br/>
Adem&#225;s, se permite la omisi&#243;n del operador <a href="#1089">DUP</a>, esto es, que <strong>2 DUP (0, 1)</strong> equivale a <strong>2(0, 1)</strong>.<br/><br/>
El operador DUP es &#250;til, sobre todo, para la inicializaci&#243;n de estructuras; si, por ejemplo, se quiere inicializar la siguiente estructura de 100 registros:<br/><br/>
<strong>STRUCT a[99]</strong><br/>
<strong>b;</strong><br/>
<strong>c[9];</strong><br/>
<strong>d[9];</strong><br/>
<strong>END</strong><br/><br/>
Con los campos <strong>b</strong> incializados a <strong>0</strong>, los campos <strong>c[9]</strong> a <strong>1</strong> y los campos <strong>d[9]</strong> a <strong>2</strong>, se utilizar&#237;a la siguiente lista de inicializaci&#243;n:<br/><br/>
100 <a href="#1089">DUP</a> (0, 10 DUP(1), 10 DUP(2));<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1014">Declaraci&#243;n de librer&#237;as</h2><br/><br/>
<strong>IMPORT</strong> <strong>&lt;nombre de archivo&gt;</strong><br/><br/>
La creaci&#243;n de librer&#237;as de funciones para el lenguaje es un tema <strong>muy avanzado</strong>, s&#243;lo apto para programadores con amplia experiencia en el lenguaje <strong>C</strong> y/o <strong>Ensamblador</strong>.<br/><br/>
Las librer&#237;as deben distribuirse con dos archivos: uno, con extensi&#243;n <strong>DLL</strong> con la librer&#237;a en s&#237; y, otro, con el mismo nombre pero con extensi&#243;n <strong>TXT</strong> que debe ser un archivo de texto, con la explicaci&#243;n del prop&#243;sito y funcionamiento de la librer&#237;a; en el mismo deben venir explicadas todas las funciones proporcionadas y el proceso de instalaci&#243;n y utilizaci&#243;n de la librer&#237;a.<br/><br/>
Desde el lenguaje se deben importar las librer&#237;as poniendo la palabra reservada <strong>IMPORT</strong> (tras la cabecera del programa) seguida de la ruta de acceso al archivo <strong>DLL</strong>. Si el archivo con extensi&#243;n <strong>DLL</strong> se ha copiado al directorio de <strong>DIV Games Studio</strong> entonces no es necesario especificar la ruta de la librer&#237;a.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;

IMPORT &quot;c:\tmp\3dtrans.dll&quot;;

CONST
  //...
GLOBAL
  //...
LOCAL
  //...
PRIVATE
  //...

BEGIN
    //...
END
</pre>
Desde el momento en que las librer&#237;as de funciones pueden ser desarrolladas de forma libre, <strong>no se garantiza el correcto funcionamiento de DIV Games Studio cuando se utilicen librer&#237;as DLL externas</strong>. Puede ser habitual el funcionamiento incorrecto del <strong>trazador de programas</strong> cuando en un juego se cargue una DLL que modifique partes vitales de la librer&#237;a de funciones o del gestor de procesos de DIV Games Studio.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> En la primera versi&#243;n del lenguaje de programaci&#243;n DIV, esta declaraci&#243;n se deb&#237;a hacer entre las secciones <strong>LOCAL</strong> y <strong>PRIVATE</strong> del programa.<br/><br/>
<strong>Nota 2:</strong> Las librer&#237;as preparadas para la primera versi&#243;n del lenguaje <strong>no funcionar&#225;n correctamente</strong> en versiones posteriores, debi&#233;ndose recompilar previamente estas librer&#237;as con los nuevos archivos de declaraciones. Es decir, que el c&#243;digo fuente de las librer&#237;as sigue siendo v&#225;lido, pero antes debe compilarse nuevamente con los nuevos archivos de cabecera (ya que estos contienen las declaraciones de los nuevos datos y estructuras existentes en el lenguaje).<br/><br/>
<strong>Nota 3:</strong> Si usted es un programador experto en C y Ensamblador, puede obtener m&#225;s informaci&#243;n sobre la creaci&#243;n de nuevas librer&#237;as en el archivo DLL\SOURCE\LEEME.TXT de DIV.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1015">C&#243;digo principal</h2><br/><br/>
<a href="#1086">BEGIN</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <strong>;</strong><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
El c&#243;digo principal de un programa comienza con la palabra reservada <a href="#1086">BEGIN</a>, tras la cual puede aparecer cualquier n&#250;mero de sentencias, y finaliza con la palabra reservada <a href="#1091">END</a>.<br/><br/>
Este c&#243;digo controla el proceso principal del programa, que es el encargado de inicializar el programa, controlar los bucles de men&#250; y de juego, y finalizar el programa.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;

GLOBAL
    opci&#243;n;             // Opci&#243;n elegida en el men&#250;.

BEGIN                   // Inicio del c&#243;digo principal.

    set_mode(m640x480); // Inicializaci&#243;n.
    set_fps(24, 4);
    // ...              // Carga ficheros, sonidos, etc.

    REPEAT              // Inicio bucle principal.

        opcion=0;       // Bucle de control del men&#250; de opciones.
        //...           // Inicializa el men&#250; de opciones.
        REPEAT
            // ...
            IF (key(_enter)) opcion=1; END  // Se elige jugar.
            IF (key(_esc)) opcion=2; END    // Se elige finalizar.
            FRAME;
        UNTIL (opcion&gt;0);

        IF (opcion==1)  // Si se ha elegido la opcion de jugar.

            // Inicializa regiones, scroll, etc.
            // Crea los procesos de juego.
            // Bucle de control del juego, espera a que finalice.

        END

    UNTIL (opcion==2);  // Final del bucle principal.

    let_me_alone();     // Finaliza todos los procesos.

END                     // Final del c&#243;digo pricipal.

// ...                  // Declaraci&#243;n de los procesos del programa.
</pre>
Que finalice la ejecuci&#243;n del c&#243;digo principal no implica que finalice la ejecuci&#243;n del programa, pues &#233;sta continuar&#225; si quedan procesos vivos; si se quiere forzar la terminaci&#243;n del programa cuando finalice este c&#243;digo, se puede utilizar, por ejemplo, la funci&#243;n <a href="#129">let_me_alone()</a> justo antes del <a href="#1091">END</a> que marca el final del c&#243;digo principal, para eliminar al resto de procesos que puedan quedar vivos.<br/><br/>
Tambi&#233;n se puede finalizar en cualquier punto del programa su ejecuci&#243;n mediante la funci&#243;n <a href="#109">exit()</a> que autom&#225;ticamente eliminar&#225; todos los procesos.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1016">Los bloques PROCESS</h2><br/><br/>
Existen dos tipos de bloques de c&#243;digo (adem&#225;s del <a href="#1015">c&#243;digo principal</a>): los bloques <strong>PROCESS</strong> (que se detallan a continuaci&#243;n), y los bloques <a href="#1408">FUNCTION</a>.<br/><br/>
<strong>PROCESS</strong> <a href="#1001">&lt;nombre&gt;</a> <strong>(</strong> <a href="#1018">&lt;par&#225;metros&gt;</a> <strong>)</strong><br/>
<a href="#1008">&lt;Declaraci&#243;n de datos privados&gt;</a><br/>
<a href="#1086">BEGIN</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <strong>;</strong><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
Un proceso debe comenzar con la palabra reservada <strong>PROCESS</strong> seguida de su nombre y sus <a href="#1018">par&#225;metros</a> de llamada entre par&#233;ntesis. Los par&#225;metros son una lista de datos en los que el proceso va a recibir diferentes valores. Los par&#233;ntesis son obligatorios incluso cuando el proceso no tenga par&#225;metros.<br/><br/>
Tras esta cabecera puede venir, de forma opcional, una secci&#243;n <a href="#1008">PRIVATE</a> donde se declaren datos que va a utilizar exclusivamente el proceso.<br/><br/>
Y, por &#250;ltimo, se especificar&#225; el c&#243;digo para el proceso, que es una secuencia de sentencias entre las palabras reservadas <a href="#1086">BEGIN</a> y <a href="#1091">END</a>.<br/><br/>
Un proceso se corresponde, normalmente, con un tipo de objeto del juego, como puede ser una nave, una explosion, un disparo, etc., y dentro del c&#243;digo del proceso se suele implementar un bucle dentro del cual se fijar&#225;n todos los valores necesarios de visualizaci&#243;n de dicho objeto (gr&#225;fico, coordenadas, etc.) y despu&#233;s, mediante la sentencia <a href="#1029">FRAME</a>, se dar&#225; la orden para visualizar el objeto con los atributos establecidos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE
    id2;
BEGIN
    id2=mi_proceso(160, 100)
    // ...
END

PROCESS mi_proceso(x, y)
PRIVATE
    n;
BEGIN
    graph=1;
    FROM n=0 to 99;
        x=x+2;
        y=y+1;
        FRAME;
    END
END
</pre>
Como se puede observar en este ejemplo, cuando se llama a un proceso &#233;ste devuelve su <a href="#1039">c&#243;digo identificador</a> (que en el ejemplo se guarda en la variable <a href="#1008">PRIVATE</a> del programa principal <strong>id2</strong>); si se quiere implementar un proceso al estilo de las funciones de otros lenguajes, que devuelva un resultado num&#233;rico, entonces se debe utilizar la sentencia <a href="#1028">RETURN(</a>valor<strong>)</strong> y no utilizar la sentencia <a href="#1029">FRAME</a> dentro del proceso, pues &#233;sta retorna al proceso padre (llamante), devolviendo el <a href="#1039">c&#243;digo identificador</a> del proceso como valor de retorno.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1408">Los bloques FUNCTION</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1017">Relaci&#243;n de sentencias</h2><br/><br/>
Una sentencia es una orden a ejecutar por el ordenador dentro de un programa. Estos son los posibles tipos de sentencias:<br/><br/>
Sentencias de asignaci&#243;n<br/>
<a href="#1019">=</a><br/>
<br/><br/>
Sentencias de control<br/>
<a href="#1020">IF</a><br/>
<a href="#1021">SWITCH</a><br/>
<br/><br/>
Sentencias de bucles<br/>
<a href="#1024">LOOP</a><br/>
<a href="#1043">FROM</a><br/>
<a href="#1023">REPEAT</a><br/>
<a href="#1022">WHILE</a><br/>
<a href="#1025">FOR</a><br/>
<br/><br/>
Sentencias de ruptura<br/>
<a href="#1026">BREAK</a><br/>
<a href="#1027">CONTINUE</a><br/>
<a href="#1028">RETURN</a><br/>
<br/><br/>
Sentencias especiales<br/>
<a href="#1029">FRAME</a><br/>
<a href="#1030">CLONE</a><br/>
<a href="#1031">DEBUG</a><br/>
<br/><br/>
Sentencias de llamada<br/>
<a href="#1033">Llamada a un proceso</a><br/>
<br/><br/>
Las sentencias siempre aparecen como un grupo de sentencias, desde ninguna (que no tiene sentido) hasta tantas como sean necesarias.<br/><br/>
Todas las sentencias se ejecutar&#225;n secuencialmente (la primera, la segunda, la tercera, ...) salvo por las excepciones que definen las sentencias que pueden controlar el flujo del programa (las sentencias de control, de bucles y de ruptura).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1018">Par&#225;metros de un proceso</h2><br/><br/>
Los par&#225;metros de un proceso son, b&#225;sicamente, una lista de datos en los cuales el proceso recibir&#225; distinta informaci&#243;n cada vez que sea invocado (llamado o utilizado) desde otro proceso.<br/><br/>
Los procesos pueden recibir par&#225;metros en los siguientes tipos de datos:<br/><br/>
- Un dato local predefinido (como <a href="#1123">x</a>, <a href="#1128">size</a>, <a href="#1127">flags</a>, ...).<br/><br/>
- Un dato local definido dentro de la secci&#243;n <a href="#1007">LOCAL</a>.<br/><br/>
- Un dato global definido dentro de la secci&#243;n <a href="#1006">GLOBAL</a>.<br/><br/>
- Un dato privado del proceso declarado dentro de la secci&#243;n <a href="#1008">PRIVATE</a> del propio proceso.<br/><br/>
- Un dato privado que <strong>no est&#233; declarado</strong> dentro de la secci&#243;n <a href="#1008">PRIVATE</a>.<br/><br/>
Entendi&#233;ndose, en todos estos casos, que un dato puede referirse a una variable, a una posici&#243;n concreta de una tabla o a un elemento dentro de una estructura.<br/><br/>
Para ejemplificar los diferentes tipos de par&#225;metros se muestra, a continuaci&#243;n, un programa con un proceso que recibe cinco par&#225;metros diferentes de los tipos indicados en la lista anterior, respectivamente.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
    puntos=0;
LOCAL
    energia=0;
BEGIN
    mi_proceso(1, 2, 3, 4, 5);
    // ...
END

PROCESS mi_proceso(x, energ&#237;a, puntos, n, m)
PRIVATE
    n;
BEGIN
    // ...
END
</pre>
El proceso <strong>mi_proceso</strong> recibe cinco par&#225;metros en cinco variables: local predefinida, local, global, <a href="#1008">private</a> declarada y <a href="#1008">private</a> sin declarar.<br/><br/>
Recibir en un dato global un par&#225;metro (como la variable <a href="#1006">GLOBAL</a> <strong>puntos</strong>) equivale a realizar la asignaci&#243;n (<strong>puntos=3;</strong>) y, despu&#233;s, llamar al proceso.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1019">Sentencia de asignaci&#243;n</h2><br/><br/>
Las sentencias de asignaci&#243;n sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;Referencia a un dato&gt;</a> <a href="#1073">=</a> <a href="#1035">&lt;expresi&#243;n&gt;</a> <a href="#1068">;</a><br/><br/>
Se debe indicar el dato en el cual se va a guardar el resultado de la expresi&#243;n, seguido del s&#237;mbolo <a href="#1073">=</a> (s&#237;mbolo de la <strong>asignaci&#243;n</strong>) y la expresi&#243;n num&#233;rica o l&#243;gica a evaluar cuando se ejecute la sentencia. Tras esta sentencia se debe poner siempre el s&#237;mbolo<a href="#1068"> ;(punto y coma)</a>.<br/><br/>
En una sentencia de asignaci&#243;n s&#243;lo est&#225; permitido asignar valores a objetos tales como variables (de cualquier tipo), a una <a href="#1011">posici&#243;n de una tabla</a>, o a un <a href="#1012">elemento de una estructura</a>.<br/><br/>
No es posible asignar un valor a una <a href="#1004">constante</a>, a una funci&#243;n o a un proceso, o, en general, a cualquier <a href="#1035">expresi&#243;n num&#233;rica o l&#243;gica</a>.<br/><br/>
Se muestra a continuaci&#243;n un programa con varias asignaciones.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x=x+1;
    angle=(angle*3)/2-pi/2;
    size=(x+y)/2;
    z=abs(x-y)*3-pow(x, 2);
    // ...
END
</pre>
&#201;sta es la forma b&#225;sica de las asignaciones, si bien existen otros s&#237;mbolos de asignaci&#243;n que, en lugar de asignar un nuevo valor al dato referido, modifican su valor. &#201;stos son los s&#237;mbolos de <strong>asignaciones operativas</strong>:<br/><br/>
<a href="#1058"> +=</a> Suma al dato el resultado de la expresi&#243;n<br/>
<strong>x=2; x+=2;</strong> -&gt; (x==4)<br/><br/>
<a href="#1062"> -=</a> Resta al dato el resultado de la expresi&#243;n<br/>
<strong>x=4; x-=2;</strong> -&gt; (x==2)<br/><br/>
<a href="#1055"> *=</a> Multiplica el dato por el resultado de la expresi&#243;n<br/>
<strong>x=2; x*=3;</strong> -&gt; (x==6)<br/><br/>
<a href="#1066"> /=</a> Divide el dato por el resultado de la expresi&#243;n<br/>
<strong>x=8; x/=2;</strong> -&gt; (x==4)<br/><br/>
<a href="#1049"> %=</a> Pone en el dato el resto de dividir al mismo entre el resultado de la expresi&#243;n<br/>
<strong>x=3; x%=2;</strong> -&gt; (x==1)<br/><br/>
<a href="#1052"> &amp;=</a> Realiza un AND (binario y/o l&#243;gico) entre el dato y el resultado de la expresi&#243;n y lo asigna como nuevo valor del dato<br/>
<strong>x=5; x&amp;=6;</strong> -&gt; (x==4)<br/><br/>
<a href="#1084"> |=</a> Realiza un OR (binario y/o l&#243;gico) entre el dato y el resultado de la expresi&#243;n y lo asigna como nuevo valor del dato<br/>
<strong>x=5; x|=6;</strong> -&gt; (x==7)<br/><br/>
<a href="#1081"> ^=</a> Realiza un OR exclusivo (XOR binario y/o l&#243;gico) entre el dato y el resultado de la expresi&#243;n y lo asigna como nuevo valor del dato<br/>
<strong>x=5; x^=3;</strong> -&gt; (x==3)<br/><br/>
<a href="#1078"> &gt;&gt;=</a> Rota a la derecha el dato tantas veces como indique el resultado de la expresi&#243;n (cada rotaci&#243;n a la derecha equivale a dividir entre 2 el dato)<br/>
<strong>x=8; x&gt;&gt;=2;</strong> -&gt; (x==2)<br/><br/>
<a href="#1071"> &lt;&lt;=</a> Rota a la izquierda el dato tantas veces como indique el resultado de la expresi&#243;n (cada rotaci&#243;n a la izquierda equivale a multiplicar por 2 el dato)<br/>
<strong>x=2; x&lt;&lt;=2;</strong> -&gt; (x==8)<br/><br/>
Tambi&#233;n se admiten dentro de la categor&#237;a de sentencias de asignaci&#243;n los <strong>incrementos</strong> y <strong>decrementos</strong> de un dato. Por ejemplo, si quisieramos sumarle 1 a la variable local <strong>x</strong> podr&#237;amos hacerlo con la sentencia <strong>x=x+1;</strong>, con la sentencia <strong>x+=1;</strong> o bien con el operador de incremento: <strong>x++;</strong> o<strong> ++x;</strong>.<br/><br/>
Es decir, se aceptan como sentencias de asignaci&#243;n <a href="#1057">incrementos ( ++ )</a> o <a href="#1061">decrementos ( -- )</a> de un dato.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1020">Sentencia IF</h2><br/><br/>
<strong>IF</strong> <a href="#1053">(</a> <a href="#1037">&lt;condici&#243;n&gt;</a> <a href="#1053">)</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
(o bien)<br/><br/>
<strong>IF</strong> <a href="#1053">(</a> <a href="#1037">&lt;condici&#243;n&gt;</a> <a href="#1053">)</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1090">ELSE</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
La sentencia <strong>IF</strong> sirve para ejecutar un bloque de sentencias opcionalmente, cuando se cumpla una condici&#243;n. En la segunda variante que aparece arriba, se ejecutar&#225; adem&#225;s otro bloque de sentencias (dentro de la secci&#243;n <a href="#1090">ELSE</a>) cuando la condici&#243;n <strong>no</strong> se cumpla.<br/><br/>
Se muestra, a continuaci&#243;n, un programa con varias sentencias <strong>IF</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN

    IF (key(_esc))
        exit(&quot;Adios!&quot;, 0);
    END

    IF (x&gt;100 AND x&lt;220)
        y=y+4;
    ELSE
        y=y-8;
    END

    IF (size&gt;0)
        size=size-1;
    END

    IF (timer[5]&gt;1000)
        z=1;
    ELSE
        z=-1;
    END

    // ...
END
</pre>
Es posible anidar sentencias <strong>IF</strong> sin ning&#250;n l&#237;mite, es decir, se pueden poner m&#225;s sentencias <strong>IF</strong> dentro de la parte que se ejecuta cuando se cumple la condici&#243;n (parte <strong>IF</strong>) o dentro de la que se ejecuta cuando la condici&#243;n no se cumple (parte <a href="#1090">ELSE</a>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1021">Sentencia SWITCH</h2><br/><br/>
<strong>SWITCH</strong> <a href="#1053">(</a> <a href="#1035">&lt;expresi&#243;n&gt;</a> <a href="#1053">)</a><br/>
<a href="#1087">CASE</a> <strong>&lt;rango de valores&gt;</strong> <a href="#1067">:</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/>
...<br/>
<a href="#1088">DEFAULT</a> <a href="#1067">:</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/>
<a href="#1091">END</a><br/><br/>
Una sentencia <strong>SWITCH</strong> consta de una serie de secciones <a href="#1087">CASE</a> y, opcionalmente, una secci&#243;n <a href="#1088">DEFAULT</a>.<br/><br/>
Cuando se ejecuta una sentencia <strong>SWITCH</strong>, primero se eval&#250;a la expresi&#243;n y despu&#233;s, si el resultado est&#225; dentro del rango de valores contemplados en la primera secci&#243;n <strong>CASE</strong>, se ejecutar&#225;n las sentencias de la misma y se dar&#225; por finalizada la sentencia. En caso de no estar el resultado de la expresi&#243;n en el primer <a href="#1087">CASE</a> se pasar&#225; a comprobarlo con el segundo <a href="#1087">CASE</a>, el tercero, etc. Y, por &#250;ltimo, si existe una secci&#243;n <a href="#1088">DEFAULT</a> y el resultado de la expresi&#243;n no ha coincidido con ninguna de las secciones <a href="#1087">CASE</a>, entonces se ejecutar&#225;n las sentencias de la secci&#243;n <a href="#1088">DEFAULT</a>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    SWITCH (x)
        CASE 1:
            x=-1;
        END
        CASE 2:
            x=-2;
        END
        CASE 3:
            x=-3;
        END
        CASE 99:
            x=-99;
        END
        DEFAULT:
            x=0;
        END
    END
END
</pre>
La sentencia <strong>SWITCH</strong> de este programa cambiar&#225; de signo la variable <strong>x</strong> si &#233;sta vale <strong>1</strong>, <strong>2</strong>, <strong>3</strong> o <strong>99</strong>; en caso contrario la pondr&#225; a <strong>0</strong>.<br/><br/>
<strong>Rango de valores de una secci&#243;n case</strong><hr/>
<br/><br/>
En una secci&#243;n case se puede especificar un valor, un rango de valores (m&#237;nimo <a href="#1064">..</a> m&#225;ximo), o una lista de valores y/o rangos separados por <a href="#1059">comas (,)</a>. Por ejemplo, la sentencia anterior se podr&#237;a haber expresado como:<br/><br/>
<strong>SWITCH (x)</strong><br/>
<strong>CASE 1..3, 99:</strong><br/>
<strong>x=-x;</strong><br/>
<strong>END</strong><br/>
<strong>DEFAULT:</strong><br/>
<strong>x=0;</strong><br/>
<strong>END</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Una vez ejecutada una de las secciones <a href="#1087">CASE</a> de una sentencia <strong>SWITCH</strong> <strong>ya no se ejecutar&#225;n m&#225;s secciones</strong>, aunque &#233;stas especifiquen tambi&#233;n el resultado de la expresi&#243;n, por ejemplo, en la siguiente sentencia:<br/><br/>
<strong>SWITCH (2+2)</strong><br/>
<strong>CASE 3..5:</strong><br/>
<strong>x=x+1;</strong><br/>
<strong>END</strong><br/>
<strong>CASE 2, 4, 6:</strong><br/>
<strong>y=y-1;</strong><br/>
<strong>END</strong><br/>
<strong>END</strong><br/><br/>
Se ejecutar&#225; la secci&#243;n <strong>x=x+1;</strong> y despu&#233;s se finalizar&#225; la sentencia, no ejecut&#225;ndose la secci&#243;n <strong>y=y-1;</strong> pues, aunque el resultado de la expresi&#243;n evaluada (<strong>4</strong>) est&#225; contemplado en ella, tambi&#233;n lo est&#225; en la secci&#243;n anterior, (ya que 4 est&#225; dentro del rango 3..5).<br/><br/>
No es necesario ordenar las secciones <a href="#1087">CASE</a> seg&#250;n sus valores (de menor a mayor, o de mayor a menor), pero s&#237; es imprescindible que la secci&#243;n <a href="#1088">DEFAULT</a> (en caso de haberla) sea la &#250;ltima secci&#243;n. No puede haber m&#225;s que una secci&#243;n <a href="#1088">DEFAULT</a>.<br/><br/>
Es posible anidar sentencias <strong>SWITCH</strong> sin ning&#250;n l&#237;mite, es decir, se pueden poner nuevas sentencias <strong>SWITCH</strong> dentro de una secci&#243;n <a href="#1087">CASE</a> (y cualquier otro tipo de sentencia).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1022">Sentencia WHILE</h2><br/><br/>
<strong>WHILE</strong> <a href="#1053">(</a> <a href="#1037">&lt;condici&#243;n&gt;</a> <a href="#1053">)</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/>
<br/><br/>
La sentencia <strong>WHILE</strong> (mientras) es una sentencia que implementa un <strong>bucle</strong>, es decir, que es capaz de <strong>repetir un grupo de sentencias un n&#250;mero determinado de veces</strong>.<br/><br/>
Para implementar este bucle se debe especificar entre par&#233;ntesis la condici&#243;n que se debe cumplir para que se ejecute el grupo de sentencias a continuaci&#243;n de la palabra reservada <strong>WHILE</strong>. Tras especificar esta condici&#243;n, se pondr&#225;n todas las sentencias que se necesita que se repitan y, finalmente, se marcar&#225; el final del bucle con la palabra reservada <a href="#1091">END</a> (No importa que dentro del bucle aparezcan m&#225;s palabras <a href="#1091">END</a> si &#233;stas forman parte de sentencias interiores a dicho bucle).<br/><br/>
Cuando se ejecute una sentencia <strong>WHILE</strong> se realizar&#225; la comprobaci&#243;n que se especifica y, si &#233;sta resulta cierta, se ejecutar&#225;n las sentencias interiores; en caso contrario, se continuar&#225; el programa a partir del <a href="#1091">END</a> que marca el final del <strong>WHILE</strong>.<br/><br/>
Si se han ejecutado las sentencias interiores (lo que se denomina realizar una <strong>iteraci&#243;n</strong> del bucle), se volver&#225; a comprobar la condici&#243;n y, si &#233;sta vuelve a ser cierta, se realizar&#225; otra <strong>iteraci&#243;n</strong> (se volver&#225;n a ejecutar las sentencias interiores). Este proceso se repetir&#225; hasta que, al comprobarse la condici&#243;n del <strong>WHILE</strong>, &#233;sta resulte falsa.<br/><br/>
Si seg&#250;n se ejecuta una sentencia <strong>WHILE</strong> la condici&#243;n resulta falsa directamente, entonces no se ejecutar&#225;n las sentencias interiores ninguna vez.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x=0;
    WHILE (x&lt;320)
        x=x+10;
        FRAME;
    END
END
</pre>
En este ejemplo se pondr&#225; la variable local <strong>x</strong> (coordenada x del proceso) a cero y despu&#233;s, mientras x sea menor que 320, se le sumar&#225;n 10 a <strong>x</strong> y se dar&#225; un <a href="#1029">FRAME</a>.<br/><br/>
Una sentencia <a href="#1026">BREAK</a> dentro de un bucle <strong>WHILE</strong> lo finalizar&#225; de forma inmediata, continuando el programa por la sentencia siguiente a dicho bucle.<br/><br/>
Una sentencia <a href="#1027">CONTINUE</a> dentro de un bucle <strong>WHILE</strong> forzar&#225; al programa a comprobar la condici&#243;n inicial inmediatamente y, si &#233;sta es cierta, volver a ejecutar las sentencias interiores desde el principio (tras el <strong>WHILE</strong>). Si la condici&#243;n resulta falsa, la sentencia <a href="#1027">CONTINUE</a> finalizar&#225; el bucle.<br/><br/>
Las sentencias interiores a un bucle <strong>WHILE</strong> pueden ser tantas como se quieran y de cualquier tipo, incluyendo, por supuesto, nuevos bucles <strong>WHILE</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1023"> Sentencia REPEAT</h2><br/><br/>
<strong>REPEAT</strong><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1097">UNTIL</a> <a href="#1053">(</a> <a href="#1037">&lt;condici&#243;n&gt;</a> <a href="#1053">)</a><br/><br/>
La sentencia <strong>REPEAT</strong> (REPEAT ... UNTIL( ... )) es una sentencia que implementa un <strong>bucle</strong>, es decir, que es capaz de <strong>repetir un grupo de sentencias un n&#250;mero determinado de veces</strong>.<br/><br/>
Para implementar este bucle se debe comenzar con la palabra reservada <strong>REPEAT</strong>, seguida de las sentencias que se quieren repetir una o m&#225;s veces y el final de la sentencia se determinar&#225; poniendo la palabra reservada <a href="#1097">UNTIL</a> seguida de la condici&#243;n que se debe cumplir para que <strong>se de por finalizada la sentencia</strong>.<br/><br/>
Cuando se ejecute una sentencia <strong>REPEAT</strong> se ejecutar&#225;n primero las sentencias interiores (las que est&#225;n entre el <strong>REPEAT</strong> y el <a href="#1097">UNTIL</a>) y, tras hacerlo, se comprobar&#225; la condici&#243;n especificada en el <a href="#1097">UNTIL</a> y si &#233;sta contin&#250;a siendo falsa, se volver&#225;n a ejecutar las sentencias interiores. El proceso se repetir&#225; hasta que la condici&#243;n del <a href="#1097">UNTIL</a> resulte cierta, continuando entonces la ejecuci&#243;n del programa tras esta sentencia.<br/><br/>
Cada vez que se ejecutan las sentencias interiores se dice que se ha realizado una <strong>iteraci&#243;n</strong> del bucle. La sentencia <strong>REPEAT</strong> ... <a href="#1097">UNTIL</a> (literalmente traducida como <strong>REPETIR</strong> ... <strong>HASTA</strong> (que se cumpla la) <strong>&lt;condici&#243;n&gt;</strong>) siempre ejecutar&#225; las sentencias interiores al menos una vez, ya que comprueba la condici&#243;n siempre tras ejecutarlas.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x=0;
    REPEAT
        x=x+10;
        FRAME;
    UNTIL (x&gt;320)
END
</pre>
En este ejemplo se pondr&#225; la variable local <strong>x</strong> (coordenada x del proceso) a cero y, despu&#233;s, se le sumar&#225;n 10 a <strong>x</strong> y se dar&#225; un <a href="#1029">FRAME</a> <strong>hasta</strong> que <strong>x</strong> sea un n&#250;mero mayor que 320.<br/><br/>
Una sentencia <a href="#1026">BREAK</a> dentro de un bucle <strong>REPEAT</strong> lo finalizar&#225; de forma inmediata, continuando el programa por la sentencia siguiente a dicho bucle.<br/><br/>
Una sentencia <a href="#1027">CONTINUE</a> dentro de un bucle <strong>REPEAT</strong> forzar&#225; al programa a realizar la comprobaci&#243;n del <a href="#1097">UNTIL</a> inmediatamente y, si &#233;sta es falsa, volver&#225; a ejecutar las sentencias interiores desde el principio (tras la palabra reservada <strong>REPEAT</strong>). Si la condici&#243;n resulta cierta, la sentencia <a href="#1027">CONTINUE</a> finalizar&#225; el bucle.<br/><br/>
Las sentencias interiores a un bucle <strong>REPEAT</strong> pueden ser tantas como se quieran y de cualquier tipo incluyendo, por supuesto, nuevos bucles <strong>REPEAT</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1024">Sentencia LOOP</h2><br/><br/>
<strong>LOOP</strong><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
La sentencia <strong>LOOP</strong> (bucle) es una sentencia que implementa un <strong>bucle infinito</strong>, es decir, que <strong>repite indefinidamente un grupo de sentencias</strong>.<br/><br/>
Para implementar este bucle se debe comenzar con la palabra reservada <strong>LOOP</strong>, seguida de las sentencias que se quieren repetir continuamente y la palabra reservada <a href="#1091">END</a> al final.<br/><br/>
Cuando en un programa se encuentre una sentencia <strong>LOOP</strong> ... <a href="#1091">END</a> se ejecutar&#225;n a partir de entonces, una y otra vez, todas las sentencias interiores a dicho bucle.<br/><br/>
Para finalizar un bucle <strong>LOOP</strong> se puede utlizar la sentencia <a href="#1026">BREAK</a> que, al ejecutarse dentro de un bucle de este tipo, forzar&#225; al programa a seguir a continuaci&#243;n del <a href="#1091">END</a>.<br/><br/>
Cada vez que se ejecutan las sentencias interiores se dice que se ha realizado una <strong>iteraci&#243;n</strong> del bucle. La sentencia <a href="#1027">CONTINUE</a>, dentro de un bucle, finalizar&#225; la <strong>iteraci&#243;n</strong> actual y comenzar&#225; la siguiente (el programa continuar&#225; ejecut&#225;ndose tras la palabra reservada <strong>LOOP</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x=0;
    LOOP
        IF (key(_esc))
            BREAK;
        END
        x=x+1;
        FRAME;
    END
END
</pre>
En este ejemplo se pondr&#225; la variable local <strong>x</strong> (coordenada x del proceso) a cero y, despu&#233;s, se le sumar&#225; 1 y se dar&#225; un <a href="#1029">FRAME</a> continuamente. Si se pulsa la tecla de escape (<strong>ESC</strong>) se ejecutar&#225; la sentencia <a href="#1026">BREAK</a>, finalizando el bucle <strong>LOOP</strong>.<br/><br/>
Las sentencias interiores a un bucle <strong>LOOP</strong> pueden ser tantas como se quieran y de cualquier tipo incluyendo, por supuesto, nuevos bucles <strong>LOOP</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1025">Sentencia FOR</h2><br/><br/>
<strong>FOR</strong> <a href="#1053">(</a>&lt;inicializaci&#243;n&gt;<a href="#1068">;</a> &lt;condici&#243;n&gt;<a href="#1068">;</a> &lt;incremento&gt;<a href="#1053">)</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
La sentencia <strong>FOR</strong> (r&#233;plica del lenguaje C) es una sentencia que implementa un <strong>bucle</strong>, es decir, que es capaz de <strong>repetir un grupo de sentencias un n&#250;mero determinado de veces</strong>.<br/><br/>
Para implementar este bucle se deben especificar, entre par&#233;ntesis, tres partes diferentes, separadas por s&#237;mbolos <a href="#1068">;</a> (punto y coma) tras la palabra reservada <strong>FOR</strong>. Estas tres partes son opcionales (pueden omitirse) y son las siguientes:<br/><br/>
- <strong>Inicializaci&#243;n</strong>. En esta parte se suele codificar una sentencia de asignaci&#243;n que fija el valor inicial de la variable que va a utilizarse como contador de <strong>iteraciones</strong> del bucle (a cada ejecuci&#243;n del grupo interior de sentencias se le denomina una <strong>iteraci&#243;n</strong> del bucle). Un ejemplo puede ser la sentencia de asignaci&#243;n <strong>x=0</strong>, que fijar&#237;a la variable <strong>x</strong> a cero al inicio del bucle (valor para la primera iteraci&#243;n).<br/><br/>
- <a href="#1037">Condici&#243;n</a>. En esta parte se especifica una condici&#243;n; justo antes de cada iteraci&#243;n se comprobar&#225; que sea cierta para pasar a ejecutar el grupo de sentencias. Si la condici&#243;n se eval&#250;a como falsa, se finalizar&#225; el bucle <strong>FOR</strong>, continuando el programa tras el <a href="#1091">END</a> del bucle <strong>FOR</strong>. Un ejemplo de condici&#243;n puede ser <strong>x&lt;10</strong>, que permitir&#225; que se ejecute el grupo interior de sentencias &#250;nicamente cuando la variable <strong>x</strong> sea un n&#250;mero menor que <strong>10</strong>.<br/><br/>
- <strong>Incremento</strong>. En la &#250;ltima de las tres partes es donde se indica el incremento de la variable usada como contador por cada iteraci&#243;n del bucle; normalmente &#233;sto se expresa tambi&#233;n con una sentencia de asignaci&#243;n. Por ejemplo, la sentencia <strong>x=x+1</strong> le sumar&#237;a <strong>1</strong> a la variable <strong>x</strong> tras cada iteraci&#243;n del bucle.<br/><br/>
Tras la definici&#243;n del bucle <strong>FOR</strong> con sus tres partes es donde debe aparecer el grupo de sentencias interiores al bucle que se van a repetir secuencialmente mientras se cumpla la condici&#243;n de permanencia (parte segunda). Tras este grupo de sentencias la palabra reservada <a href="#1091">END</a> determinar&#225; el final del bucle <strong>FOR</strong>.<br/><br/>
Cuando en un programa llega una sentencia <strong>FOR</strong> se ejecuta primero la parte de la inicializaci&#243;n y se comprueba la condici&#243;n; si &#233;sta es cierta se ejecutar&#225; el grupo de sentencias interiores y, despu&#233;s, la parte del incremento, volvi&#233;ndose a comprobar la condici&#243;n, etc. Si antes de cualquier iteraci&#243;n la condici&#243;n resulta falsa, finalizar&#225; la sentencia <strong>FOR</strong> inmediatamente.<br/><br/>
A continuaci&#243;n, se muestra un programa con un bucle <strong>FOR</strong> con las tres partes sugeridas en las secciones anteriores.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FOR ( x=0 ; x&lt;10 ; x=x+1 )
        // Aqu&#237; vendr&#237;an las sentencias interiores.
    END
END
</pre>
Este bucle se ejecutar&#237;a la primera vez con la variable <strong>x</strong> valiendo <strong>0</strong>, la segunda valiendo <strong>1</strong>, ..., y la &#250;ltima valiendo <strong>9</strong>; tras esta iteraci&#243;n se ejecutar&#237;a la parte del incremento, pasando <strong>x</strong> a valer <strong>10</strong> y, entonces, al comprobarse la condici&#243;n de permanencia en el bucle (que <strong>x</strong> sea menor que <strong>10</strong>) y resultar &#233;sta falsa, se dar&#237;a por finalizado el bucle.<br/><br/>
Como se ha mencionado, las tres partes en la definici&#243;n del bucle son opcionales; si se omitieran las tres:<br/><br/>
<strong>FOR ( ; ; )</strong><br/>
// ...<br/>
<strong>END</strong><br/><br/>
Entonces, este bucle es equivalente a un bucle <a href="#1024">LOOP</a> ... <a href="#1091">END</a>.<br/><br/>
Adem&#225;s en un bucle <strong>FOR</strong> pueden ponerse varias partes de inicializaci&#243;n, condici&#243;n o incremento separadas por comas (<a href="#1059">,</a>), ejecut&#225;ndose todas las inicializaciones al principio, luego comprob&#225;ndose todas las condiciones de permanencia (si cualquiera resulta falsa, el bucle finalizar&#225;), las asentencias interiores y, al final, tras cada iteraci&#243;n, todos los incrementos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FOR ( x=0, y=1000 ; x&lt;y ; x=x+2, y=y+1 )
        // Aqui vendr&#237;an las sentencias interiores.
    END
END
</pre>
Una sentencia <a href="#1026">BREAK</a> dentro de un bucle <strong>FOR</strong> lo finalizar&#225; de forma inmediata, continuando el programa por la sentencia siguiente a dicho bucle.<br/><br/>
Una sentencia <a href="#1027">CONTINUE</a> dentro de un bucle <strong>FOR</strong> forzar&#225; al programa a ejecutar directamente la parte del incremento y, despu&#233;s, realizar la comprobaci&#243;n de permanencia y, si &#233;sta es cierta, volver a ejecutar las sentencias interiores desde el principio. Si la condici&#243;n resulta cierta, la sentencia <a href="#1027">CONTINUE</a> finalizar&#225; el bucle <strong>FOR</strong>.<br/><br/>
Un bucle <strong>FOR</strong> es, pr&#225;cticamente, equivalente a un bucle <a href="#1022">WHILE</a> implementado de la siguiente forma:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x=0;
    WHILE (x&lt;10)
        // Aqui vendr&#237;an las sentencias interiores.
        x=x+1;
    END
END
</pre>
Con la &#250;nica excepci&#243;n de que una sentencia <a href="#1027">CONTINUE</a>, dentro de este bucle <a href="#1022">WHILE</a>, no ejecutar&#237;a la parte del incremento, mientras que en un bucle <strong>FOR</strong> s&#237; lo har&#237;a.<br/><br/>
Si en un bucle <strong>FOR</strong>, tras ejecutarse la inicializaci&#243;n, la condici&#243;n resulta falsa directamente, no se ejecutar&#225;n ninguna vez las sentencias interiores.<br/><br/>
Las sentencias interiores a un bucle <strong>FOR</strong> pueden ser tantas como se quieran y de cualquier tipo incluyendo, por supuesto, nuevos bucles <strong>FOR</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1026">Sentencia BREAK</h2><br/><br/>
Una sentencia <strong>BREAK</strong> dentro de un bucle lo finalizar&#225; de forma inmediata, continuando el programa por la sentencia siguiente a dicho bucle. No se puede poner esta sentencia m&#225;s que dentro de los siguientes bucles:<br/><br/>
<a href="#1022">LOOP</a> ... <a href="#1091">END</a><br/>
<a href="#1043">FROM</a> .. <a href="#1096">TO</a> .. <a href="#1095">STEP</a> .. ... <a href="#1091">END</a><br/>
<a href="#1023">REPEAT</a> ... <a href="#1097">UNTIL</a> <a href="#1053">(</a> .. <a href="#1053">)</a><br/>
<a href="#1024">WHILE</a> <a href="#1053">(</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
<a href="#1025">FOR</a> <a href="#1053">(</a> .. <strong>#1068;</strong> .. <a href="#1068">;</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
<br/><br/>
Un <strong>BREAK</strong> provocar&#225; que el programa contin&#250;e ejecut&#225;ndose tras el <a href="#1091">END</a> o <a href="#1097">UNTIL</a> del bucle m&#225;s cercano a la sentencia.<br/><br/>
En caso de haber varios bucles anidados (unos dentro de otros) la sentencia <strong>BREAK</strong> saldr&#225; &#250;nicamente del bucle m&#225;s interior de ellos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    LOOP
        REPEAT
            IF (key(_esc)) BREAK; END
            //...
        UNTIL (x==0);
        //...
    END
END
</pre>
En este ejemplo la sentencia <strong>BREAK</strong> saldr&#225; del <a href="#1023">REPEAT</a> ... <strong>UNTIL</strong> (cuando se pulse la tecla <strong>ESC</strong>), pero no del <a href="#1022">LOOP</a> ... <a href="#1091">END</a>.<br/><br/>
<strong>Importante</strong><hr/>
<br/><br/>
La sentencia <strong>BREAK</strong> no es v&#225;lida para finalizar sentencias <a href="#1020">IF</a>, ni <a href="#1021">SWITCH</a> (ni las secciones <a href="#1087">CASE</a> de esta sentencia), ni sentencias <a href="#1030">CLONE</a>.<br/><br/>
<strong>BREAK</strong> s&#243;lo puede finalizar las sentencias que implementan un bucle.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1027"> Sentencia CONTINUE</h2><br/><br/>
Una sentencia <strong>CONTINUE</strong> dentro de un bucle forzar&#225; al programa a finalizar la iteraci&#243;n actual del mismo y comenzar la siguiente.<br/><br/>
Se denomina <strong>iteraci&#243;n</strong> a cada ejecuci&#243;n del grupo de sentencias interior a un bucle (las sentencias entre un <a href="#1022">LOOP</a> y su <a href="#1091">END</a>, por ejemplo).<br/><br/>
No se puede poner esta sentencia m&#225;s que dentro de los siguientes bucles:<br/><br/>
<a href="#1022">LOOP</a> ... <a href="#1091">END</a><br/>
Un CONTINUE dentro de este bucle saltar&#225; al LOOP.<br/><br/>
<a href="#1043">FROM</a> .. <a href="#1096">TO</a> .. <a href="#1095">STEP</a> .. ... <a href="#1091">END</a><br/>
Un CONTINUE dentro de este bucle realizar&#225; el incremento (STEP) y, si no se ha pasado el valor indicado en el TO, continuar&#225; el programa al inicio del bucle.<br/><br/>
<a href="#1023">REPEAT</a> ... <a href="#1097">UNTIL</a> <a href="#1053">(</a>..<a href="#1053">)</a><br/>
Un CONTINUE dentro de este bucle saltar&#225; al UNTIL.<br/><br/>
<a href="#1024">WHILE</a> <a href="#1053">(</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
Un CONTINUE dentro de este bucle saltar&#225; al WHILE.<br/><br/>
<a href="#1025">FOR</a> <a href="#1053">(</a> .. <a href="#1068">;</a> .. <a href="#1068">;</a> .. <a href="#1053">)</a> ... <a href="#1091">END</a><br/>
Un CONTINUE dentro de este bucle realizar&#225; el incremento y la comparaci&#243;n; si &#233;sta &#250;ltima resulta cierta continuar&#225; el programa al inicio del bucle, si resulta falsa el programa continuar&#225; tras el END del FOR.<br/><br/>
En caso de haber varios bucles anidados (unos dentro de otros) la sentencia <strong>CONTINUE</strong> tendr&#225; efecto &#250;nicamente en el bucle m&#225;s interior de ellos.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FOR (x=0, y=0;x&lt;10;x++)
        IF (x&lt;5) CONTINUE; END
        y++;
    END
END
</pre>
En este ejemplo, tras ejecutarse el bucle completo, <strong>x</strong> valdr&#225; <strong>10</strong> e <strong>y</strong> valdr&#225; <strong>5</strong>, pues mientras <strong>x</strong> es menor que 5 la sentencia <strong>CONTINUE</strong> impide que se ejecute la sentencia <strong>y++;</strong>.<br/><br/>
<strong>Importante</strong><hr/>
<br/><br/>
La sentencia <strong>CONTINUE</strong> no es v&#225;lida dentro de sentencias <a href="#1020">IF</a>, ni <a href="#1021">SWITCH</a> (ni las secciones <a href="#1087">CASE</a> de esta sentencia), ni sentencias <a href="#1030">CLONE</a> (ya que estas sentencias no implementan bucles y, por tanto, no realizan iteraciones).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1028">Sentencia RETURN</h2><br/><br/>
La sentencia <strong>RETURN</strong> finaliza el proceso actual de forma inmediata, como si se llegara al <a href="#1091">END</a> de su <a href="#1086">BEGIN</a>.<br/><br/>
Esta sentencia en el c&#243;digo principal lo finalizar&#225;, pero si quedan procesos vivos &#233;stos se seguir&#225;n ejecutando. Para terminar un programa y todos sus procesos se puede utilizar, por ejemplo, la funci&#243;n <a href="#109">exit()</a>.<br/><br/>
Un <strong>RETURN</strong> dentro de un proceso lo finalizar&#225;, matando a dicho proceso.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    LOOP
        IF (key(_esc))
            RETURN;
        END
        FRAME;
    END
END
</pre>
En este ejemplo, al pulsarse la tecla de escape (<strong>ESC</strong>) se ejecutar&#225; la sentencia <strong>RETURN</strong>, finalizando el programa.<br/><br/>
<strong>Uso de RETURN para retornar un valor</strong><hr/>
<br/><br/>
Es posible construir procesos con un comportamiento similar a las funciones de otros lenguajes de programaci&#243;n, que <strong>reciban una serie de par&#225;metros y devuelvan un valor</strong>. Por ejemplo, un proceso que reciba dos valores num&#233;ricos y devuelva el mayor de ambos.<br/><br/>
Para ello, se debe utilizar esta sentencia con la siguiente sintaxis:<br/><br/>
<strong>RETURN(</strong><a href="#1035">&lt;expresi&#243;n&gt;</a><strong>)</strong><br/><br/>
Tambi&#233;n es importante no utilizar la sentencia <a href="#1029">FRAME</a> dentro del proceso, pues &#233;sta retornar&#225; inmediatamente al proceso llamante. Cuando el compilador encuentra la sentencia <a href="#1029">FRAME</a> dentro de un <a href="#1016">PROCESS</a> lo cataloga directamente como proceso, descartando su posible uso como funci&#243;n.<br/><br/>
<strong>Importante:</strong> Para poder retornar un valor con la sentencia <strong>RETURN</strong> despu&#233;s de haber ejecutado una o varias sentencias <a href="#1029">FRAME</a>, se debe construir un bloque de tipo <a href="#1408">FUNCTION</a>.<br/><br/>
<hr/>
<br/><br/>
A continuaci&#243;n se muestra el ejemplo antes propuesto: una implementaci&#243;n de la funci&#243;n matem&#225;tica <strong>max</strong> que devuelve el mayor de sus dos par&#225;metros.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    x=max(2, 3)+max(5, 4);
END
PROCESS max(a, b)
BEGIN
    IF (a&gt;b)
        RETURN(a);
    ELSE
        RETURN(b);
    END
END
</pre>
Tras ejecutarse este programa, la variable <strong>x</strong> del proceso principal valdr&#225; <strong>8</strong> (3+5).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Por defecto, si se utiliza la sentencia <strong>RETURN</strong> sin la expresi&#243;n entre par&#233;ntesis o la sentencia <a href="#1029">FRAME</a> en un proceso, el valor de retorno del mismo ser&#225; su <a href="#1039">c&#243;digo identificador</a> de proceso.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1029">Sentencia FRAME</h2><br/><br/>
La sentencia <strong>FRAME</strong> es una pieza clave dentro del lenguaje. El funcionamiento de un programa es, a grandes rasgos, el siguiente:<br/><br/>
- Comienza ejecut&#225;ndose el proceso principal, el cual puede crear m&#225;s procesos (objetos del juego) en cualquier punto. Todos los procesos pueden finalizar en cualquier momento, crear o eliminar otros procesos.<br/><br/>
- Los juegos se visualizar&#225;n siempre imagen a imagen (frame by frame). En cada imagen, el sistema ejecutar&#225; todos los procesos existentes en ese momento, uno por uno, hasta que cada uno ejecute la sentencia <strong>FRAME</strong>, que indicar&#225; que est&#225; listo para la siguiente visualizaci&#243;n (imagen).<br/><br/>
En la preparaci&#243;n de cada imagen todos los procesos ser&#225;n ejecutados en el orden de prioridad establecido (la variable local <a href="#1121">priority</a> de los procesos determina este orden).<br/><br/>
Luego esta sentencia es algo as&#237; como la orden de visualizaci&#243;n de los procesos.<br/><br/>
Si un proceso comienza a ejecutarse y no finaliza ni ejecuta esta sentencia, entonces el programa se quedar&#225; bloqueado, ya que existe un proceso que no est&#225; nunca listo para la siguiente visualizaci&#243;n; por lo que el sistema ser&#225; incapaz de mostrar la siguiente imagen.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    mi_proceso();
    mi_proceso();
    LOOP
        IF (key(_esc))
            mi_segundo_proceso();
        END
        FRAME;
    END
END
PROCESS mi_proceso()
BEGIN
    LOOP
        FRAME;
    END
END
PROCESS mi_segundo_proceso()
BEGIN
    LOOP
    END
END
</pre>
En este programa el proceso principal (de tipo <strong>mi_juego</strong>) crea otros dos procesos (de tipo <strong>mi_proceso</strong>); a partir de este momento los tres procesos se ejecutar&#225;n continuamente, cada uno hasta su sentencia <strong>FRAME</strong>. Pero si se pulsa la tecla de escape (<strong>ESC</strong>), el proceso principal crear&#225; un nuevo proceso (de tipo <strong>mi_segundo_proceso</strong>) que se quedar&#225; en un bucle <a href="#1024">LOOP</a> indefinidamente, sin ejecutar ning&#250;n <strong>FRAME</strong>, por lo que el programa quedar&#225; interrumpido (el sistema advertir&#225; de dicha situaci&#243;n transcurridos unos segundos, ver <a href="#1115">max_process_time</a>).<br/><br/>
B&#225;sicamente, todos los procesos que se corresponden con objetos de un juego construyen un bucle dentro del cual, cada imagen, fija todos sus valores de visualizaci&#243;n (<a href="#1123">x</a>, <a href="#1124">y</a>, <a href="#1126">graph</a>, <a href="#1128">size</a>, <a href="#1129">angle</a>, ...) y, despu&#233;s, ejecutan la sentencia <strong>FRAME</strong>.<br/><br/>
<strong>Sincronizaci&#243;n de procesos</strong><hr/>
<br/><br/>
Es posible utilizar esta sentencia con la siguiente sintaxis:<br/><br/>
<strong>FRAME(</strong>&lt;porcentaje&gt;<strong>)</strong><br/><br/>
Poniendo un porcentaje entero, de 0 a 100 o mayor, entre par&#233;ntesis tras la palabra reservada <strong>FRAME</strong>.<br/><br/>
Este porcentaje indicar&#225; el tanto por ciento de la siguiente imagen completado por el proceso; es decir, cuando no se especifica dicho porcentaje es lo mismo que si se pusiera <strong>FRAME(100)</strong> (se ha completado el 100% del trabajo previo a la siguiente visualizaci&#243;n por parte del proceso).<br/><br/>
Por ejemplo, si un proceso ejecuta en un bucle la sentencia <strong>FRAME(25)</strong>, necesitar&#225; ejecutarla <strong>4 veces</strong> antes de estar listo para la siguiente visualizaci&#243;n (ya que 4*25% es el 100%).<br/><br/>
En el otro extremo, si un proceso ejecuta dentro de su bucle la sentencia <strong>FRAME(400)</strong>, cuando se ejecute la primera vez habr&#225; completado ya un 400% de la visualizaci&#243;n, por lo que, aun tras visualizarse, le seguir&#225; restando un 300% de visualizaci&#243;n completado. Por ello, en la preparaci&#243;n de las siguientes <strong>3</strong> im&#225;genes el sistema no ejecutar&#225; dicho proceso, pues ya est&#225; listo para la visualizaci&#243;n. Luego este proceso se ejecutar&#237;a s&#243;lo una de cada 4 im&#225;genes (al contrario que el ejemplo del p&#225;rrafo anterior, que se ejecutaba 4 veces por cada imagen del juego).<br/><br/>
Los procesos no llegar&#225;n a la siguiente visualizaci&#243;n hasta no dar, <strong>por lo menos, el 100%</strong>. Por ejemplo, si un proceso ejecuta siempre sentencias <strong>FRAME(80)</strong>, las ejecutar&#225; dos veces antes de la primera visualizaci&#243;n con lo que llevar&#225; el 160% (2*80%) de la visualizaci&#243;n completado. Para la siguiente visualizaci&#243;n tendr&#225;, por tanto, un 60% pre-completado (160%-100%); por ello, en la segunda visualizaci&#243;n tan s&#243;lo requerir&#225; una sentencia <strong>FRAME(80)</strong> para visualizarse, ya que este 80%, unido al 60% sobrante de la primera, har&#225; un total de un 140% completado, con lo cual se visualizar&#225; inmediatamente, e incluso le sobrar&#225; otro 40% para la preparaci&#243;n de la siguiente imagen.<br/><br/>
<hr/>
<br/><br/>
Una sentencia <strong>FRAME(0)</strong>, que complete un 0% de la siguiente visualizaci&#243;n, puede tener sentido en estos dos casos:<br/><br/>
- Puede ser una forma de forzar al sistema a que ejecute en ese punto al resto de los procesos que tienen la misma prioridad que el actual y que, tras ellos, vuelva a ejecutarlo.<br/><br/>
- O puede ser una forma de inicializar funciones como <a href="#120">get_id()</a> o <a href="#104">collision()</a>, pues &#233;stas devuelven unos determinados valores para cada imagen; si se quiere volver a obtener valores de nuevo, se puede ejecutar una sentencia <strong>FRAME(0)</strong> que estas funciones interpretar&#225;n como una nueva imagen.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1030">Sentencia CLONE</h2><br/><br/>
<strong>CLONE</strong><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
Esta sentencia crea un nuevo proceso id&#233;ntico al actual, con la salvedad de que las sentencias entre las palabras reservadas <strong>CLONE</strong> y <a href="#1091">END</a> se ejecutar&#225;n &#250;nicamente en el nuevo proceso y no en el actual.<br/><br/>
Por ejemplo, si cualquier proceso del programa, con unas coordenadas (<a href="#1123">x</a>, <a href="#1124">y</a>) determinadas y un gr&#225;fico (<a href="#1126">graph</a>) concreto, ejecuta la siguiente sentencia:<br/><br/>
<strong>CLONE</strong><br/>
x=x+100;<br/>
<a href="#1091">END</a><br/><br/>
Se crear&#225; un nuevo proceso identico a &#233;l, con el mismo gr&#225;fico y los mismos valores en todas sus variables, a excepci&#243;n de la coordenada <a href="#1123">x</a>, que el nuevo proceso tendr&#225; <strong>100</strong> puntos m&#225;s a la derecha.<br/><br/>
Esta sentencia se utiliza para crear r&#233;plicas de un proceso, dividirlo en dos procesos (casi) iguales.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    // ...
    x=0;
    y=0;
    CLONE
        x=x+10;
    END
    CLONE
        y=y+10;
    END
    // ...
END
</pre>
En este ejemplo, las <strong>2</strong> sentencias <strong>CLONE</strong> crear&#225;n <strong>3</strong> copias del proceso principal (y no 2, como podr&#237;a haberse esperado).<br/><br/>
Al ejecutarse la primera sentencia <strong>CLONE</strong> se crear&#225; un nuevo proceso, con lo que habr&#225; <strong>2</strong>: uno en (x=0, y=0) y otro en (x=10, y=0). Y estos dos procesos ejecutar&#225;n la segunda sentencia <strong>CLONE</strong>, el primero (el original) creando con ello un nuevo proceso en (x=0, y=10), y el segundo crear&#225; el nuevo proceso en (x=10, y=10).<br/><br/>
Para crearse &#250;nicamente <strong>2</strong> copias del proceso original se podr&#237;a haber construido el programa, por ejemplo, de la siguiente forma:<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    // ...
    x=0;
    y=0;
    CLONE
        x=x+10;
        CLONE
            y=y+10;
        END
    END
    // ...
END
</pre>
El proceso original (x=0, y=0) crear&#225; uno en (x=10, y=0) y &#233;ste, a su vez, otro en (x=10, y=10), creandose &#250;nicamente dos copias del original.<br/><br/>
Se debe, por tanto, tener mucho cuidado con el uso de la sentencia <strong>CLONE</strong> de forma secuencial o dentro de un <strong>bucle</strong>, pues se debe contar con que los primeros &#39;<strong>clones</strong>&#39; pueden crear, a su vez, a nuevos &#39;<strong>clones</strong>&#39;.<br/><br/>
Esta sentencia permite usarse sin poner sentencias entre las palabras <strong>CLONE</strong> y <a href="#1091">END</a>. Pero, al menos en un principio, no parece tener mucho sentido el querer tener dos procesos id&#233;nticos, con las mismas coordenadas, el mismo gr&#225;fico y ejecutando el mismo c&#243;digo.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1031">Sentencia DEBUG</h2><br/><br/>
La sentencia <strong>DEBUG</strong> invocar&#225; al trazador (o debugger) interactivo cuando se ejecute.<br/><br/>
Se suele utilizar para depurar programas, es decir, para encontrar posibles errores que tengan los programas. Se suele poner, en ocasiones, en los siguientes puntos.<br/><br/>
- Donde se quiera comprobar que una parte del programa ha hecho lo que se esperaba que hiciera; tras ejecutarse dicha parte, <strong>DEBUG</strong> invocar&#225; al trazador, desde donde pueden comprobarse todos los procesos activos y el valor de todas sus variables.<br/><br/>
- Cuando no se est&#225; muy seguro de si algo puede suceder en un programa, se puede poner esta sentencia en dicho punto, para que nos avise en caso de que suceda.<br/><br/>
Esta sentencia se pone &#250;nicamente de forma temporal hasta que se localiza el error buscado; una vez encontrado ya no es necesaria la sentencia por lo que se puede quitar del programa, ya que por lo dem&#225;s, no tiene ning&#250;n otro efecto.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    // ...
    IF (x&lt;0)
        DEBUG;
    END
    // ...
END
</pre>
En este ejemplo se comprueba, en un determinado punto del programa, que la coordenada <strong>x</strong> del proceso no sea un n&#250;mero negativo (menor que cero); si esto sucediera, se invocar&#225; al trazador para poder investigar por qu&#233; ha sucedido.<br/><br/>
Cuando se ejecuta esta sentencia se abre un cuadro de di&#225;logo que nos ofrece las siguientes opciones:<br/><br/>
- Desabilitar la sentencia <strong>DEBUG</strong>, para que no vuelva a activarse en esta ejecuci&#243;n del programa.<br/><br/>
- Detener el programa y entrar en el trazador, para poder examinar todos los procesos y sus variables.<br/><br/>
- O terminar de inmediato la ejecuci&#243;n del programa, regresando a la edici&#243;n del mismo en el entorno gr&#225;fico de ventanas.<br/><br/>
Adem&#225;s, si se pulsa la tecla de escape <strong>ESC</strong> en dicho cuadro, simplemente se ignorar&#225; dicha sentencia <strong>DEBUG</strong> y se continuar&#225; ejecutando el programa normalmente.<br/><br/>
<hr/>
<br/><br/>
Cuando se ejecuta un programa desde el entorno gr&#225;fico de ventanas, puede invocarse al trazador en cualquier instante pulsando la tecla <strong>F12</strong>.<br/><br/>
Al invocarse de esta forma al trazador, el programa ser&#225; interrumpido siempre justo antes de empezar a procesar una nueva imagen, estando todos los procesos por ejecutar antes de la pr&#243;xima visualizaci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1032">Lista de funciones del lenguaje</h2><br/><br/>
Funciones de interacci&#243;n entre procesos<br/>
<a href="#104">collision()</a><br/>
<a href="#116">get_angle()</a><br/>
<a href="#117">get_dist()</a><br/>
<a href="#118">get_distx()</a><br/>
<a href="#119">get_disty()</a><br/>
<a href="#120">get_id()</a><br/>
<a href="#129">let_me_alone()</a><br/>
<a href="#158">signal()</a><br/>
<br/><br/>
Funciones sobre geometr&#237;a<br/>
<a href="#101">advance()</a><br/>
<a href="#113">fget_angle()</a><br/>
<a href="#114">fget_dist()</a><br/>
<a href="#142">near_angle()</a><br/>
<a href="#183">xadvance()</a><br/>
<br/><br/>
Funciones de b&#250;squeda de caminos<br/>
<a href="#185">path_find()</a><br/>
<a href="#187">path_free()</a><br/>
<a href="#186">path_line()</a><br/>
<br/><br/>
Funciones matem&#225;ticas<br/>
<a href="#100">abs()</a><br/>
<a href="#246">acos()</a><br/>
<a href="#245">asin()</a><br/>
<a href="#247">atan()</a><br/>
<a href="#248">atan2()</a><br/>
<a href="#243">cos()</a><br/>
<a href="#145">pow()</a><br/>
<a href="#242">sin()</a><br/>
<a href="#160">sqrt()</a><br/>
<a href="#244">tan()</a><br/>
<br/><br/>
Funciones de aleatorios<br/>
<a href="#149">rand()</a><br/>
<a href="#150">rand_seed()</a><br/>
<br/><br/>
Funciones gr&#225;ficas<br/>
<a href="#103">clear_screen()</a><br/>
<a href="#123">get_pixel()</a><br/>
<a href="#135">map_block_copy()</a><br/>
<a href="#136">map_get_pixel()</a><br/>
<a href="#137">map_put()</a><br/>
<a href="#138">map_put_pixel()</a><br/>
<a href="#139">map_xput()</a><br/>
<a href="#188">new_map()</a><br/>
<a href="#146">put()</a><br/>
<a href="#147">put_pixel()</a><br/>
<a href="#148">put_screen()</a><br/>
<a href="#212">screen_copy()</a><br/>
<a href="#173">xput()</a><br/>
<br/><br/>
Funciones de primitivas gr&#225;ficas<br/>
<a href="#250">delete_draw()</a><br/>
<a href="#249">draw()</a><br/>
<a href="#251">move_draw()</a><br/>
<br/><br/>
Funciones del sistema de audio<br/>
<a href="#256">change_channel()</a><br/>
<a href="#102">change_sound()</a><br/>
<a href="#175">reset_sound()</a><br/>
<a href="#178">set_volume()</a><br/>
<br/><br/>
Funciones para efectos de sonido<br/>
<a href="#221">is_playing_sound()</a><br/>
<a href="#134">load_pcm()</a><br/>
<a href="#134">load_wav()</a><br/>
<a href="#159">sound()</a><br/>
<a href="#167">stop_sound()</a><br/>
<a href="#170">unload_pcm()</a><br/>
<a href="#170">unload_wav()</a><br/>
<br/><br/>
Funciones para m&#250;sica CD<br/>
<a href="#127">is_playing_cd()</a><br/>
<a href="#144">play_cd()</a><br/>
<a href="#164">stop_cd()</a><br/>
<br/><br/>
Funciones para m&#250;sica digital<br/>
<a href="#220">get_song_line()</a><br/>
<a href="#219">get_song_pos()</a><br/>
<a href="#222">is_playing_song()</a><br/>
<a href="#214">load_song()</a><br/>
<a href="#218">set_song_pos()</a><br/>
<a href="#216">song()</a><br/>
<a href="#217">stop_song()</a><br/>
<a href="#215">unload_song()</a><br/>
<br/><br/>
Funciones de entrada<br/>
<a href="#121">get_joy_button()</a><br/>
<a href="#122">get_joy_position()</a><br/>
<a href="#128">key()</a><br/>
<br/><br/>
Funciones para el manejo de la paleta<br/>
<a href="#105">convert_palette()</a><br/>
<a href="#110">fade()</a><br/>
<a href="#111">fade_off()</a><br/>
<a href="#112">fade_on()</a><br/>
<a href="#264">find_color()</a><br/>
<a href="#266">force_pal()</a><br/>
<a href="#133">load_pal()</a><br/>
<a href="#154">roll_palette()</a><br/>
<a href="#179">set_color()</a><br/>
<br/><br/>
Funciones para scroll y modo 7<br/>
<a href="#140">move_scroll()</a><br/>
<a href="#152">refresh_scroll()</a><br/>
<a href="#162">start_mode7()</a><br/>
<a href="#163">start_scroll()</a><br/>
<a href="#165">stop_mode7()</a><br/>
<a href="#166">stop_scroll()</a><br/>
<br/><br/>
Funciones para el modo 8<br/>
<a href="#195">get_point_m8()</a><br/>
<a href="#193">get_sector_height()</a><br/>
<a href="#198">get_sector_texture()</a><br/>
<a href="#200">get_wall_texture()</a><br/>
<a href="#191">go_to_flag()</a><br/>
<a href="#189">load_wld()</a><br/>
<a href="#201">set_env_color()</a><br/>
<a href="#196">set_fog()</a><br/>
<a href="#194">set_point_m8()</a><br/>
<a href="#192">set_sector_height()</a><br/>
<a href="#197">set_sector_texture()</a><br/>
<a href="#199">set_wall_texture()</a><br/>
<a href="#190">start_mode8()</a><br/>
<a href="#182">stop_mode8()</a><br/>
<br/><br/>
Funciones para imprimir textos<br/>
<a href="#107">delete_text()</a><br/>
<a href="#131">load_fnt()</a><br/>
<a href="#141">move_text()</a><br/>
<a href="#177">unload_fnt()</a><br/>
<a href="#171">write()</a><br/>
<a href="#253">write_in_map()</a><br/>
<a href="#172">write_int()</a><br/>
<br/><br/>
Funciones de cadenas de texto<br/>
<a href="#184">char()</a><br/>
<a href="#210">lower()</a><br/>
<a href="#203">strcat()</a><br/>
<a href="#206">strchr()</a><br/>
<a href="#205">strcmp()</a><br/>
<a href="#202">strcpy()</a><br/>
<a href="#211">strdel()</a><br/>
<a href="#204">strlen()</a><br/>
<a href="#208">strset()</a><br/>
<a href="#207">strstr()</a><br/>
<a href="#209">upper()</a><br/>
<br/><br/>
Funciones de conversi&#243;n de cadenas<br/>
<a href="#254">calculate()</a><br/>
<a href="#255">itoa()</a><br/>
<br/><br/>
Funciones para animaciones<br/>
<a href="#108">end_fli()</a><br/>
<a href="#115">frame_fli()</a><br/>
<a href="#153">reset_fli()</a><br/>
<a href="#161">start_fli()</a><br/>
<br/><br/>
Funciones de regiones de pantalla<br/>
<a href="#106">define_region()</a><br/>
<a href="#143">out_region()</a><br/>
<br/><br/>
Funciones de informaci&#243;n sobre gr&#225;ficos<br/>
<a href="#124">get_point()</a><br/>
<a href="#125">get_real_point()</a><br/>
<a href="#126">graphic_info()</a><br/>
<br/><br/>
Funciones de inicializaci&#243;n<br/>
<a href="#156">set_fps()</a><br/>
<a href="#157">set_mode()</a><br/>
<br/><br/>
Funciones de carga de recursos<br/>
<a href="#132">load_fpg()</a><br/>
<a href="#174">load_map()</a><br/>
<a href="#174">load_pcx()</a><br/>
<a href="#169">unload_fpg()</a><br/>
<a href="#176">unload_map()</a><br/>
<a href="#176">unload_pcx()</a><br/>
<br/><br/>
Funciones de grabaci&#243;n de mapas<br/>
<a href="#241">save_map()</a><br/>
<a href="#241">save_pcx()</a><br/>
<br/><br/>
Funciones de grabaci&#243;n de datos<br/>
<a href="#130">load()</a><br/>
<a href="#155">save()</a><br/>
<br/><br/>
Funciones de archivos<br/>
<a href="#224">fclose()</a><br/>
<a href="#229">filelength()</a><br/>
<a href="#230">flush()</a><br/>
<a href="#223">fopen()</a><br/>
<a href="#225">fread()</a><br/>
<a href="#227">fseek()</a><br/>
<a href="#228">ftell()</a><br/>
<a href="#226">fwrite()</a><br/>
<br/><br/>
Funciones de directorios<br/>
<a href="#235">chdir()</a><br/>
<a href="#238">disk_free()</a><br/>
<a href="#231">get_dirinfo()</a><br/>
<a href="#232">get_fileinfo()</a><br/>
<a href="#233">getdrive()</a><br/>
<a href="#236">mkdir()</a><br/>
<a href="#237">remove()</a><br/>
<a href="#234">setdrive()</a><br/>
<br/><br/>
Funciones de compresi&#243;n<br/>
<a href="#262">compress_file()</a><br/>
<a href="#263">uncompress_file()</a><br/>
<br/><br/>
Funciones de encriptaci&#243;n<br/>
<a href="#261">decode_file()</a><br/>
<a href="#259">encode()</a><br/>
<a href="#260">encode_file()</a><br/>
<br/><br/>
Funciones de sistema<br/>
<a href="#109">exit()</a><br/>
<a href="#240">ignore_error()</a><br/>
<a href="#168">system()</a><br/>
<br/><br/>
Funciones de memoria din&#225;mica<br/>
<a href="#258">free()</a><br/>
<a href="#257">malloc()</a><br/>
<a href="#239">memory_free()</a><br/>
<br/><br/>
Funciones de red<br/>
<a href="#181">net_get_games()</a><br/>
<a href="#180">net_join_game()</a><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para obtener ayuda de una funci&#243;n en concreto directamente, sit&#250;e el cursor de edici&#243;n sobre el nombre de la funci&#243;n (en el editor de programas) y pulse <strong>F1</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1033">Llamada a un proceso</h2><br/><br/>
&lt;nombre_del_proceso&gt;<strong>(</strong>&lt;lista de par&#225;metros&gt;<strong>)</strong><br/><br/>
Una llamada a un proceso se hace poniendo el <a href="#1001">nombre</a> del proceso (su nombre), seguido de una lista con tantas expresiones separadas por <a href="#1059">comas (,)</a>, como <a href="#1018">par&#225;metros</a> tenga el proceso, entre <a href="#1053">par&#233;ntesis (())</a>. Los par&#233;ntesis son obligatorios aun cuando el proceso no tenga <a href="#1018">par&#225;metros</a> de llamada.<br/><br/>
Una llamada a un proceso siempre devolver&#225; un valor, que depende de cual de las siguientes acciones realice primero el proceso llamado.<br/><br/>
- Si ejecuta la sentencia <a href="#1029">FRAME</a> el proceso retornar&#225; su <a href="#1039">c&#243;digo identificador</a>.<br/><br/>
- Si el proceso ejecuta la sentencia <a href="#1028">RETURN</a><a href="#1053">(</a>&lt;expresi&#243;n&gt;<a href="#1053">)</a> retornar&#225; el resultado de dicha expresi&#243;n.<br/><br/>
- Si el proceso termina, bien porque llegue el <a href="#1091">END</a> de su <a href="#1086">BEGIN</a> o porque ejecute una sentencia <a href="#1028">RETURN</a> sin expresi&#243;n, el proceso retornar&#225; el <a href="#1039">c&#243;digo identificador</a> que tuvo, pero como el proceso ha finalizado (muerto), se debe tener en cuenta que dicho <a href="#1039">c&#243;digo identificador</a> puede ser ahora utilizado por cualquier otro proceso que se cree a partir de ahora.<br/><br/>
El valor de retorno puede ignorarse, asignarse a una variable o bien utilizarse dentro de una expresi&#243;n.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE
  id2;
BEGIN
    mi_proceso(0, 0);
    id2=mi_proceso(320, 200);
    // ...
END
PROCESS mi_proceso(x, y)
BEGIN
    LOOP
        FRAME;
    END
END
</pre>
En este ejemplo el proceso principal <strong>mi_juego</strong> realiza dos llamadas al proceso <strong>mi_proceso</strong>, que recibe dos par&#225;metros en sus variables locales <strong>x</strong> e <strong>y</strong>.<br/><br/>
Como el proceso ejecuta la sentencia <a href="#1029">FRAME</a> devolver&#225; su <a href="#1039">c&#243;digo identificador</a>.<br/><br/>
Se puede observar c&#243;mo el valor devuelto en la primera llamada al proceso es despreciado (no se utiliza para nada), y c&#243;mo en la segunda se asigna el <a href="#1039">c&#243;digo identificador</a> de <strong>mi_proceso(320, 200)</strong> a la variable privada del proceso principal <strong>id2</strong>.<br/><br/>
Cuando se realiza una llamada a un proceso se detiene moment&#225;neamente la ejecuci&#243;n del proceso actual y se pasa a ejecutar el c&#243;digo del proceso llamado, hasta que este retorne por uno de los tres casos enumerados (hasta que termine o ejecute una sentencia <a href="#1029">FRAME</a> o <a href="#1028">RETURN</a>).<br/><br/>
Si el proceso ha terminado con una sentencia <a href="#1029">FRAME</a> se visualizar&#225; en la siguiente imagen seg&#250;n los valores establecidos en sus variables locales (<a href="#1023">x</a>, <a href="#1024">y</a>, <a href="#1026">graph</a>, ...) y, en la preparaci&#243;n de la siguiente imagen, dicho proceso continuar&#225; ejecut&#225;ndose a partir de la sentencia <a href="#1029">FRAME</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1018">Par&#225;metros de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1034">Referencia a un dato</h2><br/><br/>
Una referencia a un dato es cualquier expresi&#243;n que haga referencia a una celda o posici&#243;n de la memoria del ordenador, normalmete suele entenderse como uno de los siguientes aspectos:<br/><br/>
- Si el dato es una variable, para referirnos de esta forma al dato simplemente debemos especificar su nombre.<br/><br/>
Ejemplo de una referencia a una variable: <strong>x</strong><br/><br/>
- Si el dato es una tabla se suele hacer referencia a la misma con su nombre seguido de una expresi&#243;n entre corchetes (<a href="#1079">[ ]</a>); dicha expresi&#243;n determinar&#225; la posici&#243;n de la tabla que se pretende acceder. Si se omite el &#237;ndice entre corchetes se acceder&#225; a la primera posici&#243;n de la tabla (la posici&#243;n 0).<br/><br/>
Ejemplo de una referencia a una tabla: <strong>timer[0]</strong><br/><br/>
- Si el dato es una estructura se har&#225; referencia a la misma con su nombre seguido de una expresi&#243;n entre corchetes (<a href="#1079">[ ]</a>) que determinar&#225; el n&#250;mero de registro al que se acceder&#225; y, tras esto, ir&#225; el s&#237;mbolo<a href="#1063"> . (punto)</a> precediendo al nombre concreto del campo de la estructura al que se va a acceder. Si se omite el n&#250;mero de registro entre corchetes se acceder&#225; al primer registro de la estructura (el n&#250;mero 0).<br/><br/>
Ejemplo de una referencia a una estructura: <strong>scroll[0].z</strong><br/><br/>
Estos tres casos se refieren a accesos a datos del propio proceso o globales; cuando se pretenda acceder a un dato ajeno (un dato local de otro proceso), se preceder&#225; por el <a href="#1039">c&#243;digo identificador</a> del proceso ajeno y el s&#237;mbolo<a href="#1063"> . (punto)</a>, operador de acceso a datos locales y estructuras).<br/><br/>
Ejemplo de una referencia a una variable local ajena: <strong>father.x</strong><br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1035">Definici&#243;n de una expresi&#243;n</h2><br/><br/>
Una expresi&#243;n se entiende, b&#225;sicamente, como una f&#243;rmula matem&#225;tica que involucre a uno o m&#225;s <strong>operandos</strong> (<strong>x</strong>, <strong>2</strong>, <strong>id</strong>, ...) por medio de diversos <strong>operadores</strong> (<strong>*</strong>, <strong>AND</strong>, <strong>&gt;&gt;</strong>, ...); algunos ejemplos de expresiones ser&#237;an: <strong>2</strong>, <strong>2+3</strong> o <strong>(x*4)/-3</strong>.<br/><br/>
Como valores se pueden utilizar &#250;nicamente n&#250;meros enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>) y el resultado de la expresi&#243;n siempre quedar&#225; truncado dentro de este rango.<br/><br/>
Estas expresiones ser&#225;n evaluadas cuando se ejecute la sentencia que las contiene dentro del programa.<br/><br/>
Los <strong>operandos</strong> que se pueden utilizar en una expesi&#243;n son:<br/><br/>
- <a href="#1004">Constantes</a>.<br/>
- <strong>Valores num&#233;ricos</strong>.<br/>
- <strong>Literales</strong> (textos entre comillas).<br/>
- Variables, tablas o estructuras de cualquier tipo.<br/>
- Cualquier tipo de funci&#243;n o proceso.<br/>
- <a href="#1039">C&#243;digo identificador</a> del proceso.<br/>
- Tipo de proceso (<a href="#1042">type &lt;nombre&gt;</a>).<br/>
<br/><br/>
Los <strong>operadores</strong> que se pueden utilizar en una expresi&#243;n son (entre par&#233;ntesis se muestran los sin&#243;nimos del operador, en caso de tenerlos):<br/><br/>
<a href="#1056"> +</a>    Suma<br/>
<a href="#1060"> -</a>    Resta (o negaci&#243;n de signo)<br/>
<a href="#1054"> *</a>    Multiplicaci&#243;n<br/>
<a href="#1065"> /</a>    Divisi&#243;n<br/>
<a href="#1048"> MOD</a>  M&#243;dulo (<a href="#1048">%</a>)<br/>
<a href="#1070"> &lt;&lt;</a>   Rotaci&#243;n a la derecha<br/>
<a href="#1077"> &gt;&gt;</a>   Rotaci&#243;n a la izquierda<br/>
<a href="#1045"> NOT</a>  Negaci&#243;n binaria y l&#243;gica (<a href="#1045">!</a>)<br/>
<a href="#1051"> AND</a>  AND binario y l&#243;gico (<a href="#1050">&amp;</a>, <a href="#1051">&amp;&amp;</a>)<br/>
<a href="#1083"> OR</a>   OR binario y l&#243;gico (<a href="#1083">|</a>, <a href="#1083">||</a>)<br/>
<a href="#1082"> XOR</a>  OR exclusivo (<a href="#1082">^^</a>)<br/>
<a href="#1074"> ==</a>   Comparaci&#243;n<br/>
<a href="#1046"> &lt;&gt;</a>   Distinto (<a href="#1046">!=</a>)<br/>
<a href="#1076"> &gt;</a>    Mayor<br/>
<a href="#1075"> &gt;=</a>   Mayor o igual (<a href="#1075">=&gt;</a>)<br/>
<a href="#1069"> &lt;</a>    Menor<br/>
<a href="#1072"> &lt;=</a>   Menor o igual (<a href="#1072">=&lt;</a>)<br/>
<a href="#1085"> OFFSET</a> Direcci&#243;n o desplazamiento (<a href="#1050">&amp;</a>)<br/>
<a href="#1057"> ++</a>   Operador de incremento<br/>
<a href="#1061"> --</a>   Operador de decremento<br/>
<a href="#1079"> ^</a>    Operador de indirecci&#243;n (<a href="#1054">*</a>, <a href="#1079">[ ]</a>)<br/>
<a href="#1053"> ( )</a>  Par&#233;ntesis<br/>
<br/><br/>
Pulse sobre &quot;<a href="#1036">Evaluaci&#243;n de una expresi&#243;n</a>&quot; para ver el orden en el que son realizados los c&#225;lculos dentro de una expresi&#243;n y cu&#225;ndo deben usarse los par&#233;ntesis.<br/><br/>
A continuaci&#243;n se muestran algunos ejemplos de expresiones v&#225;lidas:<br/><br/>
<strong>    -33</strong><br/>
<strong>    44-2*22</strong><br/>
<strong>    id</strong><br/>
<strong>    x+1</strong><br/>
<strong>    (angle*3)/2-pi/2</strong><br/>
<strong>    (x+y)/2</strong><br/>
<strong>    abs(x-y)*3-pow(x, 2)</strong><br/>
...<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1036">Evaluaci&#243;n de una expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1036">Evaluaci&#243;n de una expresi&#243;n</h2><br/><br/>
Es importante conocer la forma en la que son evaluadas las expresiones para saber d&#243;nde pueden ser necesarios o no par&#233;ntesis que indiquen el modo en el que se pretende que la expresi&#243;n sea evaluada.<br/><br/>
En el lenguaje, una expresi&#243;n puede contener operadores de diferentes niveles de prioridad.<br/><br/>
En la evaluaci&#243;n de una expresi&#243;n ser&#225;n siempre procesados primero los de <strong>prioridad 1</strong> (si los hay), luego los de <strong>prioridad 2</strong>, tras estos los de <strong>prioridad 3</strong> y, as&#237;, sucesivamente.<br/><br/>
Prioridad 1<br/>
<a href="#1053"> ( )</a>  Par&#233;ntesis, inicio y fin de una sub-expresi&#243;n<br/>
<br/><br/>
Prioridad 2<br/>
<a href="#1063"> .</a>    Punto, operador de acceso a datos locales y estructuras<br/>
<br/><br/>
Prioridad 3<br/>
<a href="#1045"> NOT</a>  Negaci&#243;n binaria y l&#243;gica (#1045,<strong>!</strong>)<br/>
<a href="#1085"> OFFSET</a> Direcci&#243;n o desplazamiento (#1050,<strong>&amp;</strong>)<br/>
<a href="#1079"> ^</a>    Operador de indirecci&#243;n (<a href="#1054">*</a>, <a href="#1079">[ ]</a>)<br/>
<strong> -</strong>  Negaci&#243;n de signo<br/>
<a href="#1057"> ++</a>   Operador de incremento<br/>
<a href="#1061"> --</a>   Operador de decremento<br/>
<br/><br/>
Prioridad 4<br/>
<a href="#1054"> *</a>    Multiplicaci&#243;n<br/>
<a href="#1065"> /</a>    Divisi&#243;n<br/>
<a href="#1048"> MOD</a>  M&#243;dulo (<a href="#1048">%</a>)<br/>
<br/><br/>
Prioridad 5<br/>
<a href="#1056"> +</a>    Suma<br/>
<a href="#1060"> -</a>    Resta<br/>
<br/><br/>
Prioridad 6<br/>
<a href="#1070"> &lt;&lt;</a>   Rotaci&#243;n a la derecha<br/>
<a href="#1077"> &gt;&gt;</a>   Rotaci&#243;n a la izquierda<br/>
<br/><br/>
Prioridad 7<br/>
<a href="#1051"> AND</a>  AND binario y l&#243;gico (<a href="#1050">&amp;</a>, <a href="#1051">&amp;&amp;</a>)<br/>
<a href="#1083"> OR</a>   OR binario y l&#243;gico (<a href="#1083">|</a>, <a href="#1083">||</a>)<br/>
<a href="#1082"> XOR</a>  OR exclusivo (<a href="#1082">^^</a>)<br/>
<br/><br/>
Prioridad 8<br/>
<a href="#1074"> ==</a>   Comparaci&#243;n<br/>
<a href="#1046"> &lt;&gt;</a>   Distinto (<a href="#1046">!=</a><br/>
<a href="#1076"> &gt;</a>    Mayor<br/>
<a href="#1075"> &gt;=</a>   Mayor o igual (<a href="#1075">=&gt;</a><br/>
<a href="#1069"> &lt;</a>    Menor<br/>
<a href="#1072"> &lt;=</a>   Menor o igual (<a href="#1072">=&lt;</a><br/>
<br/><br/>
Prioridad 9<br/>
<a href="#1073"> =</a>    Asignaci&#243;n<br/>
<a href="#1058"> +=</a>   Suma-asignaci&#243;n<br/>
<a href="#1062"> -=</a>   Resta-asignaci&#243;n<br/>
<a href="#1055"> *=</a>   Multiplicaci&#243;n-asignaci&#243;n<br/>
<a href="#1066"> /=</a>   Divisi&#243;n-asignaci&#243;n<br/>
<a href="#1049"> %=</a>   M&#243;dulo-asignaci&#243;n<br/>
<a href="#1052"> &amp;=</a>   AND-asignaci&#243;n<br/>
<a href="#1084"> |=</a>   OR-asignaci&#243;n<br/>
<a href="#1081"> ^=</a>   XOR-asignaci&#243;n<br/>
<a href="#1078"> &gt;&gt;=</a>  Rotaci&#243;n a la derecha-asignaci&#243;n<br/>
<a href="#1071"> &lt;&lt;=</a>  Rotaci&#243;n a la izquierda-asignaci&#243;n<br/>
<br/><br/>
Los operadores de <strong>prioridad 3</strong> son los operadores conocidos como <strong>unarios</strong>; &#233;stos no relacionan a dos operandos (que es el caso de los operadores <strong>binarios</strong> como, por ejemplo, una multiplicaci&#243;n), sino que &#250;nicamente afectan al valor de un operador. Dentro de los operadores <strong>unarios</strong> se ejecutar&#225;n primero los m&#225;s cercanos al operando, por ejemplo en la expresi&#243;n:<br/><br/>
<strong>NOT -x</strong><br/><br/>
El operando <strong>x</strong> tiene dos operadores <strong>unarios</strong>, la negaci&#243;n de signo<strong> -</strong> y el <a href="#1045">NOT</a> l&#243;gico y/o binario; de &#233;stos se ejecutar&#225; primero la negaci&#243;n de signo, pues es la que est&#225; m&#225;s cerca del operando.<br/><br/>
Todos los operadores a partir de la <strong>prioridad 4</strong> son <strong>binarios</strong> y se ejecutar&#225;n seg&#250;n su nivel de prioridad por lo que, cuando en una expresi&#243;n haya m&#225;s de un operador del mismo nivel (por ejemplo, una multiplicaci&#243;n y una divisi&#243;n, que son ambas de prioridad 4), se procesar&#225;n de izquierda a derecha, es decir, en la siguiente expresi&#243;n:<br/><br/>
<strong>8/2*2</strong><br/><br/>
Se ejecutar&#225; primero la divisi&#243;n y despu&#233;s la multiplicaci&#243;n (que es la forma natural de evaluar las expresiones en matem&#225;ticas).<br/><br/>
La &#250;nica excepci&#243;n son los operadores de <strong>prioridad 9</strong> (operadores de <strong>asignaci&#243;n</strong>), que ser&#225;n evaluados de derecha a izquierda (en lugar de izquierda a derecha), es decir, en la expresi&#243;n:<br/><br/>
<strong>x=y=0</strong><br/><br/>
Primero, se procesar&#225; <strong>y=0</strong> (se pondr&#225; <strong>y</strong> a <strong>0</strong>) y, despu&#233;s, <strong>x=y</strong> (tambi&#233;n se pondr&#225; <strong>x</strong> a <strong>0</strong>, ya que <strong>y</strong> ahora valdr&#225; <strong>0</strong>).<br/><br/>
Como se puede observar las asignaciones funcionan a modo de operador devolviendo, tras realizar la asignaci&#243;n, el valor que han asignado como resultado de la operaci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Definici&#243;n de una expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1037">Definici&#243;n de una condici&#243;n</h2><br/><br/>
Las condiciones son expresiones que normalmente son como las siguientes:<br/><br/>
<strong>x&lt;320</strong><br/>
<strong>size==100 AND graph&gt;10</strong><br/>
<strong>y==0 OR (x&gt;=100 AND x&lt;=200)</strong><br/>
...<br/><br/>
En general, cualquier expresi&#243;n es v&#225;lida como condici&#243;n. En el lenguaje se interpretan todas las expresiones <strong>IMPARES</strong> como <strong>ciertas</strong> y todas las <strong>PARES</strong> como <strong>falsas</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    IF (20*2+1)
        x=x+1;
    END
END
</pre>
En este ejemplo la sentencia <strong>x=x+1;</strong> se ejecutar&#225; siempre, pues la expresi&#243;n <strong>20*2+1</strong> vale <strong>41</strong>, que es un n&#250;mero <strong>impar</strong>. Todos los operadores disponibles son v&#225;lidos dentro de una condici&#243;n.<br/><br/>
Todos los <a href="#1039">c&#243;digos identificadores</a> de procesos son n&#250;meros <strong>impares</strong>, es decir, todos son <strong>ciertos</strong>. Es posible, por tanto, implementar condiciones como la siguiente (suponiendo que <strong>id2</strong> se haya declarado como variable, y <strong>disparo</strong> es un tipo de proceso del programa).<br/><br/>
<strong>id2=get_id(type disparo);</strong><br/>
<strong>WHILE (id2)</strong><br/>
<strong>id2.size=id2.size-1;</strong><br/>
<strong>id2=get_id(type disparo);</strong><br/>
<strong>END</strong><br/><br/>
En la condici&#243;n <strong>(id2)</strong> se comprueba si la funci&#243;n <strong>get_id()</strong> ha devuelto un <a href="#1039">c&#243;digo identificador</a>, pues &#233;ste ser&#225; siempre un n&#250;mero <strong>impar</strong> y la condici&#243;n ser&#225; evaluada como <strong>cierta</strong> (si <strong>get_id()</strong> no encuentra (m&#225;s) identificadores de procesos &quot;tipo <strong>disparo</strong>&quot;, entonces devolver&#225; <strong>0</strong> (que es un n&#250;mero <strong>par</strong>) interpret&#225;ndose la condici&#243;n como <strong>falsa</strong>, y terminando la sentencia <a href="#1022">WHILE</a>.<br/><br/>
Las sentencias anteriores decrementar&#237;an la variable <a href="#1128">size</a> (tama&#241;o) de todos los procesos de tipo <strong>disparo</strong> que hubiera en el programa.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Definici&#243;n de una expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1038">Formas de obtener el c&#243;digo identificador de un proceso</h2><br/><br/>
Todos los procesos tienen su propio <a href="#1039">c&#243;digo identificador</a> en <a href="#1092">ID</a> (palabra reservada en el lenguaje que equivale al <a href="#1039">c&#243;digo identificador</a> del proceso).<br/><br/>
Cuando se crea un proceso (se llama), &#233;ste devuelve como valor de retorno su propio <a href="#1039">c&#243;digo identificador</a>, a no ser que haya terminado con un <a href="#1028">RETURN</a><a href="#1053">(</a>&lt;expresi&#243;n&gt;<a href="#1053">)</a>. Es decir, un proceso devolver&#225; su <a href="#1039">c&#243;digo identificador</a> siempre que termine (llegue su <a href="#1091">END</a>), ejecute la sentencia <a href="#1029">FRAME</a> o la sentencia <a href="#1028">RETURN</a> sin expresi&#243;n entre par&#233;ntesis.<br/><br/>
En el siguiente ejemplo, desde el programa principal se crea un proceso (de tipo <strong>mi_proceso</strong>) y se guarda su identificador en la variable <strong>id2</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
PRIVATE id2;
BEGIN
    id2=mi_proceso();
    // ...
END
PROCESS mi_proceso()
BEGIN
    // ...
END
</pre>
Todos los procesos tienen predefinidas las siguientes variables locales con indentificadores de otros procesos:<br/><br/>
<a href="#1117">father</a> - padre, identificador del proceso que lo cre&#243; (el que hizo la llamada).<br/><br/>
<a href="#1118">son</a> - hijo, identificador del &#250;ltimo proceso creado por &#233;ste (&#250;ltimo proceso al que se ha llamado).<br/><br/>
<a href="#1120">bigbro</a> - Hermano mayor, identificador del &#250;ltimo proceso que cre&#243; el padre antes de crear &#233;ste.<br/><br/>
<a href="#1119">smallbro</a> - Hermano menor, identificador del siguiente proceso que cre&#243; el padre tras crear &#233;ste.<br/><br/>
Estas variables pueden valer <strong>0</strong> si no han sido definidas (por ejemplo <a href="#1118">son</a> valdr&#225; <strong>0</strong> hasta que no se cree un proceso, o si &#233;ste ya ha desaparecido).<br/><br/>
Los c&#243;digos identificadores de los procesos permiten acceder a las variables locales del mismo (&lt;identificador&gt;.&lt;variable&gt;), y como <a href="#1117">father</a>, <a href="#1118">son</a>, etc., son, a su vez, variables locales se pueden realizar combinaciones como <strong>son.bigbro</strong> para acceder al identificador del pen&#250;ltimo proceso creado (ya que <a href="#1118">son</a> es el del &#250;ltimo, por lo que su hermano mayor ser&#225; el pen&#250;ltimo).<br/><br/>
Hay otras formas de obtener c&#243;digos identificadores de procesos (adem&#225;s de cuando se crean y por parentesco directo), como son:<br/><br/>
- La funci&#243;n <a href="#120">get_id()</a> para obtener los identificadores de los procesos de un tipo determinado (nave, disparo, etc.) que existen en un determinado momento del juego.<br/><br/>
- La funci&#243;n <a href="#104">collision()</a> para obtener los identificadores de los procesos con los se est&#225; chocando (colisionando).<br/><br/>
Cuando un proceso determinado necesita acceder desde muchos otros, por ser un proceso importante como, por ejemplo, la nave protagonista de un juego, entonces puede ser m&#225;s &#250;til asignar su identificador a una variable <a href="#1006">GLOBAL</a> del programa (que puede ser accedida por cualquier proceso en cualquier punto). De esta forma cualquier proceso podr&#225; interactuar con &#233;l, ya que tendr&#225; su identificador.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
GLOBAL
  id_nave;
BEGIN
    id_nave=nave();
    // ...
END
PROCESS nave()
BEGIN
    // ...
END
PROCESS enemigo()
BEGIN
    // ...
    id_nave.z=0;
    // ...
END
</pre>
En este ejemplo los procesos de tipo <strong>enemigo</strong> acceden en un determinado punto a la variable <strong>z</strong> de la <strong>nave</strong> que cre&#243; el programa principal, utilizando para ello su identificador que est&#225; en la variable global <strong>id_nave</strong>.<br/><br/>
<hr/>
Ver: <a href="#1039">C&#243;digos identificadores de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1039">C&#243;digos identificadores de procesos</h2><br/><br/>
Un proceso es un objeto independiente del programa que ejecuta su propio c&#243;digo y que puede tener sus propias coordenadas, gr&#225;ficos, etc., por ejemplo pueden ser procesos de un programa: una nave, un disparo o un enemigo.<br/><br/>
Cuando se pone dentro de un programa algo similar a esto:<br/><br/>
<strong>PROCESS disparo(</strong>...<strong>);</strong><br/>
<a href="#1086">BEGIN</a><br/>
<strong> // </strong>sentencias<strong> ...</strong><br/>
<a href="#1091">END</a><br/><br/>
Se est&#225;n especificando las sentencias que van a ejecutar los procesos &quot;de tipo <strong>disparo</strong>&quot;, es decir, el c&#243;digo que va a regir su comportamiento.<br/><br/>
Como se puede observar puede haber en un programa m&#225;s de un proceso tipo <strong>disparo</strong>, luego &#191;c&#243;mo se diferencian unos de otros? Sencillamente, por su c&#243;digo identificador.<br/><br/>
Cada vez que en un juego se crea un nuevo proceso, a &#233;ste le es asignado un c&#243;digo identificador; este c&#243;digo va a ser la referencia exclusiva del proceso hasta el momento en el que desaparezca.<br/><br/>
Dos procesos diferentes no tendr&#225;n nunca el mismo c&#243;digo identificador a la vez; sin embargo, el c&#243;digo que perteneci&#243; a un proceso que ya ha desaparecido le puede ser asignado a un nuevo proceso (algo as&#237; como el n&#250;mero del carnet de identidad).<br/><br/>
Los c&#243;digo identificadores son siempre n&#250;meros enteros positivos e impares, como podr&#237;an ser 471, 1937 o 10823.<br/><br/>
Todos los procesos tienen su propio c&#243;digo identificador en <a href="#1092">ID</a>, que es algo similar a una variable local del proceso, salvo que no puede modificarse.<br/><br/>
Los procesos, adem&#225;s, tienen el c&#243;digo identificador del proceso que les cre&#243; (el que los llam&#243;) en <a href="#1117">father</a> (padre), el del &#250;ltimo proceso que ellos crearon (el &#250;ltimo que llamaron) en <a href="#1118">son</a> (hijo), etc. (ver <a href="#1041">Jerarqu&#237;as de procesos</a>).<br/><br/>
<strong>&#191;Para qu&#233; sirven los c&#243;digos identificadores?</strong><hr/>
<br/><br/>
Normalmente, todos los procesos necesitan el c&#243;digo identificador de los dem&#225;s procesos para interactuar con ellos (ver donde est&#225;n, modificarlos, ...).<br/><br/>
No se puede, por ejemplo, restarle energ&#237;a al proceso &quot;tipo <strong>enemigo</strong>&quot;, pues procesos de ese tipo pueden no existir ninguno o existir muchos; se necesita el c&#243;digo identificador concreto del proceso <strong>enemigo</strong> al que se quiere restarle energ&#237;a.<br/><br/>
Un proceso accede a todas sus propias variables simplemente por sus nombres, como <a href="#1123">x</a>, <a href="#1128">size</a> o <a href="#1126">graph</a>. Pues bien, si se dispone del identificador de un proceso (en <a href="#1118">son</a>, <a href="#1117">father</a> o cualquier variable definida por el usuario, como <strong>id2</strong>) se puede, entonces, acceder a las variables de dicho proceso como (<strong>son.x</strong>, <strong>father.size</strong> o <strong>id2.graph</strong>), es decir, la sintaxis para acceder a variables locales de otro proceso es:<br/><br/>
&lt;c&#243;digo_identificador&gt; . &lt;nombre_variable&gt;<br/><br/>
Pudi&#233;ndose utilizar dichas variables normalmente para consultarlas o modificarlas.<br/><br/>
<strong>No es posible en ning&#250;n caso acceder a variables de tipo <a href="#1008">PRIVATE</a> de otro proceso</strong>. Si se quiere acceder a una variable privada de otro proceso, se debe cambiar la declaraci&#243;n de &#233;sta a la secci&#243;n <a href="#1007">LOCAL</a> para convertirla en una variable local; entonces, cualquier proceso podr&#225; acceder a dicha variable teniendo el c&#243;digo identificador del proceso, ya que todos los procesos poseer&#225;n dicha variable.<br/><br/>
Los identificadores tienen m&#225;s usos que el acceso a variables locales ajenas, como puede ser la funci&#243;n <a href="#158">signal()</a> que puede enviar determinadas se&#241;ales a un proceso si se dispone de su c&#243;digo identificador (por ejemplo, para eliminar el proceso).<br/><br/>
Tambi&#233;n hay otras funciones, como <a href="#104">collision()</a>, para detectar colisiones (choques) con otros procesos que, en caso de detectar una colisi&#243;n, devuelve el c&#243;digo identificador del proceso con el cual se est&#225; chocando. Una vez se tiene dicho c&#243;digo, se puede acceder a las variables del proceso y enviarle se&#241;ales.<br/><br/>
La funci&#243;n <a href="#120">get_id()</a> funciona de forma similar a <a href="#104">collision()</a>, obteniendo el c&#243;digo identificador de un proceso, pero sin necesidad de que se produzca una colisi&#243;n con &#233;l.<br/><br/>
<hr/>
Ver: <a href="#1038">Formas de obtener el c&#243;digo identificador de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1040">Estados de un proceso</h2><br/><br/>
Los procesos son los diferentes elementos de un programa (objetos del juego); &#233;stos pueden pasar por diferentes estados al crearse, destruirse o recibir determinadas se&#241;ales por medio de la funci&#243;n <a href="#158">signal()</a>.<br/><br/>
proceso <strong>vivo o despierto</strong><br/><br/>
Si un proceso se est&#225; ejecutando (est&#225; interpretando las sentencias comprendidas entre su <a href="#1086">BEGIN</a> y su <a href="#1091">END</a>) se dice que est&#225; vivo.<br/><br/>
proceso <strong>muerto</strong><br/><br/>
Cuando un proceso finaliza (porque llega su <a href="#1091">END</a> en la ejecuci&#243;n, porque ejecute un <a href="#1028">RETURN</a> o porque reciba una se&#241;al <a href="#1153">s_kill</a> o <a href="#1157">s_kill_tree</a>) se dice que ha muerto.<br/><br/>
proceso <strong>dormido</strong><br/><br/>
Un proceso puede recibir la se&#241;al <a href="#1155">s_sleep</a> (o <a href="#1159">s_sleep_tree</a>) y, entonces, pasar&#225; a estado dormido; en este estado el proceso se comporta como si estuviera muerto, s&#243;lo que no lo est&#225; pues, en cualquier momento, puede recibir una se&#241;al <a href="#1154">s_wakeup</a> y volver a estado vivo o despierto. Tambi&#233;n se puede matar a un proceso que est&#225; dormido.<br/><br/>
proceso <strong>congelado</strong><br/><br/>
La se&#241;al <a href="#1156">s_freeze</a> (o <a href="#1160">s_freeze_tree</a>) pasa a estado congelado un proceso. En este estado el proceso se queda inmovilizado, se sigue viendo y el resto de los procesos lo pueden seguir detectando (en las colisiones, por ejemplo), pero no se ejecuta (deja de interpretar sus sentencias de c&#243;digo). Estar&#225; en este estado hasta que reciba otra se&#241;al que le cambie de estado o lo mate.<br/><br/>
Un proceso congelado puede ser controlado (movido) por otro proceso, manipulando directamente sus variables.<br/><br/>
<hr/>
<br/><br/>
Siempre que se env&#237;a una se&#241;al a un proceso con el fin de cambiarle de estado, &#233;sta no tendr&#225; efecto si el proceso se est&#225; ejecutando hasta que llegue a su pr&#243;xima visualizaci&#243;n (<a href="#1029">FRAME</a>). Si el proceso no se estuviera ejecutando, entonces la se&#241;al tendr&#237;a efecto de inmediato.<br/><br/>
No se deben enviar se&#241;ales a procesos inexistentes (a un <a href="#1039">c&#243;digo identificador</a> que no se corresponda a ning&#250;n proceso).<br/><br/>
Si se intenta poner a un proceso en el estado en el que ya est&#225;, la se&#241;al ser&#225; ignorada.<br/><br/>
<hr/>
Ver: <a href="#1041">Jerarqu&#237;as de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1041">Jerarqu&#237;as de procesos</h2><br/><br/>
Un proceso es un objeto independiente del programa que ejecuta su propio c&#243;digo y que puede tener sus propias coordenadas, gr&#225;ficos, etc., por ejemplo, pueden ser procesos de un programa: una nave, un disparo o un enemigo.<br/><br/>
Cuando un programa comienza a ejecutarse s&#243;lo existe un proceso; el proceso inicial que es el que comienza a ejecutar las sentencias del c&#243;digo principal, pero, a partir de entonces, &#233;ste puede crear nuevos procesos y &#233;stos, a su vez, otros, destruirse procesos, etc.<br/><br/>
Para aclarar los acontecimientos que van sucediendo en un programa se establece un s&#237;mil, que es hablar de los procesos como si fueran seres vivos que nacen y mueren (cuando se crean y destruyen). Por ello, se establecen los siguientes t&#233;rminos:<br/><br/>
<strong>Padre</strong>, denominaci&#243;n que se da al proceso que ha creado a otro (la verdad es que se deber&#237;a haber llamado madre).<br/><br/>
<strong>Hijo</strong>, el proceso que ha sido creado por otro.<br/><br/>
<strong>Hermanos</strong>, procesos que han sido creados por el mismo padre.<br/><br/>
<strong>Hu&#233;rfano</strong>, proceso cuyo padre ha muerto (ha sido eliminado o a finalizado).<br/><br/>
Y esta jerga se puede extender hasta donde llegue la imaginaci&#243;n, <strong>abuelos</strong>, <strong>nietos</strong>, <strong>t&#237;os</strong>, etc.<br/><br/>
Todos los procesos tienen acceso a los c&#243;digos identificadores de los procesos con los que tienen parentesco directo (ver: <a href="#1038">Formas de obtener el <strong>#1039,c&#243;digo identificador</a> de un proceso</strong>.<br/><br/>
En ocasiones, se hace referencia a acciones hechas por &quot;<strong>el sistema</strong>&quot;; este proceso, denominado <strong>div_main</strong>, es el que controla al resto, por tanto es el encargado de crear el proceso inicial al comienzo de la ejecuci&#243;n, de ajustar la velocidad de ejecuci&#243;n, el trazador, etc. Todos los procesos que se quedan hu&#233;rfanos pasan a ser hijos de este proceso.<br/><br/>
El <strong>identificador de div_main</strong> se puede obtener con <a href="#120">get_id(0)</a>. Puede servir para enviar una se&#241;al en &#225;rbol (tree) a todos los procesos, pero dicho proceso no se visualizar&#225; en pantalla aunque se definan sus variables <a href="#1123">x</a>, <a href="#1124">y</a>, <a href="#1126">graph</a>, etc.<br/><br/>
<hr/>
Ver: <a href="#1040">Estados de un proceso</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1042">Tipos de procesos</h2><br/><br/>
Los bloques de los programas que comienzan con la palabra reservada <a href="#1016">PROCESS</a> determinan el comportamiento de un tipo concreto de proceso. Despu&#233;s, cuando se ejecute el programa podr&#225; haber cualquier n&#250;mero de procesos de dicho tipo en un momento determinado, cada uno con un <a href="#1039">c&#243;digo identificador</a> diferente pero todos del mismo tipo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    // ...
END
PROCESS nave()
BEGIN
    // ...
END
PROCESS enemigo()
BEGIN
    // ...
END
PROCESS disparo()
BEGIN
    // ...
END
</pre>
En este ejemplo se definen cuatro tipos de procesos, <strong>mi_juego</strong> (que ser&#225; el tipo del proceso inicial del programa}, <strong>nave</strong>, <strong>enemigo</strong> y <strong>disparo</strong>.<br/><br/>
El n&#250;mero de procesos de cada uno de estos tipos que haya despu&#233;s en el juego depende del n&#250;mero de llamadas que se realicen a dichos procesos.<br/><br/>
Todos los procesos de tipo <strong>nave</strong> ejecutar&#225;n siempre las sentencias que se definen en el bloque <strong>PROCESS nave()</strong> del programa.<br/><br/>
Un &quot;tipo de proceso&quot; es un c&#243;digo num&#233;rico que hace referencia al nombre que tiene el PROCESS que determina el comportamiento del proceso durante el juego; este c&#243;digo num&#233;rico se puede obtener con: <strong>TYPE &lt;nombre_del_proceso&gt;</strong><br/><br/>
<strong>TYPE</strong> es un operador definido en el lenguaje que, aplicado a un nombre de proceso, devuelve este c&#243;digo num&#233;rico.<br/><br/>
Por ejemplo, <strong>TYPE nave</strong> equivaldr&#225; a una constante num&#233;rica determinada y <strong>TYPE enemigo</strong> a otra.<br/><br/>
Todos los procesos tienen una variable local que contiene este c&#243;digo num&#233;rico y es: <strong>reserved.process_type</strong>.<br/><br/>
<strong>&#191;Para qu&#233; sirve el tipo de un proceso?</strong><hr/>
<br/><br/>
El tipo de los procesos se emplea para varias cosas, por ejemplo:<br/><br/>
- Para la funci&#243;n <a href="#120">get_id()</a> que recibe como par&#225;metro un tipo de proceso (por ejemplo, <strong>get_id(TYPE enemigo)</strong>) y devuelve los c&#243;digos identificadores de los procesos de dicho tipo que existan en el juego en ese momento.<br/><br/>
- Para la funci&#243;n <a href="#104">collision()</a> es similar a la anterior s&#243;lo que devuelve los c&#243;digos identificadores de los procesos con los que se est&#233; colisionado (chocando, es decir, que los gr&#225;ficos de ambos procesos est&#233;n parcialmente superpuestos).<br/><br/>
- Para la funci&#243;n <a href="#158">signal()</a> que puede enviar una se&#241;al a todos los procesos que existan de un tipo determinado.<br/><br/>
- O bien para, a partir de un <a href="#1039">c&#243;digo identificador</a> de un proceso, poder comprobar de qu&#233; tipo de proceso se trata (si es de tipo nave, de tipo disparo, etc.).<br/><br/>
<hr/>
<br/><br/>
El operador TYPE puede utilizarse &#250;nicamente precediendo a un nombre de proceso del programa o a la palabra <strong>mouse</strong>, para la detecci&#243;n de colisiones con el puntero del rat&#243;n (con <strong>collision(TYPE mouse)</strong>).<br/><br/>
<hr/>
Ver: <a href="#1039">C&#243;digos identificadores de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1043">Sentencia FROM</h2><br/><br/>
<strong>FROM</strong> &lt;variable&gt;<a href="#1073">=</a><a href="#1005">&lt;constante&gt;</a> <a href="#1096">TO</a> <a href="#1005">&lt;constante&gt;</a><a href="#1068">;</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
(o bien)<br/><br/>
<strong>FROM</strong> &lt;variable&gt;<a href="#1073">=</a><a href="#1005">&lt;constante&gt;</a> <a href="#1096">TO</a> <a href="#1005">&lt;constante&gt;</a> <a href="#1095">STEP</a> <a href="#1005">&lt;constante&gt;</a><a href="#1068">;</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <a href="#1068">;</a><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
La sentencia <strong>FROM</strong> es una sentencia que implementa un <strong>bucle</strong>, es decir, que es capaz de <strong>repetir un grupo de sentencias un n&#250;mero determinado de veces</strong>.<br/><br/>
Para implementar este bucle se necesita una variable <a href="#1006">GLOBAL</a>, <a href="#1007">LOCAL</a> o <a href="#1008">PRIVATE</a> del propio proceso que sirva como contador del bucle.<br/><br/>
Antes de las sentencias que conformar&#225;n el grupo interior de sentencias se debe poner la palabra reservada <strong>FROM</strong> seguida del <strong>nombre de la variable contador</strong>, el s&#237;mbolo de asignaci&#243;n (<a href="#1073">=</a>), el <strong>valor inicial</strong> de la variable, la palabra reservada <a href="#1096">TO</a> y, finalmente, el <strong>valor final</strong> de la variable. Tras esta declaraci&#243;n del bucle <strong>FROM</strong> se debe poner el s&#237;mbolo <a href="#1068">;</a> (punto y coma).<br/><br/>
Despu&#233;s de esta cabecera definiendo las condiciones del bucle vendr&#225; el grupo interior de sentencias que se pretende repetir un n&#250;mero determinado de veces y, al final, la palabra reservada <a href="#1091">END</a>.<br/><br/>
Se denomina <strong>iteraci&#243;n</strong> del bucle el n&#250;mero de veces que se ejecuta el grupo interior de sentencias.<br/><br/>
La primera iteraci&#243;n se har&#225; con el <strong>valor incial</strong> en la variable usada como contador, tras esta iteraci&#243;n se le <strong>sumar&#225; 1</strong> a esta variable (si el valor inicial <strong>es menor</strong> que el valor final) o se le <strong>restar&#225; 1</strong> (en caso contrario). Tras actualizar el valor de la variable, se pasar&#225; a la siguiente iteraci&#243;n siempre que el valor de dicha variable no haya llegado (o sobrepasado) el <strong>valor final</strong> del bucle.<br/><br/>
Como segunda acepci&#243;n de la sentencia <strong>FROM</strong> se puede poner tras los valores inicial y final de la sentencia la palabra reservada <a href="#1095">STEP</a> seguida de un <strong>valor constante</strong> que indique el incremento de la variable contador tras cada iteraci&#243;n del bucle, en lugar de <strong>1</strong> o<strong> -1</strong>, que son los incrementos que se har&#225;n por defecto si se omite la declaraci&#243;n <a href="#1095">STEP</a> (paso).<br/><br/>
A continuaci&#243;n, se muestra un programa con dos bucles <strong>FROM</strong>, uno sin declaraci&#243;n <a href="#1095">STEP</a> (con incremento o decremento por defecto) y otro con ella.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FROM x=9 TO 0;
        // sentencias interiores ...
    END
    FROM x=0 TO 9 STEP 2;
        // Sentencias interiores ...
    END
END
</pre>
El primer bucle se ejecutar&#225; <strong>10</strong> veces con la variable <strong>x</strong> valiendo desde <strong>9</strong> hasta <strong>0</strong> en las diferentes iteraciones; por defecto, se le resta uno a la variable cada vez, ya que el valor inicial (9) es mayor que el valor final (0).<br/><br/>
En el segundo, se indica como incremento de la variable la constante <strong>2</strong>, por lo que el bucle se ejecutar&#225; <strong>5</strong> veces con la variable <strong>x</strong> valiendo <strong>0</strong>, <strong>2</strong>, <strong>4</strong>, <strong>6</strong> y <strong>8</strong>, respectivamente, en las sucesivas iteraciones. Como se puede observar no se har&#225; ninguna iteraci&#243;n con <strong>x</strong> valiendo <strong>9</strong>, aunque &#233;ste sea el <strong>valor final</strong> del bucle.<br/><br/>
Por defecto, si no se hubiera especificado como <a href="#1095">STEP</a> (paso) del bucle <strong>2</strong>, se le habr&#237;a sumado <strong>1</strong> a la variable <strong>x</strong> tras cada iteraci&#243;n.<br/><br/>
Un bucle <strong>FROM</strong> siempre se puede realizar tambi&#233;n con la sentencia <a href="#1025">FOR</a>, como se muestra a continuaci&#243;n (con dos bucles equivalentes a los del ejemplo anterior).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM mi_juego;
BEGIN
    FOR ( x=9 ; x&gt;=0 ; x=x-1 )
        // Sentencias interiores ...
    END
    FOR ( x=0 ; x&lt;=9 ; x=x+2 )
        // Sentencias interiores ...
    END
END
</pre>
Los valores <strong>inicial</strong> y <strong>final</strong> de un bucle <strong>FROM</strong> deben ser diferentes.<br/><br/>
Si el valor inicial <strong>es menor</strong> que el valor final, no se puede especificar un valor negativo en la declaraci&#243;n <a href="#1095">STEP</a>.<br/><br/>
Si el valor inicial <strong>es mayor</strong> que el valor final, no se puede especificar un valor positivo en la declaraci&#243;n <a href="#1095">STEP</a>.<br/><br/>
Una sentencia <a href="#1026">BREAK</a> dentro de un bucle <strong>FROM</strong> lo finalizar&#225; de forma inmediata, continuando el programa por la sentencia siguiente a dicho bucle (tras el <a href="#1091">END</a>).<br/><br/>
Una sentencia <a href="#1027">CONTINUE</a> dentro de un bucle <strong>FROM</strong> forzar&#225; al programa a incrementar inmediatamente la variable usada como contador y, despu&#233;s, si no se ha sobrepasado el valor final, comenzar con la siguiente iteraci&#243;n.<br/><br/>
Las sentencias interiores a un bucle <strong>FROM</strong> pueden ser tantas como se quiera y de cualquier tipo, incluyendo, por supuesto, nuevos bucles <strong>FROM</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1044">Uso de &#225;ngulos en el lenguaje</h2><br/><br/>
Todos los &#225;ngulos se especifican en el lenguaje en mil&#233;simas de grado. Por ejemplo:<br/><br/>
<strong>0</strong> es <strong>0 grados</strong> (hacia la derecha)<br/>
<strong>90000</strong> son <strong>90 grados</strong> (hacia arriba)<br/>
<strong> -45000</strong> son<strong> -45 grados</strong> (diagonal abajo derecha)<br/>
<br/><br/>
Si a cualquier &#225;ngulo se le suman o restan <strong>360 grados</strong> (360000) se obtiene un &#225;ngulo equivalente. Por ejemplo, los &#225;ngulos -90000 y 270000 son equivalentes (los &#225;ngulos de<strong> -90 grados</strong> y <strong>270 grados</strong> son ambos hacia abajo)<br/><br/>
Se puede utilizar como referencia la constante <a href="#1179">PI</a> predefinida como <strong>180000</strong>, <strong>3.1415 radianes</strong> o, lo que es lo mismo, <strong>180 grados</strong>. Por ejemplo <strong>PI/2</strong> equivaldr&#225; a 90 grados (90000).<br/><br/>
Algunas de las funciones para el manejo de &#225;ngulos son las siguientes:<br/><br/>
<a href="#116">get_angle()</a><br/>
<a href="#118">get_distx()</a><br/>
<a href="#119">get_disty()</a><br/>
<a href="#113">fget_angle()</a><br/>
<a href="#142">near_angle()</a><br/>
<a href="#101">advance()</a><br/>
<a href="#183">xadvance()</a><br/>
<br/><br/>
Todos los procesos tienen una variable local predefinida denominada <strong>angle</strong> que, por defecto, valdr&#225; <strong>0</strong>; si se modifica su valor se cambiar&#225; el &#225;ngulo de visualizaci&#243;n del gr&#225;fico del proceso (se rotar&#225; el gr&#225;fico en los grados indicados, a partir del gr&#225;fico original).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1045">NOT  !</h2><br/><br/>
Operador unario de <strong>negaci&#243;n</strong> l&#243;gica y binaria utilizado en expresiones y condiciones.<br/><br/>
La palabra reservada <strong>NOT</strong> y el s&#237;mbolo <strong>!</strong> son sin&#243;nimos.<br/><br/>
<strong>NOT l&#243;gico:</strong> Si el operando es <strong>cierto</strong>, al aplicarle este operador, se obtendr&#225; una expresi&#243;n <strong>falsa</strong> y viceversa.<br/><br/>
CIERTO  -&gt;  FALSO<br/>
FALSO   -&gt;  CIERTO<br/>
<br/><br/>
<strong>NOT binario:</strong> Cambia todos los bit del operando, es decir, pasa los 0 a 1 y los 1 a 0.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este operador funciona indistintamente como l&#243;gico y binario debido a que en el lenguaje se interpretan las expresiones l&#243;gicas <strong>ciertas</strong> como las que tienen el &#250;ltimo bit a 1 (el bit 0, de peso 1), es decir, los n&#250;meros impares (1, -1, 3, -3, ...), y como expresiones l&#243;gicas <strong>falsas</strong> las que tienen el &#250;ltimo bit a 0 (los n&#250;meros pares: 0, 2, -2, 4, -4, ...).<br/><br/>
Al cambiar el operador <strong>NOT</strong> todos los bit tambi&#233;n cambian el &#250;ltimo convirtiendo, de este modo, los n&#250;meros pares en impares (expresiones falsas en ciertas) e impares en pares (expresiones ciertas en falsas).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1046">&lt;&gt;  !=</h2><br/><br/>
Operador l&#243;gico [<strong>distinto que</strong>] utilizado en condiciones. Los s&#237;mbolos <strong>&lt;&gt;</strong> y <strong>!=</strong> son sin&#243;nimos.<br/><br/>
Debe utilizarse entre dos expresiones num&#233;ricas y devuelve un resultado l&#243;gico:<br/><br/>
<strong>Falso</strong> - Si ambas expresiones dan el mismo resultado (si son dos expresiones equivalentes), pues NO son distintas.<br/><br/>
<strong>Cierto</strong> - Si las expresiones dan resultados distintos, pues SI son distintas.<br/><br/>
<strong>Ejemplos:</strong><br/><br/>
<strong>2+2 &lt;&gt; 4</strong> devolver&#225; <strong>falso</strong>.<br/>
<strong>0 &lt;&gt; -1</strong>  devolver&#225; <strong>cierto</strong>.<br/>
<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1047">&quot;  &#39;</h2><br/><br/>
S&#237;mbolos delimitadores de literales.<br/><br/>
Los literales son los <strong>textos entre comillas</strong> que pueden comenzar y terminar con el car&#225;cter [<strong>&#39;</strong>] o bien con el car&#225;cter [<strong>&quot;</strong>] (deben comenzar y terminar con el mismo car&#225;cter). Si se quiere incluir el car&#225;cter [<strong>&quot;</strong>] en un literal, se puede hacer de dos formas; sup&#243;ngase que se quiere definir un literal que contenga el texto: a&quot;B&quot;c<br/><br/>
- Duplicar el car&#225;cter: &quot;a&quot;&quot;B&quot;&quot;c&quot;<br/><br/>
- Definirlo con la comilla simple: &#39;a&quot;B&quot;c&#39;<br/><br/>
Lo mismo sucede con el car&#225;cter [<strong>&#39;</strong>], que se puede incluir en un literal si se duplica, o bien si el literal se delimita con el car&#225;cter [<strong>&quot;</strong>].<br/><br/>
Todos los literales deben cerrarse en la misma l&#237;nea en la que comenzaron, no pudi&#233;ndose definir literales de m&#225;s de una l&#237;nea.<br/><br/>
<hr/>
<br/><br/>
<strong>Literales de varias l&#237;neas.</strong><br/><br/>
Es posible definir literales en varias l&#237;neas, para ello s&#237;mplemente deber&#225; dividirse el texto en varios, y ponerse estos seguidos (sin separarse por ning&#250;n s&#237;mbolo). Por ejemplo, se podr&#237;a definir una constante como:<br/><br/>
<strong>saludo=&quot;&#161;Ho&quot;</strong><br/>
<strong>       &quot;la!&quot;;</strong><br/><br/>
Esto podr&#237;a utilizarse tambi&#233;n para inicializar los datos de tipo <a href="#1406">STRING</a>. No hay l&#237;mite en el n&#250;mero de l&#237;neas. Entre dos literales seguidos &#250;nicamente podr&#237;an aparecer <a href="#1002">comentarios explicativos</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1048">MOD  %</h2><br/><br/>
Operador aritm&#233;tico de <strong>m&#243;dulo</strong> o <strong>resto de una divisi&#243;n</strong> entera. La palabra reservada <strong>MOD</strong> y el s&#237;mbolo<strong> %</strong> son sin&#243;nimos.<br/><br/>
Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a> entre dos operandos, para obtener el m&#243;dulo del primero partido por el segundo.<br/><br/>
Por ejemplo <strong>7 MOD 3</strong> devolver&#225; 1, ya que al realizar la divisi&#243;n entera de 7 entre 3 se obtiene 2 como cociente y <strong>1</strong> como <strong>resto</strong>.<br/><br/>
Es decir, que <strong>n MOD m</strong> siempre devolver&#225; un n&#250;mero dentro del rango (0..m-1).<br/><br/>
Para comprender de forma sencilla c&#243;mo obtener el resto de una operaci&#243;n <strong>n MOD m</strong> se pueden seguir los siguientes pasos:<br/><br/>
<strong>Paso 1</strong> - Si <strong>n</strong> es menor que <strong>m</strong>, el resultado de la operaci&#243;n <strong>MOD</strong> es <strong>n</strong>.<br/><br/>
<strong>Paso 2</strong> - (Cuando <strong>n</strong> es mayor o igual que <strong>m</strong>) se le resta <strong>m</strong> a <strong>n</strong> y se vuelve al <strong>paso 1</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Uso:</strong> Este operador se utiliza en ocasiones en los programas en los que se requiere que una variable contador var&#237;e entre <strong>0</strong> y <strong>otro n&#250;mero</strong> siempre; si se quiere, por ejemplo, que la variable <strong>x</strong> var&#237;e entre 0 y 319 indefinidamente (x=0, x=1, x=2, ..., x=319, x=0, x=1, ...) se podr&#237;a optar por lo siguiente:<br/><br/>
<strong>x=0;</strong><br/>
<strong>LOOP</strong><br/>
<strong>    x=x+1;</strong><br/>
<strong>    IF (x==320) x=0;</strong><br/>
<strong>    // ...</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Pero muchos programas sustituyen estas sentencias por las siguientes:<br/><br/>
<strong>x=0;</strong><br/>
<strong>LOOP</strong><br/>
<strong>    x=(x+1) MOD 320;</strong><br/>
<strong>    // ...</strong><br/>
<strong>END</strong><br/>
<br/><br/>
que realizan exactamente la misma funci&#243;n, ya que el operador <strong>MOD</strong> truncar&#225; la expresi&#243;n cuando sea mayor o igual que 320 a un valor menor.<br/><br/>
<hr/>
<br/><br/>
El <strong>cociente</strong> de una divisi&#243;n entera se obtiene con el operador <a href="#1065">/</a> (divisi&#243;n).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1049">%=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n de <strong>m&#243;dulo</strong> o <strong>resto de divisi&#243;n</strong> entera.<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo <strong>%=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato el <strong>m&#243;dulo</strong> o <strong>resto de la divisi&#243;n</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] / [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=3; x%=2;</strong> -&gt; (x=1)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>, en cualquier caso una sentencia del tipo <strong>n %= m;</strong> ser&#225; equivalente a &#233;sta otra <strong>n = n MOD m;</strong>.<br/><br/>
Ver el operador <a href="#1048">MOD</a> para m&#225;s informaci&#243;n sobre el <strong>m&#243;dulo</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1050">&amp;</h2><br/><br/>
S&#237;mbolo bifuncional que tiene dos usos diferentes seg&#250;n se utilice como un operador unario o binario.<br/><br/>
Un operador <strong>UNARIO</strong> aparece dentro de una expresi&#243;n precediendo, simplemente, a un operando (como si fuera el signo de &#233;ste); en este caso el operador<strong> &amp;</strong> ser&#225; un sin&#243;nimo de <a href="#1085">OFFSET</a>.<br/><br/>
<strong>Ejemplo: &amp;x</strong> es equivalente a <strong>OFFSET x</strong><br/><br/>
Un operador <strong>BINARIO</strong> aparece dentro de una expresi&#243;n concatenando a dos operandos (indicando una operaci&#243;n entre ambos), en este caso el operador<strong> &amp;</strong> ser&#225; un sin&#243;nimo de <a href="#1051">AND</a>.<br/><br/>
<strong>Ejemplo: x&amp;2</strong> es equivalente a <strong>x AND 2</strong><br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1085">OFFSET</a> - <a href="#1051">AND</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1051">AND  &amp;&amp;</h2><br/><br/>
Operador binario del <strong>producto l&#243;gico</strong> utilizado en expresiones y condiciones.<br/><br/>
La palabra reservada <strong>AND</strong> y el s&#237;mbolo<strong> &amp;&amp;</strong> son sin&#243;nimos.<br/><br/>
<strong>AND l&#243;gico:</strong> Se eval&#250;an, primero, las condiciones de la derecha e izquierda del operador y, si ambas son <strong>ciertas</strong>, este operador devolver&#225; <strong>cierto</strong>, en caso contrario el operador devolver&#225; siempre <strong>falso</strong>.<br/><br/>
FALSO  AND FALSO  = FALSO<br/>
FALSO  AND CIERTO = FALSO<br/>
CIERTO AND FALSO  = FALSO<br/>
CIERTO AND CIERTO = CIERTO<br/>
<br/><br/>
Se utiliza para comprobar que se cumplan obligatoriamente m&#225;s de una condici&#243;n, por ejemplo:<br/><br/>
<strong>(x&gt;0 AND x&lt;100)</strong><br/><br/>
Para comprobar que la variable sea mayor que 0 <strong>Y</strong> que sea menor que 100.<br/><br/>
<strong>AND binario:</strong> Eval&#250;a los bit de los resultados de las expresiones anterior y posterior al operador generando, como resultado, un valor que tendr&#225; a uno &#250;nicamente los bit que tuvieran a uno ambas expresiones.<br/><br/>
0 AND 0 = 0<br/>
0 AND 1 = 0<br/>
1 AND 0 = 0<br/>
1 AND 1 = 1<br/>
<br/><br/>
Esta regla se aplicar&#225; a todos los bits de los operandos (en el lenguaje son enteros de 32 bits).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este operador funciona indistintamente como l&#243;gico y binario debido a que en el lenguaje se interpretan las expresiones l&#243;gicas <strong>ciertas</strong> como las que tienen el &#250;ltimo bit a 1 (el bit 0, de peso 1), es decir, los n&#250;meros impares (1, -1, 3, -3, ... ), y como expresiones l&#243;gicas <strong>falsas</strong> las que tienen el &#250;ltimo bit a 0 (los n&#250;meros pares: 0, 2, -2, 4, -4, ...).<br/><br/>
El operador <strong>AND</strong> &#250;nicamente dejar&#225; a 1 el &#250;ltimo bit (s&#243;lo devolver&#225; <strong>cierto</strong> como resultado} cuando lo tuvieran a 1 ambos operandos (cuando los dos fueran expresiones <strong>ciertas</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El s&#237;mbolo<strong> &amp;</strong> tambi&#233;n puede utlizarse como un sin&#243;nimo m&#225;s de <strong>AND</strong> y<strong> &amp;&amp;</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1052">&amp;=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n binaria de <strong>producto l&#243;gico</strong> (<strong>AND</strong>).<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo <strong>&amp;=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato el <strong>producto l&#243;gico</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] AND [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=5; x&amp;=6;</strong> -&gt; (x=4)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>; en cualquier caso, una sentencia del tipo <strong>n &amp;= m;</strong> ser&#225; equivalente a esta otra <strong>n = n AND m;</strong>.<br/><br/>
Ver el operador <a href="#1051">AND</a> para m&#225;s informaci&#243;n sobre el <strong>producto l&#243;gico</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1053">(  )</h2><br/><br/>
Los s&#237;mbolos <strong>(</strong> y <strong>)</strong>, denominados par&#233;ntesis, deben aparecer siempre emparejados y en este mismo orden.<br/><br/>
Se utilizan para delimitar determinados c&#225;lculos, par&#225;metros o condiciones de los programas, marcando el inicio de los mismos con el s&#237;mbolo <strong>(</strong> y el final con el s&#237;mbolo <strong>)</strong>.<br/><br/>
<hr/>
<br/><br/>
Dentro de una expresi&#243;n indican que el c&#225;lculo de su interior se debe realizar antes que el de su exterior.<br/><br/>
Por ejemplo, la expresi&#243;n <strong>2*3+2</strong> se evaluar&#225; como <strong>8</strong>, ya que primero se realizar&#225; la multiplicaci&#243;n (2 por 3, que es 6) y despu&#233;s la suma (6 m&#225;s 2, que da como resultado 8).<br/><br/>
Utilizando par&#233;ntesis se puede forzar a que se realice la suma en primer lugar, expresando el c&#225;lculo como <strong>2*(3+2)</strong>, que ser&#225; evaluado como <strong>10</strong>, ya que ahora se realizar&#225; primero la suma (3 m&#225;s 2, que es 5) y despu&#233;s la multiplicaci&#243;n (2 por 5, que es 10).<br/><br/>
<hr/>
<br/><br/>
Los par&#233;ntesis tambi&#233;n se utilizan para delimitar los par&#225;metros de llamada de los procesos o las funciones y dentro de la sintaxis de diferentes sentencias del lenguaje.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1054">*</h2><br/><br/>
Operador aritm&#233;tico de <strong>multiplicaci&#243;n</strong> entera. Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a> entre dos operandos, para obtener como resultado su producto (la multiplicaci&#243;n).<br/><br/>
Por ejemplo <strong>2 * 8</strong> devolver&#225; <strong>16</strong>, <strong>99 * 0</strong> devolver&#225; <strong>0</strong>, <strong>2 * -1</strong> devolver&#225;<strong> -2</strong>, etc.<br/><br/>
Todas las variables son <strong>enteros</strong> con signo de 32 bit en el lenguaje. Por lo tanto, &#250;nicamente se pueden manejar n&#250;meros enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>)} por lo que, cuando el resultado de la <strong>multiplicaci&#243;n</strong> deba exceder dicho rango, <strong>se mostrar&#225;n resultados incorrectos</strong>. En este caso, el sistema no advertir&#225; de ning&#250;n error, de ah&#237; que se deban extremar las precauciones.<br/><br/>
<hr/>
<br/><br/>
Este s&#237;mbolo es bifuncional, es decir, tiene dos usos diferentes seg&#250;n se utilice como un operador unario o binario.<br/><br/>
Un operador <strong>UNARIO</strong> aparece dentro de una expresi&#243;n precediendo simplemente a un operando (como si fuera el signo de &#233;ste); en este caso el operador <strong>*</strong> ser&#225; un sin&#243;nimo de <a href="#1079">^</a>.<br/><br/>
<strong>Ejemplo: *x</strong> es equivalente a <strong>^x</strong>.<br/><br/>
Un operador <strong>BINARIO</strong> aparece dentro de una expresi&#243;n concatenando a dos operandos (indicando una operaci&#243;n entre ambos), en cuyo caso el operador <strong>*</strong> ser&#225; el operador aritm&#233;tico de <strong>multiplicaci&#243;n</strong> explicado anteriormente.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1079">^</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1055">*=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n aritm&#233;tica de <strong>multiplicaci&#243;n</strong>.<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo <strong>*=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato la <strong>multiplicaci&#243;n</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] * [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=2; x*=3;</strong> -&gt; (x=6)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>, en cualquier caso una sentencia del tipo <strong>n *= m;</strong> ser&#225; equivalente a esta otra <strong>n = n * m;</strong>.<br/><br/>
Ver el operador <a href="#1054">*</a> para m&#225;s informaci&#243;n sobre la <strong>multiplicaci&#243;n</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1056">+</h2><br/><br/>
Operador aritm&#233;tico de <strong>suma</strong>. Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a> entre dos operandos, para obtener su suma.<br/><br/>
Por ejemplo <strong>2 + 6</strong> devolver&#225; 8, la suma de 2 m&#225;s 6.<br/><br/>
Todas las variables son <strong>enteros</strong> con signo de 32 bits en el lenguaje. Luego, &#250;nicamente se pueden manejar n&#250;meros enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>)}, por lo que cuando el resultado de la <strong>suma</strong> deba exceder dicho rango, <strong>se mostrar&#225;n resultados incorrectos</strong>. En este caso, el sistema no advertir&#225; de ning&#250;n error, de ah&#237; que deban extremarse las precauciones.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1057">++</h2><br/><br/>
Operador de incremento, este operador, derivado del lenguaje C, permite incrementar el valor de un dato (sumarle 1) sin requerir, para ello, una <a href="#1019">sentencia de asignaci&#243;n</a>.<br/><br/>
El dato puede ser una variable, una <strong>posici&#243;n de una tabla</strong>, o bien un <strong>campo de una estructura</strong>.<br/><br/>
Este operador se puede incluir dentro de una expresi&#243;n en dos modalidades: <strong>preincremento</strong> y <strong>postincremento</strong>.<br/><br/>
<strong>Operador de preincremento</strong><br/><br/>
Cuando se ponga el s&#237;mbolo <strong> ++</strong> justo delante de un dato, se le sumar&#225; 1 al mismo <strong>antes de ejecutar la sentencia</strong>, por ejemplo, v&#233;anse las siguientes sentencias:<br/><br/>
<strong> ++x;</strong> - sentencia que sumar&#225; 1 a la variable <strong>x</strong>.<br/><br/>
<strong> z=++x+y;</strong> - sentencia que sumar&#225; 1 a la variable <strong>x</strong> y, despu&#233;s, asignar&#225; a la variable <strong>z</strong> la suma de <strong>x</strong> (ya incrementada) e <strong>y</strong>.<br/><br/>
<strong>Operador de postincremento</strong><br/><br/>
Cuando se ponga el s&#237;mbolo<strong> ++</strong> justo detr&#225;s de un dato, se le sumar&#225; 1 al mismo <strong>tras ejecutar la sentencia</strong>, por ejemplo, v&#233;anse las siguientes sentencias:<br/><br/>
<strong> x++;</strong> - sentencia que sumar&#225; 1 a la variable <strong>x</strong>.<br/><br/>
<strong> z=x+y++;</strong> - sentencia que asignar&#225; la suma de <strong>x</strong> m&#225;s <strong>y</strong> a la variable <strong>z</strong>, y, despu&#233;s, incrementar&#225; la variable <strong>y</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Resumen:</strong><br/><br/>
En general, una sentencia del tipo<strong> ++dato;</strong> o <strong>dato++;</strong> es siempre equivalente a la siguiente sentencia: <strong>dato=dato+1;</strong> (o bien <strong>dato+=1;</strong>).<br/><br/>
La diferencia entre el <strong>preincremento</strong> y el <strong>postincremento</strong> es que en el primero se toma el valor del dato ya incrementado para evaluar el resto de la expresi&#243;n, mientras que en el segundo se eval&#250;a la expresi&#243;n con el valor que ten&#237;a el dato antes de ser incrementado.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1061">Decremento(--)</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1058">+=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n aritm&#233;tica de <strong>suma</strong>.<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> +=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato la <strong>suma</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] + [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=2; x+=2;</strong> -&gt; (x=4)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>, en cualquier caso una sentencia del tipo <strong>n += m;</strong> ser&#225; equivalente a esta otra <strong>n = n + m;</strong>.<br/><br/>
Ver el operador <a href="#1056">+</a> para m&#225;s informaci&#243;n sobre la <strong>suma</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1059">,</h2><br/><br/>
El s&#237;mbolo de la coma ( <strong>,</strong> ) se utiliza dentro del lenguaje de programaci&#243;n, en diferentes puntos de un programa, <strong>para separar</strong> dos elementos consecutivos de una lista.<br/><br/>
Se utiliza, por ejemplo, en los siguientes puntos:<br/><br/>
- En las <a href="#1013">listas de constantes</a> para separar los diferentes valores num&#233;ricos de las mismas.<br/><br/>
- En la definici&#243;n de los <a href="#1018">par&#225;metros de un proceso</a> para separar los nombres de los diferentes par&#225;metros.<br/><br/>
- En la <a href="#1033">llamada a un proceso</a> para separar las diferentes expresiones que ser&#225;n asignadas a los p&#225;rametros.<br/><br/>
- En la <a href="#1025">sentencia FOR</a> para separar diferentes inicializaciones, condiciones o incrementos.<br/><br/>
- En la <a href="#1021">sentencia SWITCH</a> para definir los diferentes valores aceptados en un bloque <strong>CASE ... END</strong>.<br/><br/>
<hr/>
<br/><br/>
El s&#237;mbolo de la coma se puede utilizar tambi&#233;n para separar varias <a href="#1009">declaraciones de datos</a>, en lugar de finalizar cada una de ellas con un s&#237;mbolo <strong>punto y coma</strong> (<a href="#1068">;</a>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1060">-</h2><br/><br/>
Operador aritm&#233;tico de <strong>resta</strong>. Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a> entre dos operandos para obtener su suma.<br/><br/>
Por ejemplo <strong>2 - 6</strong> devolver&#225; -4, el resultado de restarle 6 a 2.<br/><br/>
Todas las variables son <strong>enteros</strong> con signo de 32 bits en el lenguaje. Por ello, &#250;nicamente se pueden manejar n&#250;meros enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>)}, por lo que cuando el resultado de la <strong>resta</strong> deba exceder dicho rango, <strong>se mostrar&#225;n resultados incorrectos</strong>. En este caso, el sistema no advertir&#225; de ning&#250;n error, con lo que se deben extremar las precauciones.<br/><br/>
<hr/>
<br/><br/>
Este s&#237;mbolo es bifuncional, es decir, tiene dos usos diferentes seg&#250;n se utilice como un operador unario o binario.<br/><br/>
Un operador <strong>UNARIO</strong> aparece dentro de una expresi&#243;n precediendo simplemente a un operando, este caso el operador<strong> -</strong> ser&#225; el <strong>signo menos</strong>.<br/><br/>
<strong>Ejemplo: -7</strong> el n&#250;mero entero negativo <strong>menos siete</strong>.<br/><br/>
Un operador <strong>BINARIO</strong> aparece dentro de una expresi&#243;n concatenando a dos operandos (indicando una operaci&#243;n entre ambos); en este caso el operador<strong> -</strong> ser&#225; el operador aritm&#233;tico de <strong>resta</strong> explicado anteriormente.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1061">--</h2><br/><br/>
Operador de decremento, este operador, derivado del lenguaje C, permite decrementar el valor de un dato (restarle 1), sin requerir para ello una <a href="#1019">sentencia de asignaci&#243;n</a>.<br/><br/>
El dato puede ser una variable, una <strong>posici&#243;n de una tabla</strong>, o bien un <strong>campo de una estructura</strong>.<br/><br/>
Este operador se puede incluir dentro de una expresi&#243;n en dos modalidades: <strong>predecremento</strong> y <strong>postdecremento</strong>.<br/><br/>
<strong>Operador de predecremento</strong><br/><br/>
Cuando se ponga el s&#237;mbolo<strong> --</strong> justo delante de un dato, se le restar&#225; 1 al mismo <strong>antes de ejecutar la sentencia</strong>, por ejemplo, v&#233;anse las siguientes sentencias:<br/><br/>
<strong> --x;</strong> - sentencia que restar&#225; 1 a la variable <strong>x</strong>.<br/><br/>
<strong> z=--x+y;</strong> - sentencia que restar&#225; 1 a la variable <strong>x</strong> y despu&#233;s asignar&#225; a la variable <strong>z</strong> la suma de <strong>x</strong> (ya decrementada) e <strong>y</strong>.<br/><br/>
<strong>Operador de postdecremento</strong><br/><br/>
Cuando se ponga el s&#237;mbolo<strong> --</strong> justo detr&#225;s de un dato, se le restar&#225; 1 al mismo <strong>tras ejecutar la sentencia</strong>, por ejemplo, v&#233;anse las siguientes sentencias:<br/><br/>
<strong> x--;</strong> - sentencia que restar&#225; 1 a la variable <strong>x</strong>.<br/><br/>
<strong> z=x+y--;</strong> - sentencia que asignar&#225; la suma de <strong>x</strong> m&#225;s <strong>y</strong> a la variable <strong>z</strong>, y despu&#233;s decrementar&#225; la variable <strong>y</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Resumen:</strong><br/><br/>
En general, una sentencia del tipo<strong> --dato;</strong> o <strong>dato--;</strong> siempre equivalente a la siguiente sentencia: <strong>dato=dato-1;</strong> (o bien <strong>dato-=1;</strong>).<br/><br/>
La diferencia entre el <strong>predecremento</strong> y el <strong>postdecremento</strong> es que en el primero se toma el valor del dato ya decrementado para evaluar el resto de la expresi&#243;n, y en el segundo se eval&#250;a la expresi&#243;n con el valor que ten&#237;a el dato antes de ser decrementado.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1057">Incremento(++)</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1062">-=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n aritm&#233;tica de <strong>resta</strong>.<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> -=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato la <strong>resta</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] - [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=4; x-=2;</strong> -&gt; (x=2)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>; en cualquier caso una sentencia del tipo <strong>n -= m;</strong> ser&#225; equivalente a esta otra <strong>n = n - m;</strong>.<br/><br/>
Ver el operador<a href="#1060"> -</a> para m&#225;s informaci&#243;n sobre la <strong>resta</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1063">.  -&gt;</h2><br/><br/>
Operador de acceso a estructuras o datos locales ajenos. Los s&#237;mbolos<strong> .</strong> y<strong> -&gt;</strong> son sin&#243;nimos, por lo que pueden ser usados indistintamente.<br/><br/>
<hr/>
<br/><br/>
<strong>Acceso a estructuras</strong><br/><br/>
Para acceder a un campo de una estructura se debe utilizar este operador de la siguiente forma:<br/><br/>
&lt;nombre de la estructura&gt;<strong>[</strong>&lt;n&#186; registro&gt;<strong>]</strong><strong> . </strong>&lt;nombre del campo&gt;<br/><br/>
(o bien, utilizando el otro s&#237;mbolo)<br/><br/>
&lt;nombre de la estructura&gt;<strong>[</strong>&lt;n&#186; registro&gt;<strong>]</strong><strong> -&gt; </strong>&lt;nombre del campo&gt;<br/><br/>
<strong>Ejemplos:</strong><br/>
<strong>scroll[0].camera</strong><br/>
<strong>m7[1]-&gt;z</strong><br/>
<br/><br/>
<strong>Nota:</strong> Se recuerda que el n&#250;mero de registro entre corchetes se puede omitir cuando se acceda al registro n&#250;mero 0, por ejemplo <strong>scroll[0].camera</strong> equivaldr&#225; siempre a <strong>scroll.camera</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Acceso a datos locales ajenos (de otro proceso)</strong><br/><br/>
Para acceder a un dato <a href="#1007">LOCAL</a> de un proceso desde otro, se debe tener el <a href="#1039">c&#243;digo identificador</a> del proceso del cual se quiere leer o modificar su dato, entonces se podr&#225; acceder al mismo de la siguiente forma:<br/><br/>
&lt;c&#243;digo identificador&gt;<strong> . </strong>&lt;nombre dato local&gt;<br/><br/>
(o bien, utilizando el otro s&#237;mbolo)<br/><br/>
&lt;c&#243;digo identificador&gt;<strong> -&gt; </strong>&lt;nombre dato local&gt;<br/><br/>
<strong>Ejemplos:</strong><br/>
<strong>father.x</strong><br/>
<strong>son-&gt;graph</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#1012">Declaraci&#243;n de una estructura</a> - <a href="#1039">C&#243;digos identificadores</a> - <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1064">..</h2><br/><br/>
<strong>Rango de valores de una secci&#243;n CASE</strong><hr/>
<br/><br/>
El s&#237;mbolo<strong> ..</strong> (doble punto) se utiliza para definir un rango de valores, es decir, para expresar el conjunto de n&#250;meros comprendidos entre dos valores (incluyendo &#233;stos).<br/><br/>
Este s&#237;mbolo se utiliza <strong>&#250;nicamente en las sentencias</strong> <a href="#1021">SWITCH</a>, dentro de las <strong>secciones CASE</strong>, para especificar un rango de valores.<br/><br/>
Resulta indiferente expresar un rango como <strong>m&#237;nimo..m&#225;ximo</strong> o como <strong>m&#225;ximo..m&#237;nimo</strong>.<br/><br/>
Por ejemplo, el rango definido con<strong> -2 .. 1</strong> ser&#237;an los n&#250;meros<strong> -2</strong>,<strong> -1</strong>, <strong>0</strong> y <strong>1</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1021">sentencia SWITCH</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1065">/</h2><br/><br/>
Operador aritm&#233;tico de <strong>divisi&#243;n</strong> entera. Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a> entre dos operandos, para obtener el cociente del primero partido por el segundo.<br/><br/>
Por ejemplo <strong>7 / 3</strong> devolver&#225; 2, ya que al realizar la divisi&#243;n entera de 7 entre 3 se obtiene <strong>2</strong> como <strong>cociente</strong> (y 1 como resto).<br/><br/>
Es decir, que <strong>n / m</strong> siempre devolver&#225; el resultado de la divisi&#243;n de <strong>n</strong> entre <strong>m</strong>, pero sin decimales (ya que todas las variables son <strong>enteros</strong> con signo de 32 bits en el lenguaje).<br/><br/>
<hr/>
<br/><br/>
El <strong>resto</strong> de una divisi&#243;n entera se obtiene con el operador <a href="#1048">MOD</a> (m&#243;dulo).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1066">/=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n de <strong>divisi&#243;n entera</strong> (cociente).<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> /=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato el <strong>resultado entero</strong> (cociente) de la <strong>divisi&#243;n</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] / [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=8; x/=2;</strong> -&gt; (x=4)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>, en cualquier caso una sentencia del tipo <strong>n /= m;</strong> ser&#225; equivalente a esta otra <strong>n = n / m;</strong>.<br/><br/>
Ver el operador <a href="#1065">/</a> para m&#225;s informaci&#243;n sobre la <strong>divisi&#243;n entera</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1067">:</h2><br/><br/>
El s&#237;mbolo <strong>:</strong> (dos puntos) se utiliza para finalizar una declaraci&#243;n <a href="#1087">CASE</a> o una declaraci&#243;n <a href="#1088">DEFAULT</a> de una <a href="#1021">sentencia SWITCH</a>.<br/><br/>
En realidad, los s&#237;mbolos <strong>:</strong> (dos puntos) y <strong>;</strong> (punto y coma) son sin&#243;nimos en este lenguaje, es decir, que es indiferente utilizar uno u otro.<br/><br/>
A&#250;n as&#237;, por similitud a otros lenguajes de programaci&#243;n se utiliza, normalmente, el s&#237;mbolo <strong>punto y coma</strong> como terminador de sentencias y el s&#237;mbolo <strong>dos puntos</strong> dentro de la sintaxis de la <a href="#1021">sentencia SWITCH</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1087">CASE</a> -  <a href="#1088">DEFAULT</a> - <a href="#1021">sentencia SWITCH</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1068">;</h2><br/><br/>
El s&#237;mbolo <strong>;</strong> (punto y coma) se utiliza en m&#250;ltiples puntos de un programa para indicar, siempre, que finaliza una sentencia o alg&#250;n tipo de declaraci&#243;n. Es lo que se denomina un s&#237;mbolo <strong>terminador</strong> que tiene, como &#250;nico fin marcar el final de algo.<br/><br/>
En el lenguaje se deben indicar con punto y coma los siguientes puntos del programa:<br/><br/>
- El final de la <a href="#1003">declaraci&#243;n PROGRAM</a>.<br/><br/>
- El final de una <a href="#1009">declaraci&#243;n de un dato</a>.<br/><br/>
- El final de una <a href="#1014">declaraci&#243;n IMPORT</a>.<br/><br/>
- El final de las siguientes sentencias:<br/>
<a href="#1019">Asignaciones o incrementos de datos</a>.<br/>
<a href="#1033">Llamadas a procesos</a>.<br/>
<a href="#1032">Llamadas a funciones</a>.<br/>
<a href="#1029">FRAME</a>, <a href="#1028">RETURN</a>, <a href="#1031">DEBUG</a>, <a href="#1026">BREAK</a> y <a href="#1027">CONTINUE</a>.<br/>
<br/><br/>
- El final de un inicio de bucle <a href="#1043">FROM</a>.<br/><br/>
- Y como separador de las diferentes partes de una sentencia <a href="#1025">FOR</a>.<br/><br/>
El compilador indicar&#225; cuando falte el s&#237;mbolo <strong>;</strong> en cualquiera de estos puntos.<br/><br/>
Pudiendo, adem&#225;s, ponerse dicho s&#237;mbolo en otros puntos determinados de los programas, como detr&#225;s de cualquier otro tipo de sentencia, aunque en este caso ser&#225; opcional y, por tanto, el compilador no advertir&#225; de su ausencia.<br/><br/>
<hr/>
<br/><br/>
En realidad los s&#237;mbolos <strong>;</strong> (punto y coma) y <strong>:</strong> (dos puntos) son sin&#243;nimos en este lenguaje, es decir, que es indiferente utilizar uno u otro.<br/><br/>
A&#250;n as&#237;, por similitud a otros lenguajes de programaci&#243;n se utiliza, normalmente, el s&#237;mbolo <strong>punto y coma</strong> como terminador de sentencias y el s&#237;mbolo <strong>dos puntos</strong> dentro de la sintaxis de la <a href="#1021">sentencia SWITCH</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1069">&lt;</h2><br/><br/>
Operador l&#243;gico [<strong>menor que</strong>] utilizado en condiciones. Debe utilizarse entre dos expresiones num&#233;ricas y devuelve un resultado l&#243;gico:<br/><br/>
<strong>Falso</strong> - Si la primera expresi&#243;n NO es menor que la segunda.<br/><br/>
<strong>Cierto</strong> - Si la primera expresi&#243;n SI es menor que la segunda.<br/><br/>
<strong>Ejemplos:</strong><br/><br/>
<strong>2+2 &lt; 4</strong> devolver&#225; <strong>falso</strong>.<br/>
<strong>1 &lt; 2</strong>   devolver&#225; <strong>cierto</strong>.<br/>
<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1070">&lt;&lt;</h2><br/><br/>
Operador binario de <strong>rotaci&#243;n a la izquierda</strong>. Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a>, entre dos operandos, para obtener el resultado de rotar el primer operando a la izquierda el n&#250;mero de veces que indique el segundo. Por ejemplo, la siguiente rotaci&#243;n:<br/><br/>
<strong>n</strong> &lt;&lt; <strong>m</strong><br/><br/>
Devolver&#225; <strong>n</strong> rotado a la izquierda <strong>m</strong> veces; cada rotaci&#243;n a la izquierda equivale a multiplicar por 2 el n&#250;mero. Es decir, rotar a la izquierda 1 vez, equivale a multiplicar por 2, rotar a la izquierda 2 veces a multiplicar por 4, 3 veces a multiplicar por 8, y, as&#237;, sucesivamente.<br/><br/>
O lo que es equivalente (la <a href="#145">funci&#243;n POW</a><strong>(2, m)</strong> devuelve <strong>2</strong> elevado a <strong>m</strong>):<br/><br/>
<strong>n</strong> * POW(2, <strong>m</strong>)<br/><br/>
Por ejemplo, <strong>2&lt;&lt;3</strong> devolver&#225; 16, <strong>4&lt;&lt;1</strong> devolver&#225; 8, <strong>100&lt;&lt;0</strong> devolver&#225; 100, etc.<br/><br/>
Todas las variables son <strong>enteros</strong> con signo de 32 bits en el lenguaje. Por eso s&#243;lo se pueden manejar n&#250;meros enteros dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>)}, por lo que cuando el resultado de la <strong>rotaci&#243;n</strong> deba exceder dicho rango, <strong>se mostrar&#225;n resultados incorrectos</strong>. En este caso, el sistema no advertir&#225; de ning&#250;n error, por lo que se deben extremar las precauciones.<br/><br/>
<hr/>
<br/><br/>
El operador de rotaci&#243;n a la derecha (operaci&#243;n opuesta a &#233;sta) es el <a href="#1077">s&#237;mbolo &gt;&gt;</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1071">&lt;&lt;=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n binaria de <strong>rotaci&#243;n a la izquierda</strong>.<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> &lt;&lt;=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato el resultado de la siguiente rotaci&#243;n:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] &lt;&lt; [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
O lo que es equivalente (la <a href="#145">funci&#243;n POW</a><strong>(2, n)</strong> devuelve <strong>2</strong> elevado a <strong>n</strong>):<br/><br/>
[<strong>valor_anterior_del_dato</strong>] * POW(2, [<strong>resultado_de_la_expresi&#243;n</strong>])<br/><br/>
Es decir, si el resultado de la expresi&#243;n es:<br/><br/>
0 -&gt; el dato mantendr&#225; su valor.<br/>
1 -&gt; el dato ser&#225; multiplicado por 2.<br/>
2 -&gt; el dato ser&#225; multiplicado por 4.<br/>
3 -&gt; el dato ser&#225; multiplicado por 8.<br/>
...<br/><br/>
Ejemplo: <strong>x=2; x&lt;&lt;=2;</strong> -&gt; (x=8)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>, en cualquier caso una sentencia del tipo <strong>n &lt;&lt;= m;</strong> ser&#225; equivalente a esta otra <strong>n = n &lt;&lt; m;</strong>.<br/><br/>
Ver el operador <a href="#1070">&lt;&lt;</a> para m&#225;s informaci&#243;n sobre la <strong>rotaci&#243;n a la izquierda</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1072">&lt;=  =&lt;</h2><br/><br/>
Operador l&#243;gico [<strong>menor o igual que</strong>] utilizado en condiciones. Los s&#237;mbolos <strong>&lt;=</strong> y <strong>=&lt;</strong> son sin&#243;nimos.<br/><br/>
Debe utilizarse entre dos expresiones num&#233;ricas y devuelve un resultado l&#243;gico:<br/><br/>
<strong>Falso</strong> - Si la primera expresi&#243;n NO es menor o igual que la segunda.<br/><br/>
<strong>Cierto</strong> - Si la primera expresi&#243;n SI es menor o igual que la segunda.<br/><br/>
<strong>Ejemplos:</strong><br/><br/>
<strong>2+2 &lt;= 3</strong> devolver&#225; <strong>falso</strong>.<br/>
<strong>2+2 &lt;= 4</strong> devolver&#225; <strong>cierto</strong>.<br/>
<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1073">=</h2><br/><br/>
El s&#237;mbolo <strong>=</strong> (s&#237;mbolo de <strong>asignaci&#243;n</strong>) se utiliza en el lenguaje dentro de las <a href="#1009">declaraciones de datos</a> para inicializarlos, es decir, para definir el valor inicial de los mismos y en las <a href="#1019">sentencias de asignaci&#243;n</a> para separar la referencia al dato, de la expresi&#243;n asignada.<br/><br/>
Dentro de una expresi&#243;n este operador se puede utilizar como un operador aritm&#233;tico binario convencional, que se sit&#250;a entre dos operandos, y devuelve como resultado el valor del segundo operando (adem&#225;s de realizar la asignaci&#243;n de este resultado al dato reflejado como primer operando).<br/><br/>
Este operador representa una <strong>orden imperativa</strong>; se ordena que, al ejecutarse la sentencia que lo contiene, el primer operando (anterior al s&#237;mbolo) tome el valor que tiene el segundo operando (o expresi&#243;n posterior al s&#237;mbolo).<br/><br/>
En la evaluaci&#243;n de una expresi&#243;n los operandos de asignaci&#243;n son siempre los de <strong>menor prioridad</strong> (los &#250;ltimos que se interpretan en la expresi&#243;n), pudiendo utilizar par&#233;ntesis para forzar una prioridad mayor. Si en una expresi&#243;n (o sentencia) se han utilizado varios operadores de asignaci&#243;n, &#233;stos ser&#225;n evaluados (ejecutados) de derecha a izquierda.<br/><br/>
Por ejemplo, en la sentencia:<br/><br/>
<strong>x=y=x+y;</strong><br/><br/>
Primero se relizar&#225; la suma (<strong>x+y</strong>), despu&#233;s se asignar&#225; el resultado como nuevo valor de la variable <strong>y</strong> (<strong>y=x+y</strong>) y, por &#250;ltimo, se asignar&#225; este mismo valor a la variable <strong>x</strong> (<strong>x=y</strong>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1009">Declaraciones de datos</a> - <a href="#1019">Sentencias de asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1074">==</h2><br/><br/>
Operador l&#243;gico [<strong>igual que</strong>] utilizado en condiciones. Debe utilizarse entre dos expresiones num&#233;ricas y devuelve un resultado l&#243;gico:<br/><br/>
<strong>Falso</strong> - Si las expresiones dan resultados distintos, pues NO son iguales (ni equivalentes).<br/><br/>
<strong>Cierto</strong> - Si ambas expresiones dan el mismo resultado (si son dos expresiones equivalentes), pues SI son iguales.<br/><br/>
<strong>Ejemplos:</strong><br/><br/>
<strong>0 == -1</strong>  devolver&#225; <strong>falso</strong>.<br/>
<strong>2+2 == 4</strong> devolver&#225; <strong>cierto</strong>.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El s&#237;mbolo <a href="#1073">=</a> no puede utilizarse para comparar dos expresiones o valores num&#233;ricos, ya que es el s&#237;mbolo de asignaci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1075">&gt;=  =&gt;</h2><br/><br/>
Operador l&#243;gico [<strong>mayor o igual que</strong>] utilizado en condiciones. Los s&#237;mbolos <strong>&gt;=</strong> y <strong>=&gt;</strong> son sin&#243;nimos.<br/><br/>
Debe utilizarse entre dos expresiones num&#233;ricas y devuelve un resultado l&#243;gico:<br/><br/>
<strong>Falso</strong> - Si la primera expresi&#243;n NO es mayor o igual que la segunda.<br/><br/>
<strong>Cierto</strong> - Si la primera expresi&#243;n SI es mayor o igual que la segunda.<br/><br/>
<strong>Ejemplos:</strong><br/><br/>
<strong>2+2 &gt;= 5</strong> devolver&#225; <strong>falso</strong>.<br/>
<strong>2+2 &gt;= 4</strong> devolver&#225; <strong>cierto</strong>.<br/>
<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1076">&gt;</h2><br/><br/>
Operador l&#243;gico [<strong>mayor que</strong>] utilizado en condiciones. Debe utilizarse entre dos expresiones num&#233;ricas y devuelve un resultado l&#243;gico:<br/><br/>
<strong>Falso</strong> - Si la primera expresi&#243;n NO es mayor que la segunda.<br/><br/>
<strong>Cierto</strong> - Si la primera expresi&#243;n SI es mayor que la segunda.<br/><br/>
<strong>Ejemplos:</strong><br/><br/>
<strong>2+2 &gt; 4</strong> devolver&#225; <strong>falso</strong>.<br/>
<strong>2 &gt; 1</strong>   devolver&#225; <strong>cierto</strong>.<br/>
<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1037">Condici&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1077">&gt;&gt;</h2><br/><br/>
Operador binario de <strong>rotaci&#243;n a la derecha</strong>. Este operador se utiliza en las <a href="#1035">expresiones aritm&#233;ticas</a> entre dos operandos para obtener el resultado de rotar el primer operando a la derecha el n&#250;mero de veces que indique el segundo. Por ejemplo, la siguiente rotaci&#243;n:<br/><br/>
<strong>n</strong> &gt;&gt; <strong>m</strong><br/><br/>
devolver&#225; <strong>n</strong> rotado a la derecha <strong>m</strong> veces; cada rotaci&#243;n a la derecha equivale a dividir por 2 el n&#250;mero. Es decir, rotar a la izquierda 1 vez, equivale a dividir por 2, rotar a la izquierda 2 veces a dividir por 4, 3 veces a dividir por 8, etc.<br/><br/>
Se recuerda que todos los n&#250;meros manipulados en este lenguaje son <strong>enteros</strong> (sin decimales) por lo que siempre se devolver&#225; el resultado <strong>entero</strong> de la divisi&#243;n (7 dividido entre 2 devolver&#225; 3, por ejemplo).<br/><br/>
O lo que es equivalente (la <a href="#145">funci&#243;n POW</a><strong>(2, m)</strong> devuelve <strong>2</strong> elevado a <strong>m</strong>):<br/><br/>
<strong>n</strong> / POW(2, <strong>m</strong>)<br/><br/>
Por ejemplo, <strong>16&gt;&gt;3</strong> devolver&#225; 2, <strong>2&gt;&gt;1</strong> devolver&#225; 1, <strong>100&gt;&gt;0</strong> devolver&#225; 100, etc.<br/><br/>
<hr/>
<br/><br/>
El operador de rotaci&#243;n a la izquierda (operaci&#243;n opuesta a &#233;sta) es el <a href="#1070">s&#237;mbolo &lt;&lt;</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1078">&gt;&gt;=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n binaria de <strong>rotaci&#243;n a la derecha</strong>.<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> &gt;&gt;=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato el resultado de la siguiente rotaci&#243;n:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] &gt;&gt; [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
O lo que es equivalente (la <a href="#145">funci&#243;n POW</a><strong>(2, n)</strong> devuelve <strong>2</strong> elevado a <strong>n</strong>):<br/><br/>
[<strong>valor_anterior_del_dato</strong>] / POW(2, [<strong>resultado_de_la_expresi&#243;n</strong>])<br/><br/>
Es decir, si el resultado de la expresi&#243;n es:<br/><br/>
0 -&gt; el dato mantendr&#225; su valor.<br/>
1 -&gt; el dato ser&#225; dividido por 2.<br/>
2 -&gt; el dato ser&#225; dividido por 4.<br/>
3 -&gt; el dato ser&#225; dividido por 8.<br/>
...<br/><br/>
Ejemplo: <strong>x=8; x&gt;&gt;=2;</strong> -&gt; (x=2)<br/><br/>
El resultado de una rotaci&#243;n a la derecha ser&#225; siempre un n&#250;mero entero, sin decimales, es decir, el cociente de la divisi&#243;n entera anterior.<br/><br/>
Ejemplo: <strong>x=9; x&gt;&gt;=2;</strong> -&gt; (x=2)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>; en cualquier caso, una sentencia del tipo <strong>n &gt;&gt;= m;</strong> ser&#225; equivalente a esta otra <strong>n = n &gt;&gt; m;</strong>.<br/><br/>
Ver el operador <a href="#1077">&gt;&gt;</a> para m&#225;s informaci&#243;n sobre la <strong>rotaci&#243;n a la derecha</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1079">^  [  ]</h2><br/><br/>
Operador de indirecci&#243;n. Este operador requiere un nivel ligeramente avanzado en t&#233;cnicas de programaci&#243;n. El uso de punteros es una caracter&#237;stica de otros lenguajes que, aunque puede ser muy &#250;til, no resulta imprescindible para la realizaci&#243;n de programas, por complejos que &#233;stos sean.<br/><br/>
El s&#237;mbolo <strong>^</strong> sirve para hacer referencia a una posici&#243;n determinada de la memoria del ordenador.<br/><br/>
<strong>Caso pr&#225;ctico</strong><hr/>
<br/><br/>
Por ejemplo, si se tiene una variable denominada <strong>mi_variable</strong> con el valor <strong>3</strong>, &#233;sta estar&#225; en una direcci&#243;n de la memoria (todas las variables tienen su direcci&#243;n), el operador <a href="#1085">OFFSET</a> sirve para obtener esta direcci&#243;n.<br/><br/>
Suponiendo que exista otra variable denominada <strong>direcci&#243;n_de_mi_variable</strong> en la que guardar la direcci&#243;n de la variable anterior, &#233;sto se har&#237;a con la siguiente sentencia:<br/><br/>
<strong>direcci&#243;n_de_mi_variable = OFFSET mi_variable;</strong><br/><br/>
Esta direcci&#243;n ser&#225; un n&#250;mero entero, pongamos <strong>12345</strong>; para obtener el valor de la variable (<strong>3</strong>) o modificarlo, teniendo &#250;nicamente la direcci&#243;n (posici&#243;n) de la variable en memoria (y no su nombre), se debe utilizar el operador <strong>^</strong>, la sentencia obtener el valor de la variable a partir de su direcci&#243;n ser&#237;a:<br/><br/>
<strong>mi_variable = ^ direcci&#243;n_de_mi_variable;</strong><br/><br/>
Para aclarar los conceptos de <strong>nombre de variable</strong>, <strong>direcci&#243;n de la variable</strong> y <strong>valor de la variable</strong> se muestran a continuaci&#243;n una serie de expresiones y sus equivalentes num&#233;ricos.<br/><br/>
<strong>mi_variable</strong> = <strong>3</strong><br/>
<strong>OFFSET mi_variable</strong> = <strong>12345</strong><br/>
<strong>direcci&#243;n_de_mi_variable</strong> = <strong>12345</strong><br/>
<strong>^ direcci&#243;n_de_mi_variable</strong> = <strong>3</strong><br/>
<br/><br/>
La direcci&#243;n de una variable puede variar seg&#250;n se vaya ampliando un programa (a&#241;adiendo nuevos datos y sentencias al mismo).<br/><br/>
En resumen, <strong>el operador ^ accede al valor que est&#225; en la posici&#243;n de la memoria del ordenador indicada tras &#233;l</strong>, es decir:<br/><br/>
<strong>^ 12345</strong> = <strong>3</strong><br/>
<br/><br/>
Lo que quiere decir que, en la direcci&#243;n <strong>12345</strong> de la memoria del ordenador, est&#225; el valor <strong>3</strong>, ya que en esta direcci&#243;n es donde se <strong>almacena</strong> el valor de la variable <strong>mi_variable</strong> y &#233;se es su valor.<br/><br/>
<hr/>
<br/><br/>
El <a href="#1054">s&#237;mbolo *</a> puede utilizarse como <strong>sin&#243;nimo</strong> de <strong>^</strong> (en el ejemplo anterior <strong>*12345</strong> = <strong>3</strong>).<br/><br/>
Los corchetes (s&#237;mbolos <strong>[ ]</strong>) funcionan de forma similiar al operador <strong>^</strong>, con la &#250;nica diferencia que acceden al dato cuya direcci&#243;n se indica entre ellos (en el ejemplo anterior <strong>[12345]</strong> = <strong>3</strong>).<br/><br/>
Los corchetes tambi&#233;n se utilizan para especificar el &#237;ndice en las tablas y estructuras.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1085">OFFSET</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1081">^=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n l&#243;gica y binaria de <strong>OR (o) exclusivo</strong> (<strong>XOR</strong>).<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> ^=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato el <strong>OR (o) exclusivo</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] XOR [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=5; x^=3;</strong> -&gt; (x=3)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>; en cualquier caso una sentencia del tipo <strong>n ^= m;</strong> ser&#225; equivalente a &#233;sta otra <strong>n = n XOR m;</strong>.<br/><br/>
Ver el operador <a href="#1082">XOR</a> para m&#225;s informaci&#243;n sobre el <strong>OR (o) exclusivo</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1082">XOR  ^^</h2><br/><br/>
Operador l&#243;gico y binario de <strong>OR (o) exclusivo</strong> utilizado en expresiones y condiciones.<br/><br/>
La palabra reservada <strong>XOR</strong> y el s&#237;mbolo<strong> ^^</strong> son sin&#243;nimos.<br/><br/>
<strong>XOR l&#243;gico:</strong> Se eval&#250;an primero las condiciones de la derecha e izquierda del operador y si <strong>s&#243;lo una</strong> de ambas es <strong>cierta</strong>, este operador devolver&#225; <strong>cierto</strong>; en caso contrario el operador devolver&#225; siempre <strong>falso</strong>.<br/><br/>
FALSO  XOR FALSO  = FALSO<br/>
FALSO  XOR CIERTO = CIERTO<br/>
CIERTO XOR FALSO  = CIERTO<br/>
CIERTO XOR CIERTO = FALSO<br/>
<br/><br/>
Se utiliza para comprobar que se cumplan una, y s&#243;lo una, de las dos condiciones que se especifican, por ejemplo:<br/><br/>
<strong>(y&gt;0 XOR x&gt;0)</strong><br/>
<br/><br/>
Para comprobar que la primera variable sea mayor que 0, o bien (&#39;o&#39; exclusivo), que lo sea la segunda (pero no la primera).<br/><br/>
<strong>XOR binario:</strong> Eval&#250;a los bits de los resultados de las expresiones anterior y posterior al operador generando, como resultado, un valor que tendr&#225; a 1 solamente los bits que tuvieran a 1 una, y s&#243;lo una, de las expresiones.<br/><br/>
0 XOR 0 = 0<br/>
0 XOR 1 = 1<br/>
1 XOR 0 = 1<br/>
1 XOR 1 = 0<br/>
<br/><br/>
Esta regla se aplicar&#225; a todos los bits de los operandos (en el lenguaje son enteros de 32 bits).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este operador funciona indistintamente como l&#243;gico y binario debido a que en el lenguaje se interpretan las expresiones l&#243;gicas <strong>ciertas</strong> como las que tienen el &#250;ltimo bit a 1 (el bit 0, de peso 1), es decir, los n&#250;meros impares (1, -1, 3, -3, ... ), y como expresiones l&#243;gicas <strong>falsas</strong> las que tienen el &#250;ltimo bit a 0 (los n&#250;meros pares: 0, 2, -2, 4, -4, ...).<br/><br/>
El operador <strong>XOR</strong> &#250;nicamente dejar&#225; a 1 el &#250;ltimo bit (s&#243;lo devolver&#225; <strong>cierto</strong> como resultado} cuando lo tuviera a 1 uno, y s&#243;lo uno, de ambos operandos (cuando &#250;nicamente una de las dos expresiones fuera <strong>cierta</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El s&#237;mbolo<strong> ^</strong> tambi&#233;n puede utilizarse como un sin&#243;nimo m&#225;s de <strong>XOR</strong> y<strong> ^^</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1037">Condici&#243;n</a> - <a href="#1083">OR</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1083">OR  ||  |</h2><br/><br/>
Operador binario de <strong>suma l&#243;gica</strong> utilizado en expresiones y condiciones.<br/><br/>
La palabra reservada <strong>OR</strong> y los s&#237;mbolos<strong> ||</strong> y<strong> |</strong> son sin&#243;nimos.<br/><br/>
<strong>OR l&#243;gico:</strong> Se eval&#250;an primero las condiciones de la derecha e izquierda del operador y si al menos una de ellas es <strong>cierta</strong>, este operador devolver&#225; <strong>cierto</strong>, en caso contrario el operador devolver&#225; <strong>falso</strong> (cuando las dos condiciones sean <strong>falsas</strong>).<br/><br/>
FALSO  OR FALSO  = FALSO<br/>
FALSO  OR CIERTO = CIERTO<br/>
CIERTO OR FALSO  = CIERTO<br/>
CIERTO OR CIERTO = CIERTO<br/>
<br/><br/>
Se utiliza para comprobar que se cumplan una (cualquiera) de las condiciones que se establecen, por ejemplo:<br/><br/>
<strong>(x&gt;0 OR y&gt;0)</strong><br/>
<br/><br/>
Para comprobar que al menos una de las dos variables sea mayor que 0. Es decir, que se cumpla la primera condici&#243;n <strong>O</strong> la segunda.<br/><br/>
<strong>OR binario:</strong> Eval&#250;a los bit de los resultados de las expresiones anterior y posterior al operador, generando como resultado un valor que tendr&#225; a 1 los bit que tuvieran a 1 cualquiera de las expresiones.<br/><br/>
0 OR 0 = 0<br/>
0 OR 1 = 1<br/>
1 OR 0 = 1<br/>
1 OR 1 = 1<br/>
<br/><br/>
Esta regla se aplicar&#225; a todos los bit de los operandos (en el lenguaje son enteros de 32 bits).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este operador funciona indistintamente como l&#243;gico y binario debido a que en el lenguaje se interpretan las expresiones l&#243;gicas <strong>ciertas</strong> como las que tienen el &#250;ltimo bit a 1 (el bit 0, de peso 1), es decir, los n&#250;meros impares (1, -1, 3, -3, ... ), y como expresiones l&#243;gicas <strong>falsas</strong> las que tienen el &#250;ltimo bit a 0 (los n&#250;meros pares: 0, 2, -2, 4, -4, ...).<br/><br/>
El operador <strong>OR</strong> dejar&#225; a 1 el &#250;ltimo bit (devolver&#225; <strong>cierto</strong> como resultado} cuando lo tuviera a 1 uno (cualquiera) de los operandos (cuando los dos fueran, al menos, una de las dos expresiones fuera <strong>cierta</strong>).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1035">Expresi&#243;n</a> - <a href="#1037">Condici&#243;n</a> - <a href="#1082">XOR</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1084">|=</h2><br/><br/>
Asignaci&#243;n operativa. Operaci&#243;n binaria de <strong>suma l&#243;gica</strong> (<strong>OR</strong>).<br/><br/>
Las <a href="#1019">sentencias de asignaci&#243;n</a> sirven para calcular expresiones y <strong>asign&#225;rselas</strong> a un dato.<br/><br/>
<a href="#1034">&lt;referencia a un dato&gt;</a> <strong>=</strong> <a href="#1035">&lt;expresi&#243;n&gt;</a> <strong>;</strong><br/><br/>
Si se utiliza el s&#237;mbolo<strong> |=</strong> en lugar de <strong>=</strong> para realizar la asignaci&#243;n, se asignar&#225; al dato la <strong>suma l&#243;gica</strong> siguiente:<br/><br/>
[<strong>valor_anterior_del_dato</strong>] OR [<strong>resultado_de_la_expresi&#243;n</strong>]<br/><br/>
Ejemplo: <strong>x=5; x|=6;</strong> -&gt; (x=7)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Este s&#237;mbolo es una simple abreviatura derivada del <strong>lenguaje C</strong>, en cualquier caso una sentencia del tipo <strong>n |= m;</strong> ser&#225; equivalente a esta otra <strong>n = n OR m;</strong>.<br/><br/>
Ver el operador <a href="#1083">OR</a> para m&#225;s informaci&#243;n sobre la <strong>suma l&#243;gica</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> No se debe confundir este s&#237;mbolo con el de [<strong>distinto que</strong>] que se expresa como <a href="#1046">!=</a>, y sirve para comparar si dos expresiones difieren en su resultado.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1019">Asignaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1085">OFFSET</h2><br/><br/>
La palabra reservada <strong>OFFSET</strong> permite obtener la direcci&#243;n de un dato dentro de la memoria del ordenador.<br/><br/>
Todos los datos de un programa se corresponden con alguna posici&#243;n concreta de la memoria en la que est&#225; almacenado su valor; el operador <strong>OFFSET</strong> permite obtener esta posici&#243;n como un valor num&#233;rico.<br/><br/>
Este operador se utiliza, principalmente, en los par&#225;metros de algunas de las funciones del lenguaje; esto se hace para permitir a dichas funciones que puedan modificar estos par&#225;metros.<br/><br/>
Si se tiene una variable, por ejemplo denominada <strong>mi_variable</strong>, con el valor <strong>321</strong> y se pasa, como par&#225;metro, dicha variable a una funci&#243;n par&#225;metro, se le est&#225; pasando a la funci&#243;n el n&#250;mero 321; con esto, la funci&#243;n no podr&#225; modificar la variable ya que conoce su valor pero no <strong>d&#243;nde est&#225; la variable</strong> (pues puede haber muchos valores <strong>321</strong> por toda la memoria del ordenador, y no sabr&#225; cu&#225;l de ellos es la variable).<br/><br/>
Si a esta funci&#243;n se le pasa como par&#225;metro <strong>OFFSET mi_variable</strong> se le estar&#225; informando del lugar en el que est&#225; almacenado el valor de la variable, pudiendo, la funci&#243;n, acceder a dicho valor para consultarlo o modificarlo.<br/><br/>
Para m&#225;s informaci&#243;n sobre este operador se puede acceder al <a href="#1079">operador ^</a> que realiza la operaci&#243;n inversa al operador <strong>OFFSET</strong> (es decir, obtiene el valor que hay en una posici&#243;n determinada de la memoria).<br/><br/>
<hr/>
<br/><br/>
El <a href="#1050">s&#237;mbolo &amp;</a> puede utilizarse como <strong>sin&#243;nimo</strong> de la palabra reservada <strong>OFFSET</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1079">^</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1086">BEGIN</h2><br/><br/>
Esta palabra reservada indica el comienzo del programa, proceso o funci&#243;n.<br/><br/>
Es decir, la palabra <strong>BEGIN</strong> se utiliza para separar la zona de declaraci&#243;n de datos del programa principal o de un proceso, de la zona de sentencias.<br/><br/>
Es obligatoria la declaraci&#243;n <strong>BEGIN</strong> (inicio) en el programa principal y todos los procesos.<br/><br/>
Cuando se ejecuta un programa o proceso, &#233;ste comenzar&#225; siempre por la sentencia que venga a continuaci&#243;n de <strong>BEGIN</strong>.<br/><br/>
La sentencia <strong>BEGIN no hace nada</strong>, &#250;nicamente sirve como delimitador dentro de la estructura de los programas.<br/><br/>
<hr/>
<br/><br/>
Cada <strong>BEGIN</strong> (inicio) viene relacionado directamente con un <a href="#1091">END</a> (fin) que marcar&#225; el final de la zona de sentencias del programa o proceso.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1015">C&#243;digo Principal</a> - <a href="#1016">PROCESS</a> - <a href="#1408">FUNCTION</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1087">CASE</h2><br/><br/>
Esta palabra reservada forma parte de la sentencia <a href="#1021">SWITCH</a>; se utiliza como inicio de las diferentes secciones de sentencias que pueden ejecutarse o no, dependiendo del resultado de la expresi&#243;n evaluada.<br/><br/>
Cada <strong>CASE</strong> debe tener una palabra <a href="#1091">END</a> que indique el final de la secci&#243;n.<br/><br/>
La sentencia <a href="#1021">SWITCH</a> eval&#250;a una expresi&#243;n y el significado que tiene la palabra <strong>CASE</strong> es &quot;<strong>en el caso de que el resultado de la expresi&#243;n sea ..., entonces se deben ejecutar las siguientes sentencias ...</strong>&quot;.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1021">Sentencia SWITCH</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1088">DEFAULT</h2><br/><br/>
Esta palabra reservada forma parte de la sentencia <a href="#1021">SWITCH</a> que se utiliza como inicio de una secci&#243;n de sentencias que debe ejecutarse cuando el resultado de la expresi&#243;n evaluada no est&#233; contemplado en ninguna de las secciones <a href="#1087">CASE</a> de la sentencia.<br/><br/>
Cada <strong>DEFAULT</strong> debe tener una palabra <a href="#1091">END</a> que indique el final de la secci&#243;n.<br/><br/>
La sentencia <a href="#1021">SWITCH</a> eval&#250;a una expresi&#243;n; cada secci&#243;n <a href="#1087">CASE</a> de la sentencia contemplar&#225; uno o varios resultados en los que se debe ejecutar dicha secci&#243;n y, por &#250;ltimo, si aparece una secci&#243;n <strong>DEFAULT</strong> es para expresar &quot;<strong>en el caso de que el resultado de la expresi&#243;n no sea ninguno de los anteriores, entonces se deben ejecutar las siguientes sentencias ...</strong>&quot;.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1021">Sentencia SWITCH</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1089">DUP</h2><br/><br/>
Esta palabra sirve para definir <a href="#1013">listas de constantes</a> (valores num&#233;ricos), a base de repetir un patr&#243;n sencillo. Se utiliza para inicializar los valores iniciales de tablas y estructuras.<br/><br/>
Su sintaxis es la siguiente:<br/><br/>
&lt;n&#250;mero de veces&gt; <strong>DUP (</strong>&lt;secuencia a repetir&gt;<strong>)</strong><br/><br/>
Es equivalente a poner la &lt;secuencia a repetir&gt; el &lt;n&#250;mero de veces&gt; que se indica.<br/><br/>
Por ejemplo, la secuencia <strong>1, 2, 3, 1, 2, 3, 1, 2, 3</strong> ser&#237;a equivalente a la secuencia <strong>3 DUP (1, 2, 3)</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1013">Definici&#243;n de una lista de constantes</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1090">ELSE</h2><br/><br/>
Esta palabra forma parte de la sentencia <a href="#1020">IF</a>, y sirve para especificar d&#243;nde comienza el bloque de sentencias que se debe ejecutar cuando la condici&#243;n especificada en la sentencia <a href="#1020">IF</a> no se cumpla.<br/><br/>
El formato de la sentencia <a href="#1020">IF</a> es el siguiente:<br/><br/>
<strong>IF (&lt;</strong>condici&#243;n<strong>&gt;)</strong><br/>
// C&#243;digo a ejecutar cuando se cumpla la condici&#243;n<br/>
<strong>ELSE</strong><br/>
// C&#243;digo a ejecutar cuando <strong>no</strong> se cumpla la condici&#243;n<br/>
<strong>END</strong><br/>
<br/><br/>
El significado sem&#225;ntico de <strong>ELSE</strong> es &quot;<strong>en el caso contrario ...</strong>&quot;.<br/><br/>
<hr/>
<br/><br/>
La secci&#243;n <strong>ELSE</strong> es opcional, pudiendo formularse la sentencia <a href="#1020">IF</a> de la siguiente forma:<br/><br/>
<strong>IF (&lt;</strong>condici&#243;n<strong>&gt;)</strong><br/>
// C&#243;digo a ejecutar cuando se cumpla la condici&#243;n<br/>
<strong>END</strong><br/>
<br/><br/>
Cuando no se requiera que se ejecute ninguna sentencia <strong>en el caso contrario</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1020">Sentencia IF</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1091">END</h2><br/><br/>
Esta palabra reservada marca el final de una de las siguientes sentencias:<br/><br/>
<a href="#1086">BEGIN</a><br/>
<a href="#1020">IF</a><br/>
<a href="#1022">WHILE</a><br/>
<a href="#1021">SWITCH</a><br/>
<a href="#1087">CASE</a><br/>
<a href="#1087">DEFAULT</a><br/>
<a href="#1025">FOR</a><br/>
<a href="#1043">FROM</a><br/>
<a href="#1024">LOOP</a><br/>
<a href="#1030">CLONE</a><br/>
<br/><br/>
Es decir, la funci&#243;n de la palabra <strong>END</strong> es <strong>delimitar d&#243;nde acaba una sentencia</strong>.<br/><br/>
Se debe tener en cuenta que las sentencias se pueden anidar, es decir, incluir unas dentro de otras, por lo que si no se estructura bien un programa (tabulando el c&#243;digo), puede resultar dif&#237;cil averiguar a qu&#233; sentencia corresponde cada <strong>END</strong>.<br/><br/>
Por ejemplo, en el siguiente c&#243;digo se puede ver claramente a qu&#233; sentencia pertenece cada <strong>END</strong>.<br/><br/>
<strong>BEGIN</strong><br/>
<strong>IF (x&gt;0)</strong><br/>
<strong>x=x-1;</strong><br/>
<strong>END</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Pero este mismo c&#243;digo podr&#237;a haberse expresado como sigue:<br/><br/>
<strong>BEGIN</strong><br/>
<strong>IF (x&gt;0)</strong><br/>
<strong>x=x-1;</strong><br/>
<strong>END</strong><br/>
<strong>END</strong><br/>
<br/><br/>
resultando mucho m&#225;s complicada la lectura del programa, aunque para el compilador del lenguaje <strong>ambos bloques de c&#243;digo son exactamente iguales</strong> (el compilador seguir&#225; interpretando que el primer <strong>END</strong> es el de la sentencia <strong>IF</strong> y el segundo el del <strong>BEGIN</strong>, aunque &#233;stos est&#233;n tabulados incorrectamente).<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1092">ID</h2><br/><br/>
La palabra reservada <strong>ID</strong> se utiliza para obtener el <a href="#1039">c&#243;digo identificador</a> de un proceso en tiempo de ejecuci&#243;n.<br/><br/>
Un <a href="#1039">c&#243;digo identificador</a> es un valor num&#233;rico que <strong>identifica</strong> a cada uno de los porcesos activos en cada momento (cada uno de los objetos que tenga el juego).<br/><br/>
Es decir, <strong>ID</strong> es como una constante num&#233;rica s&#243;lo que su valor ser&#225; diferente para cada proceso que la consulte.<br/><br/>
No es posible cambiar el valor de <strong>ID</strong>, ya que es un objeto &#250;nicamente de lectura.<br/><br/>
Normalmente, un proceso accede a este valor cuando quiere informar a otros procesos de cu&#225;l es su <a href="#1039">c&#243;digo identificador</a>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1039">C&#243;digos identificadores</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1093">SETUP_PROGRAM</h2><br/><br/>
Esta palabra reservada sirve para designar un tipo especial de programas, de <strong>configuraci&#243;n del hardware de sonido</strong>.<br/><br/>
Estos programas se identifican por comenzar con la palabra reservada <strong>SETUP_PROGRAM</strong> en lugar de <a href="#1003">PROGRAM</a>.<br/><br/>
&#201;ste es un t&#243;pico muy avanzado, para usuarios con experiencia.<br/><br/>
Se puede observar un programa de este tipo en el directorio <strong>SETUP</strong> de DIV Games Studio; estos programas, una vez compilados, se incluir&#225;n autom&#225;ticamente en las instalaciones del resto de programas, cuando en el proceso de instalaci&#243;n se active la casilla &quot;<strong>Incluir setup de sonido</strong>&quot;.<br/><br/>
<strong>Nota:</strong> En las instalaciones siempre se incluir&#225; el &#250;ltimo programa de setup que haya sido compilado en DIV Games Studio.<br/><br/>
<hr/>
<br/><br/>
No obstante, se recuerda que no es imprescindible crear programas de configuraci&#243;n del sistema de sonido, ya que los juegos creados con DIV Games Studio detectar&#225;n autom&#225;ticamente si el ordenador en el que se ejecutan tiene una tarjeta de sonido compatible con <strong>Sound Blaster</strong> o <strong>Gravis Ultrasound</strong>, siempre que &#233;sta est&#233; apropiadamente configurada.<br/><br/>
<hr/>
<br/><br/>
Este tipo de programas suelen modificar la <a href="#1104">estructura global setup</a>, que es la que controla los par&#225;metros del sistema de sonido.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1104">Estructura setup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1094">SIZEOF()</h2><br/><br/>
<strong>SIZEOF(</strong>&lt;nombre del dato&gt;<strong>)</strong><br/><br/>
<strong>Retorna:</strong><br/><br/>
El n&#250;mero de elementos que contiene el dato.<br/><br/>
<strong>Descripci&#243;n:</strong><br/><br/>
La palabra reservada <strong>SIZEOF</strong> se utiliza para calcular el n&#250;mero de elementos que tiene una tabla o una estructura.<br/><br/>
Esta palabra reservada <strong>se utiliza como si fuera una funci&#243;n</strong> del lenguaje, indicando, entre par&#233;ntesis, el <a href="#1001">nombre</a> del dato y devolviendo el n&#250;mero de elementos (posiciones) del mismo.<br/><br/>
Es posible utilizarla para obtener el n&#250;mero de elementos de una variable pero, en este caso, <strong>SIZEOF</strong> retornar&#225; siempre <strong>1</strong> como n&#250;mero de elementos (ya que una variable es un &#250;nico elemento).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_sizeof;

PRIVATE
    tabla1[]=0, 1, 2, 3;
    tabla2[]=4, 5, 6, 7, 8;
    variable=9;

BEGIN
    // ...

    save(&quot;help\help.dat&quot;, OFFSET tabla1, SIZEOF(tabla1)+SIZEOF(tabla2)+SIZEOF(variable));

    // ...
END
</pre>
En este ejemplo se utiliza <strong>SIZEOF</strong> para obtener el n&#250;mero de elementos de tres datos diferentes; &#233;stos son:<br/><br/>
<strong>tabla1</strong> de <strong>4</strong> elementos.<br/>
<strong>tabla2</strong> de <strong>5</strong> elementos.<br/>
<strong>variable</strong> (<strong>1</strong> elemento).<br/>
<br/><br/>
En este caso se utiliza para grabar en el archivo <strong>help.dat</strong> el contenido de estos tres datos con la funci&#243;n <a href="#155">save()</a> que requiere, como tercer par&#225;metro, el n&#250;mero de elementos que se quieren guardar en el archivo.<br/><br/>
En este caso se guardar&#225;n <strong>10</strong> elementos en el archivo <strong>help.dat</strong>, que seg&#250;n est&#225;n inicializados los datos en el ejemplo ser&#225;n los n&#250;meros del <strong>0</strong> al <strong>9</strong>.<br/><br/>
La sentencia <a href="#155">save()</a> del ejemplo anterior se podr&#237;a haber expresado tambi&#233;n sin utilizar <strong>SIZEOF</strong> de la siguiente forma:<br/><br/>
<strong>save(&quot;help\help.dat&quot;, OFFSET tabla1, 10);</strong><br/><br/>
La &#250;nica diferencia es que si en el programa del ejemplo se a&#241;adieran elementos a alguna de las dos tablas, no har&#237;a falta modificar la llamada a la funci&#243;n <a href="#155">save()</a>, ya que <strong>SIZEOF</strong> siempre devolver&#225; el tama&#241;o actual de las mismas.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1011">Declaraci&#243;n de una tabla</a> - <a href="#1012">Declaraci&#243;n de una estructura</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1095">STEP</h2><br/><br/>
La palabra reservada <strong>STEP</strong> forma parte de la sentencia <a href="#1043">FROM</a> y sirve para indicar el incremento (paso) que se debe hacer en cada iteraci&#243;n del bucle.<br/><br/>
La sentencia <a href="#1043">FROM</a> implementa un bucle, es decir, un grupo de sentencias que se van a repetir un n&#250;mero determinado de veces; para ello, utiliza una variable como contador del n&#250;mero de repeticiones.<br/><br/>
Se define el valor inicial de la variable as&#237; como el valor final, y el bucle se repetir&#225; hasta que la variable alcance el valor final, partiendo del valor inicial.<br/><br/>
Por defecto, la variable pasar&#225; por todos los valores num&#233;ricos enteros comprendidos entre el valor inicial y el valor final, pero se puede indicar una declaraci&#243;n <strong>STEP</strong> para establecer un incremento de la variable diferente.<br/><br/>
Por ejemplo, si se define un bucle en el que la variable <strong>x</strong> va a recorrer los valores del <strong>1</strong> al <strong>10</strong>, se ejecutar&#225; dicho bucle un total de <strong>10</strong> veces, pero si se estable el paso (<strong>STEP</strong>) como <strong>2</strong> el bucle se ejecutar&#225; &#250;nicamente <strong>5</strong> veces, en donde la variable <strong>x</strong> tomar&#225; los valores <strong>1</strong>, <strong>3</strong>, <strong>5</strong>, <strong>7</strong> y <strong>9</strong>, pues se habr&#225; establecido que la variable debe incrementarse de <strong>2</strong> en <strong>2</strong>. Este bucle se implementar&#237;a de la siguiente forma:<br/><br/>
<strong>FROM x=1 TO 10 STEP 2</strong><br/>
// Sentencias que se van a repetir las cinco veces<br/>
<strong>END</strong><br/>
<br/><br/>
Si se omite la declaraci&#243;n <strong>STEP</strong> de la sentencia <a href="#1043">FROM</a>, el incremento ser&#225; siempre de 1 en 1, sumando 1 a la variable tras cada iteraci&#243;n del bucle (o restando 1, en el caso de que el valor final sea menor que el valor inicial).<br/><br/>
<strong>Nota:</strong> Unicamente se pueden establecer incrementos enteros.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1096">TO</h2><br/><br/>
La palabra reservada <strong>TO</strong> forma parte de la sentencia <a href="#1043">FROM</a> y sirve para separar las constantes que indican los valores inicial y final que debe tomar la variable que se utilice como contador del bucle.<br/><br/>
La sentencia <a href="#1043">FROM</a> implementa un bucle, es decir, un grupo de sentencias que se van a repetir un n&#250;mero determinado de veces; para ello utiliza una variable como contador del n&#250;mero de repeticiones.<br/><br/>
Se define el valor inicial de la variable y el valor final, y el bucle se repetir&#225; hasta que la variable alcance el valor final, partiendo del valor inicial.<br/><br/>
<strong>Ejemplo:</strong><br/><br/>
<strong>FROM x=1 TO 10</strong><br/>
// Sentencias que se repetir&#225;n 10 veces<br/>
<strong>END</strong><br/>
<br/><br/>
Por defecto, la variable pasar&#225; por todos los valores num&#233;ricos enteros comprendidos entre el valor inicial y el valor final, pero se puede indicar una declaraci&#243;n <a href="#1095">STEP</a> para establecer un incremento de la variable diferente.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1043">Sentencia FROM</a> - <a href="#1095">STEP</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1097">UNTIL</h2><br/><br/>
La palabra reservada <strong>UNTIL</strong> forma parte de la sentencia <a href="#1023">REPEAT</a>, cuya sintaxis es, a grandes rasgos, la siguiente:<br/><br/>
<a href="#1023">REPEAT</a><br/>
<a href="#1017">&lt;sentencia&gt;</a>;<br/>
...<br/>
<strong>UNTIL (&lt;</strong>condici&#243;n&gt;}<strong>)</strong><br/><br/>
La sentencia <a href="#1023">REPEAT</a> implementa un bucle, es decir, es capaz de repetir un grupo de sentencias un n&#250;mero determinado de veces.<br/><br/>
El final de la sentencia se determina poniendo la palabra reservada <strong>UNTIL</strong> seguida de la condici&#243;n que se debe cumplir para que <strong>se de por finalizada la sentencia</strong>.<br/><br/>
<hr/>
Ver: <a href="#1000">Sintaxis</a> - <a href="#1023">Sentencia REPEAT</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1100">GLOBAL STRUCT mouse</h2><br/><br/>
<strong>STRUCT mouse;</strong><br/>
<strong>x, y;</strong>                // Coordenadas<br/>
<strong>graph;</strong>               // C&#243;digo del gr&#225;fico<br/>
<strong>file;</strong>                // C&#243;digo del fichero<br/>
<strong>z;</strong>                   // Plano de profundidad<br/>
<strong>angle;</strong>               // &#225;ngulo<br/>
<strong>size;</strong>                // Tama&#241;o (%)<br/>
<strong>flags;</strong>               // Indicador espejados<br/>
<strong>region;</strong>              // Regi&#243;n de corte<br/>
<strong>left, middle, right;</strong> // Estado botones<br/>
<strong>cursor;</strong>              // Emulaci&#243;n con cursores<br/>
<strong>speed;</strong>               // Velocidad del rat&#243;n<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura global sirve para controlar el rat&#243;n; contiene una serie de campos relacionados con la programaci&#243;n de este dispositivo, como la posici&#243;n en pantalla, el gr&#225;fico del puntero, el estado de los botones, etc.<br/><br/>
Para acceder a estos campos se debe preceder el nombre del campo por la palabra <strong>mouse</strong> y el s&#237;mbolo <a href="#1063">. (punto)</a>; por ejemplo, para acceder al campo <strong>x</strong> (coordenada horizontal del puntero del rat&#243;n) se debe utilizar <strong>mouse.x</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>x</strong>, <strong>y</strong> - Coordenadas horizontal y vertical del rat&#243;n. Estos dos campos (<strong>mouse.x</strong> y <strong>mouse.y</strong>) ser&#225;n los &#250;nicos que necesariamente habr&#225; que leer para conocer la posici&#243;n en pantalla del cursor del rat&#243;n.<br/><br/>
Para <strong>posicionar el rat&#243;n en otras coordenadas</strong> (forzar su posici&#243;n), bastar&#225; con asignar las nuevas coordenadas a estos dos campos.<br/><br/>
<hr/>
<br/><br/>
<strong>graph</strong> - <strong>C&#243;digo del gr&#225;fico</strong> asignado como puntero del rat&#243;n. Por defecto <strong>el rat&#243;n no ser&#225; visible</strong>; para hacerlo visible se debe crear el gr&#225;fico que va a servir de puntero en el <strong>editor gr&#225;fico</strong>, cargarlo en el programa (con la funci&#243;n <a href="#132">load_fpg()</a>, <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a>, seg&#250;n se haya guardado este gr&#225;fico en un <strong>fichero FPG</strong> o en un <strong>archivo MAP/PCX</strong>), y asignar su <strong>c&#243;digo de gr&#225;fico</strong> a esta variable (<strong>mouse.graph</strong>). Entonces se har&#225; visible el puntero del rat&#243;n en pantalla.<br/><br/>
En las coordenadas <strong>mouse.x</strong>, <strong>mouse.y</strong> aparecer&#225; el centro del gr&#225;fico, a no ser que se haya definido el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong> del mismo en el <strong>editor gr&#225;fico</strong>. Si se define este punto, com&#250;nmente denominado &quot;<strong>punto caliente del rat&#243;n</strong>&quot; (<strong>hot spot</strong>), ser&#225; &#233;l mismo el que aparezca en las coordenadas indicadas en los campos <strong>mouse.x</strong> e <strong>mouse.y</strong>.<br/><br/>
Por ejemplo, si se crea como dibujo para el puntero del rat&#243;n la t&#237;pica flecha (como el puntero de rat&#243;n DIV Games Studio), el &quot;punto caliente&quot; (punto de control n&#250;mero <strong>0</strong>) se definir&#237;a en la esquina superior izquierda del gr&#225;fico, pues &#233;ste es el <strong>punto activo</strong> dentro del gr&#225;fico. Entonces, cuando el rat&#243;n estuviera, por ejemplo, en las coordenadas (0, 0), ser&#237;a la precisamente la &quot;<strong>punta de la flecha</strong>&quot; la que se situara en dichas coordenadas.<br/><br/>
<hr/>
<br/><br/>
<strong>file</strong> - <strong>C&#243;digo del fichero</strong> que contiene el gr&#225;fico. En este campo se define el <strong>c&#243;digo de fichero</strong> que contiene el gr&#225;fico del puntero del rat&#243;n. <strong>No es necesario</strong> indicar aqu&#237; un valor si el gr&#225;fico se carg&#243; de un <strong>archivo MAP o PCX</strong>, o si est&#225; en el primer <strong>archivo FPG</strong> cargado en el programa. En caso contrario, se deber&#225; asignar a <strong>mouse.file</strong> el <strong>c&#243;digo de fichero</strong> que retorn&#243; la funci&#243;n <a href="#132">load_fpg()</a> al cargar el fichero que contiene el gr&#225;fico del puntero del rat&#243;n.<br/><br/>
<hr/>
<br/><br/>
<strong>z</strong> - Prioridad de impresi&#243;n del gr&#225;fico. Indica en qu&#233; plano de profundidad debe pintarse el gr&#225;fico del puntero del rat&#243;n. <strong>Por defecto</strong> este campo valdr&#225;<strong> -512</strong>, lo que implica que <strong>el puntero se ver&#225; por encima del resto de gr&#225;ficos y textos</strong>. Cuanto mayor sea este campo, m&#225;s al fondo se situar&#225; el puntero del rat&#243;n.<br/><br/>
Si se quisiera que un gr&#225;fico de un proceso apareciera por encima del puntero del rat&#243;n, bastar&#237;a con asignar a la variable <a href="#1125">local z</a> de dicho proceso un n&#250;mero entero menor de<strong> -512</strong>, por ejemplo<strong> -600</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>angle</strong> - &#225;ngulo con el que se ver&#225; el gr&#225;fico del puntero del rat&#243;n. El valor de <strong>mouse.angle</strong> por defecto es <strong>0</strong>, lo que implica que no se ver&#225; rotado este gr&#225;fico, a no ser que se asigne un nuevo &#225;ngulo a este campo.<br/><br/>
Se recuerda que los &#225;ngulos se deben especificar en mil&#233;simas de grado, por ejemplo, la sentencia <strong>mouse.angle=90000;</strong> har&#225; que el puntero aparezca rotado <strong>90 grados</strong> (ver el <a href="#1044">uso de &#225;ngulos en el lenguaje</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>size</strong> - Tama&#241;o del gr&#225;fico en porcentaje. Por defecto, este campo valdr&#225; <strong>100</strong> (el gr&#225;fico se ver&#225; al 100% de su tama&#241;o), y no es necesario indicar aqu&#237; otro valor a no ser que se quiera que el gr&#225;fico se escale (se vea ampliado o reducido).<br/><br/>
Si por ejemplo se quisiera que el gr&#225;fico apareciera el doble de grande que su tama&#241;o original (al 200%), se deber&#237;a utilizar la sentencia <strong>mouse.size=200;</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>flags</strong> - En este campo se indicar&#225;n diferentes valores cuando se pretenda que el gr&#225;fico del rat&#243;n aparezca espejado (invertido horizontal o verticalmente), o se quiera visualizarlo como un gr&#225;fico (semi) transparente. Los posibles valores asignables a la variable <strong>mouse.flags</strong> son:<br/><br/>
<strong>0</strong>-Gr&#225;fico normal (valor por defecto).<br/>
<strong>1</strong>-Espejado horizontal.<br/>
<strong>2</strong>-Espejado vertical.<br/>
<strong>3</strong>-Espejado horizontal y vertical (180&#176;).<br/>
<strong>4</strong>-Gr&#225;fico transparente.<br/>
<strong>5</strong>-Transparente y espejado horizontal.<br/>
<strong>6</strong>-Transparente y espejado vertical.<br/>
<strong>7</strong>-Transparente, espejado horizontal y vertical.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>region</strong> - Regi&#243;n de corte del gr&#225;fico. A este campo se debe asignar un valor <strong>&#250;nicamente cuando se quiera que el puntero del rat&#243;n sea visible s&#243;lo dentro de una regi&#243;n</strong> (una zona rectangular de la pantalla); para conseguirlo se debe, primero, definir esta regi&#243;n con la funci&#243;n <a href="#106">define_region()</a> y, despu&#233;s, asignar a este campo (<strong>mouse.region</strong>) el n&#250;mero de la regi&#243;n que se ha definido.<br/><br/>
Por defecto este valor ser&#225; <strong>0</strong>, que es el n&#250;mero de regi&#243;n que se refiere a la pantalla completa, por lo que el gr&#225;fico ser&#225; visible en toda la pantalla.<br/><br/>
<hr/>
<br/><br/>
<strong>left</strong>, <strong>middle</strong> y <strong>right</strong> - Estos tres campos almacenan valores l&#243;gicos (<strong>0</strong> o <strong>1</strong>) seg&#250;n los botones del rat&#243;n est&#233;n pulsados o no (se corresponden con los botones izquierdo, central y derecho del rat&#243;n). Normalmente, se activan &#250;nicamente dos botones del rat&#243;n (<strong>left</strong> y <strong>right</strong>) ignor&#225;ndose el estado del bot&#243;n central. Esto depende del <strong>driver</strong> (dispositivo de control) del rat&#243;n que est&#233; instalado en el ordenador.<br/><br/>
Por ejemplo, para realizar en un programa una acci&#243;n <strong>cuando se pulse el bot&#243;n izquierdo del rat&#243;n</strong> (<strong>mouse.left</strong>) se debe incluir en el c&#243;digo una sentencia como la siguiente:<br/><br/>
<strong>IF (mouse.left)</strong><br/>
// Acci&#243;n a realizar (sentencias)<br/>
<strong>END</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>cursor</strong> - Indica si est&#225; activa la emulaci&#243;n del rat&#243;n con las teclas de los <strong>Cursores</strong> y <strong>Enter</strong>; cuando esta emulaci&#243;n est&#233; activada, se podr&#225; mover el puntero tanto con el rat&#243;n como con los cursores. Por defecto, esta emulaci&#243;n estar&#225; desactivada (<strong>mouse.cursor=0;</strong>) a no ser que el programa no pueda detectar un rat&#243;n conectado al sistema, en cuyo caso se activar&#225; la emulaci&#243;n autom&#225;ticamente (es decir, si <strong>mouse.cursor</strong> vale <strong>1</strong> al inicio del programa, es que no hay un rat&#243;n conectado en el equipo).<br/><br/>
<hr/>
<br/><br/>
<strong>speed</strong> - Al igual que en el entorno, ahora se puede regular la velocidad de desplazamiento del puntero del rat&#243;n en los programas. Este es un valor entre <strong>0</strong> (velocidad m&#225;xima) y <strong>9</strong> (m&#237;nima), por defecto <strong>mouse.speed</strong> valdr&#225; <strong>2</strong>.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1101">GLOBAL STRUCT scroll</h2><br/><br/>
<strong>STRUCT scroll[9];</strong><br/>
<strong>x0, y0;</strong>    // Coordenadas del primer plano<br/>
<strong>x1, y1;</strong>    // Coordenadas del segundo plano<br/>
<strong>z;</strong>         // Plano de profundidad<br/>
<strong>camera;</strong>    // <a href="#1039">C&#243;digo identificador</a> de la c&#225;mara<br/>
<strong>ratio;</strong>     // Velocidad relativa del segundo plano<br/>
<strong>speed;</strong>     // Velocidad m&#225;xima del primer plano<br/>
<strong>region1;</strong>   // Primera regi&#243;n de pantalla<br/>
<strong>region2;</strong>   // Segunda regi&#243;n de pantalla<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura de <strong>10</strong> registros contiene ciertos campos relacionados con par&#225;metros modificables de las <strong>ventanas de scroll</strong>. Los diez registros tienen los mismos nombres de campos, pero cada uno de ellos modifica los par&#225;metros de una ventana de scroll diferente (ya que pueden activarse hasta 10 ventanas de este tipo).<br/><br/>
Una <strong>ventana de scroll</strong> se podr&#237;a definir como una regi&#243;n de pantalla que muestra s&#243;lo una parte de un gr&#225;fico m&#225;s grande que dicha ventana (este gr&#225;fico suele ser el <strong>decorado</strong> o <strong>fondo</strong> del juego). El <strong>scroll</strong> en s&#237; es el movimiento de dicha ventana por el gr&#225;fico en cualquier direcci&#243;n, visualiz&#225;ndose poco a poco el gr&#225;fico completo, secci&#243;n a secci&#243;n del mismo.<br/><br/>
Para que un registro (del <strong>0</strong> al <strong>9</strong>) de la <strong>estructura scroll</strong> tenga sentido, primero debe activarse dicha <strong>ventana de scroll</strong> (del <strong>0</strong> al <strong>9</strong>) con la funci&#243;n <a href="#163">start_scroll</a> (ver esta funci&#243;n para m&#225;s informaci&#243;n sobre las ventanas de scroll}.<br/><br/>
Se entiende que los campos de esta estructura son complementarios a los par&#225;metros de llamada de esta &#250;ltima funci&#243;n.<br/><br/>
<hr/>
<br/><br/>
<strong>Forma de uso de la estructura scroll:</strong><br/><br/>
Para acceder a estos campos se debe preceder el nombre del campo por la palabra <strong>scroll</strong>, el n&#250;mero de registro entre corchetes y el s&#237;mbolo <a href="#1063">.</a> (punto).<br/><br/>
Por ejemplo, si se inicializaran dos ventanas de scroll, la n&#250;mero 0 y la n&#250;mero 1, se podr&#237;a acceder al campo <strong>camera</strong> de ambas ventanas como <strong>scroll[0].camera</strong> y <strong>scroll[1].camera</strong>, respectivamente. Cuando se acceda a la ventana n&#250;mero 0 de scroll se puede, adem&#225;s, omitir el n&#250;mero de ventana entre corchetes, es decir, que la variable <strong>scroll.camera</strong> y la variable <strong>scroll[0].camera</strong> son, a todos los efectos, la misma para el lenguaje.<br/><br/>
<hr/>
<br/><br/>
<strong>Se muestra a continuaci&#243;n una descripci&#243;n detallada de cada campo</strong><br/><br/>
<strong>x0, y0</strong> - Coordenadas del primer plano de scroll, cuando es scroll <strong>NO</strong> es autom&#225;tico (no se ha definido el campo <strong>camera</strong>), <strong>&#233;stos son los campos que se deber&#225;n modificar para mover el primer plano de la ventana de scroll</strong>.<br/><br/>
Estos dos campos almacenan las coordenadas horizontal y vertical de la esquina superior izquierda de la ventana de scroll (el punto del gr&#225;fico del primer plano que se ver&#225; en la esquina superior izquierda de la ventana).<br/><br/>
Cuando se haya definido el campo <strong>camera</strong> de esta estructura, el movimiento de la ventana de scroll ser&#225; autom&#225;tico, por lo que estos campos ser&#225;n s&#243;lo de lectura; para poder comprobar donde est&#225; situado el scroll en cada momento (ver la funci&#243;n <a href="#140">move_scroll()</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>x1, y1</strong> - Coordenadas del segundo plano, cuando se haya definido un gr&#225;fico para el segundo plano. Cuando el scroll <strong>NO</strong> es autom&#225;tico (no se ha definido el campo <strong>camera</strong>), <strong>&#233;stos son los campos que se deber&#225;n modificar para mover el plano de fondo de la ventana de scroll</strong>.<br/><br/>
Cuando se haya definido el campo <strong>camera</strong> de esta estructura, el movimiento de la ventana de scroll ser&#225; autom&#225;tico, por lo que estos campos ser&#225;n s&#243;lo de lectura, determin&#225;ndose la velocidad de movimento del segundo plano en funci&#243;n del campo <strong>ratio</strong> de esta misma estructura.<br/><br/>
<hr/>
<br/><br/>
<strong>z</strong> - Prioridad de impresi&#243;n del scroll, aqu&#237; se indica en que plano de profundidad se debe pintar esta ventana, respecto al resto de procesos. Por defecto, esta variable valdr&#225; <strong>512</strong>, lo cual quiere decir que como los procesos por defecto tienen su variable <a href="#1125">local z</a> a <strong>0</strong>, la ventana de scroll se pintar&#225; en un plano de profundidad mayor, m&#225;s al fondo, visualiz&#225;ndose los gr&#225;ficos de los procesos por encima de la ventana. Para variar esta situaci&#243;n se puede modificar la variable <strong>z</strong> de la ventana (por ejemplo, ponerla a<strong> -1</strong>) o la variable <strong>z</strong> de los procesos (por ejemplo, ponerla a <strong>600</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>camera</strong> - Este campo no es necesario inicializarlo, se inicializar&#225; cuando se quiera que el scroll sea <strong>autom&#225;tico</strong>, esto es, que el sistema se encargue de que &#233;ste siga siempre a un proceso (un gr&#225;fico del juego). Para ello, se debe poner en este campo el <a href="#1039">c&#243;digo identificador</a> del proceso; s&#243;lo con esto, el desplazamiento de la ventana de scroll pasar&#225; a ser controlado autom&#225;ticamente por el sistema, intentando centrar el gr&#225;fico de dicho proceso siempre en la ventana. Este proceso debe tener la variable local <a href="#1122">ctype</a> con el valor <a href="#1168">c_scroll</a>.<br/><br/>
Por defecto este campo valdr&#225; <strong>0</strong>, lo que implica que el scroll no seguir&#225; a ning&#250;n proceso, a no ser que se asigne el <a href="#1039">c&#243;digo identificador</a> de uno a <strong>camera</strong>. Cuando se haga esto, se denominar&#225; a este proceso como el <strong>proceso c&#225;mara</strong> del scroll.<br/><br/>
<strong>Nota:</strong> A continuaci&#243;n se muestra una serie de campos <strong>s&#243;lo para ventanas de scroll autom&#225;tico</strong>; esto quiere decir que para que dichos campos tengan sentido (y, por consiguiente, efecto) se debe haber definido previamente el campo <strong>camera</strong> de esta estructura con el <a href="#1039">c&#243;digo identificador</a> del proceso que se va a centrar en el scroll. Estos valores afectar&#225;n a la forma en la que se va a hacer este seguimiento al proceso denominado <strong>c&#225;mara del scroll</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>ratio</strong> - <strong>Ventanas de scroll autom&#225;tico</strong>. Cuando se hayan definido dos planos de scroll en la llamada a la funci&#243;n <a href="#163">start_scroll()</a>, en este campo se puede definir la <strong>velocidad de movimiento del plano del fondo</strong> respecto a la del primer plano. Por defecto, este valor ser&#225; <strong>200</strong> lo que implicar&#225; que el plano de fondo se mover&#225; a la mitad de velocidad del primer plano; si se define como <strong>400</strong> se mover&#225; a la cuarta parte (cuatro veces m&#225;s lento), <strong>100</strong> a la misma velocidad, <strong>50</strong> al doble de velocidad que el primer plano, etc.<br/><br/>
<hr/>
<br/><br/>
<strong>speed</strong> - <strong>Ventanas de scroll autom&#225;tico</strong>. Velocidad m&#225;xima del primer plano de scroll, por defecto valdr&#225; <strong>0</strong>, lo que quiere decir que no se impone ning&#250;n l&#237;mite de velocidad. Si se impone un l&#237;mite, especificando el n&#250;mero de puntos m&#225;ximo que puede desplazarse el primer plano por cada imagen del juego, se descentrar&#225; el <strong>proceso c&#225;mara</strong> de la ventana de scroll cuando &#233;ste se mueva a una velocidad mayor.<br/><br/>
<hr/>
<br/><br/>
<strong>region1</strong> - <strong>Ventanas de scroll autom&#225;tico</strong>. Regi&#243;n de bloqueo del scroll, cuyo valor, por defecto, es<strong> -1</strong> lo que implica que no hay ninguna regi&#243;n de bloqueo. Si se define este campo con un n&#250;mero de regi&#243;n (una zona rectangular de la pantalla definida previamente con la funci&#243;n <a href="#106">define_region()</a>), entonces el sistema no mover&#225; el scroll mientras el <strong>proceso c&#225;mara</strong> permanezca dentro de la misma.<br/><br/>
<hr/>
<br/><br/>
<strong>region2</strong> - <strong>Ventanas de scroll autom&#225;tico</strong>. Region exterior del scroll; por defecto su valor es<strong> -1</strong>, lo que implica que no hay una regi&#243;n exterior. Si se define este campo con un n&#250;mero de regi&#243;n y se ha definido una <strong>velocidad m&#225;xima</strong> en el campo <strong>speed</strong>, entonces el sistema ignorar&#225; dicho l&#237;mite de velocidad cuando el proceso<strong> c&#225;mara</strong> vaya a salirse de esta regi&#243;n (&#233;sto se hace para no perder de vista al proceso (para que su gr&#225;fico siempre sea visible dentro de la ventana de scroll).<br/><br/>
<strong>Nota:</strong> Si se definen las dos regiones (<strong>region1</strong> y <strong>region2</strong>), normalmente la regi&#243;n 1 es menor que la regi&#243;n 2 (est&#225; contenida en ella), esto implicar&#225; que:<br/><br/>
- No se desplazar&#225; el gr&#225;fico de fondo (no se har&#225; scroll) mientras el gr&#225;fico del proceso c&#225;mara est&#233; dentro de la regi&#243;n 1.<br/><br/>
- Si se ha definido una velocidad m&#225;xima (<strong>speed</strong>), entonces se har&#225; scroll para intentar devolver el gr&#225;fico del proceso c&#225;mara a la regi&#243;n 1, pero sin sobrepasar el l&#237;mite de velocidad impuesto.<br/><br/>
- Si el gr&#225;fico del proceso c&#225;mara intentara salirse de la regi&#243;n 2, se ignorar&#237;a el l&#237;mite de velocidad impuesto, para no permitirlo.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#163">start_scroll()</a> - <a href="#166">stop_scroll()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1102">GLOBAL STRUCT m7</h2><br/><br/>
<strong>STRUCT m7[9];</strong><br/>
<strong>camera;</strong>   // <a href="#1039">C&#243;digo identificador</a> de la c&#225;mara<br/>
<strong>height;</strong>   // Altura de la c&#225;mara<br/>
<strong>distance;</strong> // Distancia de la c&#225;mara<br/>
<strong>horizon;</strong>  // Altura del horizonte<br/>
<strong>focus;</strong>    // Focal de visi&#243;n<br/>
<strong>z;</strong>        // Plano de profundidad<br/>
<strong>color;</strong>    // Color del exterior<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura de <strong>10</strong> registros contiene ciertos campos relacionados con par&#225;metros modificables de las <strong>ventanas de modo 7</strong>. Los diez registros tienen los mismos nombres de campos, pero cada uno de ellos modifica los par&#225;metros de una ventana de modo 7 diferente (ya que pueden activarse hasta 10 ventanas de este tipo).<br/><br/>
Una <strong>ventana de modo 7</strong> se podr&#237;a definir como una regi&#243;n de pantalla que muestra un plano gr&#225;fico tridimensionalmente abatido. Por ejemplo como una hoja de papel con un dibujo que pusieramos horizontal, visualiz&#225;ndose en pantalla como un suelo (o techo) virtual.<br/><br/>
Para que un registro (del <strong>0</strong> al <strong>9</strong>) de la <strong>estructura m7</strong> tenga sentido, primero debe activarse dicha <strong>ventana de modo 7</strong> (del <strong>0</strong> al <strong>9</strong>) con la funci&#243;n <a href="#162">start_mode7()</a> (ver esta funci&#243;n para m&#225;s informaci&#243;n sobre las ventanas de modo 7}.<br/><br/>
Se entiende que los campos de esta estructura son complementarios a los par&#225;metros de llamada de esta &#250;ltima funci&#243;n. Para poder observar un ejemplo pr&#225;ctico de un modo 7, se puede acceder a la ayuda sobre la funci&#243;n <a href="#162">start_mode7()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Forma de uso de la estructura m7:</strong><br/><br/>
Para acceder a estos campos se debe preceder el nombre del campo por la palabra <strong>m7</strong>, el n&#250;mero de registro entre corchetes y el s&#237;mbolo <a href="#1063">. (punto)</a>.<br/><br/>
Por ejemplo, si se inicializaran dos ventanas de modo 7, la n&#250;mero 0 y la n&#250;mero 1, se podr&#237;a acceder a la variable <strong>camera</strong> de ambas ventanas como <strong>m7[0].camera</strong> y <strong>m7[1].camera</strong>, respectivamente. Cuando se acceda a la ventana n&#250;mero 0 de modo 7 se puede, adem&#225;s, omitir el n&#250;mero de ventanas entre corchetes, es decir, que la variable <strong>m7.camera</strong> y la variable <strong>m7[0].camera</strong> son, a todos los efectos, la misma para el lenguaje.<br/><br/>
<hr/>
<br/><br/>
<strong>Se muestra a continuaci&#243;n una descripci&#243;n detallada de cada campo</strong><br/><br/>
<strong>camera</strong> - <a href="#1039">C&#243;digo identificador del proceso</a> al que sigue la c&#225;mara. Para mover la c&#225;mara que controla la visi&#243;n del modo 7, &#250;nicamente se debe crear un proceso de modo 7, un proceso que tenga su variable local <a href="#1122">ctype</a> <strong>=</strong> <a href="#1169">c_m7</a>, y poner su <a href="#1039">c&#243;digo identificador</a> en la variable <strong>camera</strong> de esta estructura. Tras esto, s&#237;mplemente se deben modificar las variables locales <a href="#1123">x</a>, <a href="#1124">y</a> e <a href="#1129">angle</a> de este proceso y, por ejemplo, utilizar la funci&#243;n <a href="#101">advance()</a> para mover hacia delante la c&#225;mara.<br/><br/>
El campo <strong>camera</strong> es <strong>imprescindible</strong> inicializarlo para que se active la ventana de modo 7; sin este campo, la ventana no puede determinar desde d&#243;nde se debe <strong>ver</strong> el plano abatido.<br/><br/>
<hr/>
<br/><br/>
<strong>height</strong> - Altura de la c&#225;mara. Esta variable de la estructura regula la distancia a la que se sit&#250;a del suelo la c&#225;mara, por defecto su valor es <strong>32</strong>. Cualquier n&#250;mero positivo har&#225; que se sit&#250;e la c&#225;mara m&#225;s arriba cuanto mayor sea el n&#250;mero. Si el valor puesto en el campo <strong>height</strong> de esta misma estructura es negativo, menor que cero, entonces la c&#225;mara se situar&#225; por debajo del plano abatido, mostr&#225;ndose un &quot;<strong>techo</strong>&quot; en lugar de un &quot;<strong>suelo</strong>&quot;.<br/><br/>
Se pueden crear dos modos-7 dentro de la misma regi&#243;n: uno como techo y otro como suelo (uno con <strong>height</strong> positiva y otro negativa). En este caso, es importante fijar la variable <strong>z</strong> de la <a href="#1102">estructura m7</a> de ambos para, de esta forma, determinar en qu&#233; plano de profundidad se debe pintar cada uno.<br/><br/>
<hr/>
<br/><br/>
<strong>distance</strong> - Distancia de la c&#225;mara al proceso seguido. El punto de vista de la c&#225;mara siempre se situar&#225; un poco por detr&#225;s del proceso cuyo identificador se ha puesto en el campo <strong>camera</strong> de la estructura. Esto se hace para que se vea el gr&#225;fico del proceso utilizado como c&#225;mara, en el caso de que este proceso lo tenga definido (en su variable local <a href="#1126">graph</a> o <a href="#1132">xgraph</a>).<br/><br/>
Por defecto, la c&#225;mara se situar&#225; a <strong>64</strong> puntos por detr&#225;s del proceso. Se entiende por &quot;detr&#225;s&quot;, a un punto situado a la distancia indicada del gr&#225;fico en el &#225;ngulo contrario al que est&#233; orientado el proceso; por ejemplo, si el proceso est&#225; mirando a la derecha, 64 puntos a la izquierda del mismo.<br/><br/>
<hr/>
<br/><br/>
<strong>horizon</strong> - Altura del horizonte. &#201;ste es el mismo valor que se indicaba como &#250;ltimo par&#225;metro de la funci&#243;n <strong>start_mode7()</strong>; su valor inicial ser&#225; el que se indic&#243; en la llamada a esta funci&#243;n. La utilidad de esta variable es el poder hacer que suba o baje el horizonte en cada visualizaci&#243;n (imagen) del juego seg&#250;n las necesidades de &#233;ste.<br/><br/>
Al variar la <strong>altura del horizonte</strong> se conseguir&#225; en la <strong>ventana de modo 7</strong> el efecto de &quot;<strong>mirar hacia arriba</strong>&quot; y &quot;<strong>mirar hacia abajo</strong>&quot;.<br/><br/>
<hr/>
<br/><br/>
<strong>focus</strong> - Focal para la c&#225;mara. Esta variable controla la perspectiva de la c&#225;mara; por defecto, su valor es 256 pero se puede poner cualquier valor entre <strong>0</strong> y <strong>512</strong>, consiguiendo diversos efectos de deformaci&#243;n del plano tridimensional.<br/><br/>
Es decir, este campo controla el &#225;ngulo que capta el foco de la c&#225;mara; cuanto mayor sea este valor, m&#225;s cerca se ver&#225;n todos los objetos (procesos) situados en el plano abatido.<br/><br/>
<hr/>
<br/><br/>
<strong>z</strong> - Prioridad de impresi&#243;n del modo 7, aqu&#237; se indica en qu&#233; plano de profundidad se debe pintar esta ventana, respecto al resto de procesos. Por defecto, esta variable valdr&#225; <strong>256</strong> lo cual quiere decir que, como los procesos por defecto tienen su variable <a href="#1125">local z</a> a <strong>0</strong>, la ventana de modo 7 se pintar&#225; en un plano de profundidad mayor, m&#225;s al fondo, visualiz&#225;ndose los gr&#225;ficos de los procesos por encima de la ventana. Para variar esta situaci&#243;n se puede modificar la variable <strong>z</strong> de la ventana (por ejemplo ponerla a<strong> -1</strong>) o la variable <strong>z</strong> de los procesos (por ejemplo ponerla a <strong>257</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>color</strong> - Color para el exterior del modo 7. Cuando en la llamada a la funci&#243;n <strong>start_mode7()</strong> no se especifique ning&#250;n <strong>gr&#225;fico exterior</strong> (se ponga a <strong>0</strong> el cuarto par&#225;metro de llamada), esta variable controlar&#225; de qu&#233; color se quiere pintar el exterior, es decir, de qu&#233; color debe ser la pantalla m&#225;s all&#225; del gr&#225;fico que se est&#225; abatiendo (m&#225;s alla de sus l&#237;mites).<br/><br/>
Este campo est&#225; inicializado por defecto a <strong>0</strong> que, normalmente, es el color negro en la paleta de colores, por lo que, si no se asigna a este campo otro valor (y no se define un gr&#225;fico exterior) se ver&#225; la pantalla en negro m&#225;s all&#225; del plano principal.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#162">start_mode7()</a> - <a href="#165">stop_mode7()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1103">GLOBAL STRUCT joy</h2><br/><br/>
<strong>STRUCT joy;</strong><br/>
<strong>left;</strong>    // Control izquierda<br/>
<strong>right;</strong>   // Control derecha<br/>
<strong>up;</strong>      // Control arriba<br/>
<strong>down;</strong>    // Control abajo<br/>
<strong>button1;</strong> // Primer bot&#243;n<br/>
<strong>button2;</strong> // Segundo bot&#243;n<br/>
<strong>button3;</strong> // Tercer bot&#243;n<br/>
<strong>button4;</strong> // Cuarto bot&#243;n<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura global sirve para controlar el <strong>joystick</strong> (palanca de juegos); contiene una serie de campos l&#243;gicos relacionados con la programaci&#243;n de este dispositivo que son el estado de los botones (si se encuentran pulsados o no) y el estado de las cuatro direcciones de control principales.<br/><br/>
Para acceder a estos campos se debe preceder el nombre del campo por la palabra <strong>joy</strong> y el s&#237;mbolo <a href="#1063">. (punto)</a>, por ejemplo, para acceder al campo <strong>left</strong> (que indica si se est&#225; pulsando el control izquierda) se debe utilizar <strong>joy.left</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>left</strong> - Este campo estar&#225; a <strong>1</strong> cuando el <strong>joystick</strong> est&#233; orientado hacia la <strong>izquierda</strong>, y a <strong>0</strong> en caso contrario.<br/><br/>
<strong>right</strong>  - Este campo estar&#225; a <strong>1</strong> cuando el <strong>joystick</strong> est&#233; orientado hacia la <strong>derecha</strong>, y a <strong>0</strong> en caso contrario.<br/><br/>
<strong>up</strong>  - Este campo estar&#225; a <strong>1</strong> cuando el <strong>joystick</strong> est&#233; orientado hacia <strong>arriba</strong>, y a <strong>0</strong> en caso contrario.<br/><br/>
<strong>down</strong>  - Este campo estar&#225; a <strong>1</strong> cuando el <strong>joystick</strong> est&#233; orientado hacia <strong>abajo</strong>, y a <strong>0</strong> en caso contrario.<br/><br/>
Por ejemplo, para realizar en un programa una acci&#243;n <strong>cuando se mueva el joystick hacia la derecha</strong> (<strong>joy.right</strong>) se debe incluir en el c&#243;digo una sentencia como la siguiente:<br/><br/>
<strong>IF (joy.right)</strong><br/>
// Acci&#243;n a realizar (sentencias)<br/>
<strong>END</strong><br/>
<br/><br/>
Para las posiciones en diagonal se deben comprobar los dos campos que conforman esa diagonal; por ejemplo, para realizar una acci&#243;n cuando el <strong>joystick</strong> est&#233; en la diagonal superior derecha se utilizar&#225; la siguiente sentencia:<br/><br/>
<strong>IF (joy.up AND joy.right)</strong><br/>
// Acci&#243;n a realizar (sentencias)<br/>
<strong>END</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>button1</strong>, <strong>button2</strong>, <strong>button3</strong> y <strong>button4</strong> - Estos campos indican el estado de hasta cuatro botones del joystick, estando a <strong>1</strong> cuando el bot&#243;n respectivo est&#233; pulsado, y a <strong>0</strong> cuando no lo est&#233;.<br/><br/>
Algunos joystick s&#243;lo tienen 2 botones; en este caso, ser&#225;n los botones n&#250;mero 0 y 1. En ordenadores con dos joystick conectados el segundo joystick tendr&#225; los botones n&#250;mero 2 y 3.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Cuando se requiera una lectura anal&#243;gica del <strong>joystick</strong> (conocer las coordenadas exactas en las que est&#225; situada la &quot;palanca&quot; del joystick), se deber&#225; utilizar la funci&#243;n <a href="#122">get_joy_position()</a>. Obviamente, esta funci&#243;n ser&#225; util &#250;nicamente en <strong>joystick</strong> anal&#243;gicos, no funcionando en los digitales.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#122">get_joy_position()</a> - <a href="#121">get_joy_button()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1104">GLOBAL STRUCT setup</h2><br/><br/>
<strong>STRUCT setup;</strong><br/>
<strong>card;</strong>     // Tipo de tarjeta<br/>
<strong>port;</strong>     // Puerto de acceso<br/>
<strong>irq;</strong>      // Interrupci&#243;n requerida<br/>
<strong>dma;</strong>      // Canal de acceso a memoria<br/>
<strong>dma2;</strong>     // Canal de acceso de 16 bit<br/>
<strong>mixer;</strong>    // Tipo de mezclador<br/>
<strong>rate;</strong>     // Frecuencia m&#225;xima (bitrate)<br/>
<strong>bits;</strong>     // Calidad 8 o 16 bits<br/>
<strong>master;</strong>   // Volumen maestro (general)<br/>
<strong>sound_fx;</strong> // Volumen de los efectos<br/>
<strong>cd_audio;</strong> // Volumen de m&#250;sica CD<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura de datos es de nivel muy avanzado y no es en absoluto necesaria para crear ning&#250;n juego, por complejo que &#233;ste sea, ya que el gestor de procesos de DIV Games Studio se encargar&#225;, normalmente, del hardware de sonido de forma transparente.<br/><br/>
Todos los campos referentes al hardware de sonido se actualizan de manera autom&#225;tica por el programa si se tiene una tarjeta de sonido, siempre y cuando se tenga la variable de entorno <strong>BLASTER</strong> o <strong>GRAVIS</strong> debidamente inicializada.<br/><br/>
Esta estructura de un &#250;nico registro contiene una serie de campos divididos en dos grupos: los primeros para activar nuevos par&#225;metros del hardware de sonido instalado en el ordenador y los segundos para ajustar los diferentes controles de volumen gestionados por el mezclador (<strong>mixer</strong>) del sistema de sonido.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong><br/><br/>
Para activar los nuevos par&#225;metros del hardware de sonido que se introduzcan en esta estructura se debe llamar a la funci&#243;n <a href="#175">reset_sound()</a>.<br/><br/>
Para activar los nuevos niveles de volumen que se introduzcan en la estructura (en los campos <strong>master</strong>, <strong>sound_fx</strong> y <strong>cd_audio</strong>) se debe llamar a la funci&#243;n <a href="#178">set_volume()</a>.<br/><br/>
Esta estructura se utiliza generalmente dentro de los programas de configuraci&#243;n del sistema de sonido (ver <a href="#1093">setup_program</a>).<br/><br/>
<strong>Nota:</strong> Para acceder a estos campos se debe preceder el nombre del campo por la palabra <strong>setup</strong> y el s&#237;mbolo <a href="#1063">. (punto)</a>; por ejemplo, para acceder al campo <strong>master</strong> (que indica el nivel de volumen general del mezclador) se debe utilizar <strong>setup.master</strong>.<br/><br/>
<hr/>
<br/><br/>
Se muestra, a continuaci&#243;n, una descripci&#243;n algo m&#225;s detallada de cada uno de los campos de esta estructura.<br/><br/>
<strong>card</strong> - Indica el tipo de tarjeta de sonido instalada en el ordenador. El programa admite tarjetas de las familias <strong>Sound Blaster</strong> (tm) y <strong>Gravis Ultra Sound</strong> (tm) y todas las que sean compatibles <strong>100%</strong> con &#233;stas.<br/><br/>
Los valores que puede tomar este campo son los siguientes, depediendo del tipo de tarjeta de sonido:<br/><br/>
Sin tarjeta o sin sonido = <strong>0</strong><br/>
Sound Blaster 1.5        = <strong>1</strong><br/>
Sound Blaster 2.0        = <strong>2</strong><br/>
Sound Blaster Pro        = <strong>3</strong><br/>
Sound Blaster 16         = <strong>4</strong><br/>
Sound Blaster AWE        = <strong>5</strong><br/>
Gravis Ultra Sound       = <strong>6</strong><br/>
Gravis Ultra Sound MAX   = <strong>7</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>port</strong> - Indica el puerto de comunicaciones del ordenador en el cual se deben escribir y leer los datos de la tarjeta de sonido.<br/><br/>
Los valores que puede tomar este campo son los siguientes, dependiendo del puerto asignado al hardware de sonido:<br/><br/>
0x210 = <strong>0</strong><br/>
0x220 = <strong>1</strong><br/>
0x230 = <strong>2</strong><br/>
0x240 = <strong>3</strong><br/>
0x250 = <strong>4</strong><br/>
0x260 = <strong>5</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>irq</strong> - Este campo indica el n&#250;mero de interrupci&#243;n o IRQ (Interrupt request) asignado a la tarjeta de sonido activa.<br/><br/>
Los valores que puede tomar este campo son, dependiendo de la interrupci&#243;n utilizada por la tarjeta, los siguientes:<br/><br/>
IRQ 2   = <strong>0</strong><br/>
IRQ 3   = <strong>1</strong><br/>
IRQ 5   = <strong>2</strong><br/>
IRQ 7   = <strong>3</strong><br/>
IRQ 10  = <strong>4</strong><br/>
IRQ 11  = <strong>5</strong><br/>
IRQ 12  = <strong>6</strong><br/>
IRQ 13  = <strong>7</strong><br/>
IRQ 14  = <strong>8</strong><br/>
IRQ 15  = <strong>9</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>dma</strong> - En este campo se debe indicar el n&#250;mero de canal de acceso directo a memoria (DMA) que utiliza la tarjeta de sonido.<br/><br/>
Este campo puede tomar valores de 0 a 10, dependiendo directamente del n&#250;mero de canal.<br/><br/>
<hr/>
<br/><br/>
<strong>dma2</strong> - Algunas tarjetas de sonido tienen disponible un segundo canal de acceso directo a memoria m&#225;s r&#225;pido que el anterior, de 16 bits, denominado com&#250;nmente HDMA, DMA2 o DMA16.<br/><br/>
Como el campo anterior de esta estructura, &#233;ste podr&#225; tomar valores del 0 al 10 dependiendo del n&#250;mero de canal de 16 bits utilizado por la tarjeta.<br/><br/>
<hr/>
<br/><br/>
<strong>mixer</strong> - Tipo de mezclador utilizado por el sistema de sonido, puede ser una de estas dos constantes:<br/><br/>
<strong>fast_mixer</strong> - Mezclador r&#225;pido de los canales de sonido (1).<br/>
<strong>quality_mixer</strong> - Mezclador de calidad m&#225;xima (2).<br/>
<br/><br/>
Por defecto, todos los programas tendr&#225;n activado el mezclador r&#225;pido (<strong>setup.mixer=fast_mixer;</strong>) ya que este es el modo m&#225;s r&#225;pido, y la diferencia de calidad no es muy grande.<br/><br/>
<hr/>
<br/><br/>
<strong>rate</strong> - Frecuencia m&#225;xima permitida (bit rate), entre <strong>11025</strong> (calidad de sonido m&#237;nima permitida) y <strong>44100</strong> (calidad CD). Por defecto, todos los programas se configuran a 44100 (<strong>setup.rate=44100;</strong>), no obstante esto puede cambiarse, ya que a mayor calidad, m&#225;s lento ser&#225; el sistema de sonido, y m&#225;s tiempo de procesador consume.<br/><br/>
Se entiende que el valor especificado en <strong>setup.rate</strong> es la <strong>calidad m&#225;xima</strong> de sonido, lo que quiere decir que todos los efectos de sonido cargados se adaptar&#225;n a esta calidad en caso de tener una mayor. Es decir, que los efectos grabados a una frecuencia de 11025 seguir&#225;n sonando con calidad pobre, aunque la frecuencia m&#225;xima permitida sea mayor.<br/><br/>
<hr/>
<br/><br/>
<strong>bits</strong> - Resoluci&#243;n de las muestras de los efectos digitales y m&#243;dulos musicales, este campo puede tener uno de estas dos constantes como valores:<br/><br/>
<strong>sound_bits_8</strong> - Muestras de 8 bit.<br/>
<strong>sound_bits_16</strong> - Muestras de 16 bit.<br/>
<br/><br/>
El efecto es similar al valor especificado en el campo <strong>rate</strong>, los sonidos con <strong>8 bit</strong> suenan peor (tambi&#233;n ocupan menos espacio) y los de <strong>16 bit</strong> son de m&#225;s calidad. El valor indicado en <strong>setup.bits</strong> indicar&#225; la profundidad de muestra m&#225;xima.<br/><br/>
Por defecto, todos los programas activar&#225;n las muestras de <strong>16 bit</strong> ({setup.bits=sound_bits_8;)), ya que la diferencia de calidad es m&#225;s que notable.<br/><br/>
<hr/>
<br/><br/>
<strong>master</strong> - Este campo contiene el volumen general o maestro de salida de la tarjeta. Aqu&#237; se debe indicar un n&#250;mero entre 0 (volumen m&#237;nimo) y 15 (volumen m&#225;ximo). El valor por defecto es <strong>15</strong>, el volumen m&#225;ximo.<br/><br/>
Si se disminuye el volumen maestro afectar&#225; tanto al volumen de los efectos de sonido como al volumen de reproducci&#243;n de la m&#250;sica de cd audio.<br/><br/>
<hr/>
<br/><br/>
<strong>sound_fx</strong> - Este campo controla el volumen al que los efectos de sonido que se ejecutan con la funci&#243;n <a href="#159">sound()</a> son reproducidos.<br/><br/>
Este volumen es independiente del utilizado con las funciones de sonido siendo, este volumen, general para todos los efectos de sonido y el indicado en las funciones el espec&#237;fico para cada sonido.<br/><br/>
Este campo tambi&#233;n puede oscilar entre 0 (volumen m&#237;nimo) y 15 (volumen m&#225;ximo), siendo el valor por defecto el volumen m&#225;ximo.<br/><br/>
<hr/>
<br/><br/>
<strong>cd_audio</strong> - Este campo controla el volumen de la m&#250;sica que ser&#225; reproducida a partir de pistas de audio de un CD ROM o de un Compact Disc.<br/><br/>
Al igual que los dos campos anteriores, este campo tambi&#233;n puede oscilar entre 0 (volumen m&#237;nimo) y 15 (volumen m&#225;ximo) siendo el valor por defecto el volumen m&#225;ximo.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#175">reset_sound()</a> - <a href="#178">set_volume()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1105">GLOBAL timer[]</h2><br/><br/>
<strong>timer[9];</strong> // Contadores de tiempo<hr/>
<br/><br/>
&#201;sta es una tabla global con 10 posiciones, desde <strong>timer[0]</strong> hasta <strong>timer[9]</strong>, y cada una de estas 10 posiciones es un contador de <strong>cent&#233;simas de segundo</strong> que se va incrementando autom&#225;ticamente.<br/><br/>
Al comienzo del programa estos 10 contadores ser&#225;n puestos a cero. Se utilizan para cronometrar tiempos dentro de un programa, para lo que pueden ser puestos a cero en cualquier momento.<br/><br/>
Se dispone de 10 contadores para que el usuario pueda dedicar cada uno de ellos a realizar una cuenta diferente dentro del juego; es indiferente cu&#225;les de los 10 contadores se utilicen. Normalmente, si el programa necesita un s&#243;lo contador (en la mayor&#237;a de ocasiones) se suele utilizar el n&#250;mero <strong>0</strong> (<strong>timer[0]</strong>), ya que el lenguaje permite omitir el cero entre corchetes en este caso, es decir, si &#250;nicamente se necesita un contador, se puede utilizar simplemente <strong>timer</strong>.<br/><br/>
Por ejemplo, para implementar un proceso que a los 5 segundos del inicio de su ejecuci&#243;n (de haberlo llamado) realizara una acci&#243;n determinada, se construir&#237;a el mismo de una forma similar a &#233;sta (utilizando, por ejemplo, el contador timer[9]):<br/><br/>
<strong>PROCESS proceso_ejemplo();</strong><br/>
<strong>BEGIN</strong><br/>
<strong>timer[9]=0;</strong><br/>
// ...<br/>
<strong>LOOP</strong><br/>
<strong>IF (timer[9]&gt;=500)</strong><br/>
// Acci&#243;n a realizar ...<br/>
<strong>END</strong><br/>
// ...<br/>
<strong>FRAME;</strong><br/>
<strong>END</strong><br/>
<strong>END</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> Como la cuenta se realiza en cent&#233;simas de segundo, en cada imagen del juego estos contadores se pueden incrementar en <strong>1</strong> cent&#233;sima, <strong>2</strong>, <strong>3</strong>, <strong>4</strong>, etc., es decir, en un ejemplo como el anterior no se puede esperar a que <strong>timer[9]</strong> sea exactamente igual a <strong>500</strong>, ya que una imagen podr&#237;a indicar <strong>497</strong> cent&#233;simas transcurridas (desde su puesta a cero con <strong>timer[9]=0;</strong>) y la siguiente imagen <strong>502</strong> cent&#233;simas, sin haber pasado por el valor <strong>500</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 2:</strong> Es tambi&#233;n importante resaltar que se deben tomar precauciones para que no haya en el programa varios procesos utilizando el mismo contador para diferentes fines.<br/><br/>
Si, por ejemplo, se creara un <strong>proceso_ejemplo()</strong> (como el anterior), en cada imagen del juego &#233;stos no llegar&#237;an nunca a ejecutar la acci&#243;n de los cinco segundos, ya que cada uno de ellos pondr&#237;a a <strong>0</strong> el contador <strong>timer[9]</strong> al comienzo de su ejecuci&#243;n invalidando, de esta forma, la cuenta de los procesos anteriores.<br/><br/>
Teniendo en cuenta que el contador timer[9] es <a href="#1006">GLOBAL</a>, es decir, es el mismo para todos los procesos del juego, si un proceso lo pone a <strong>0</strong>, lo pondr&#225; a <strong>0</strong> para el resto de los procesos.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 3:</strong> Por &#250;ltimo se debe tener cuidado con las condiciones similares a la del ejemplo anterior (<strong>IF (timer[9]&gt;=500) ... </strong>) ya que estas condiciones no se activar&#225;n &#250;nicamente <strong>una vez a los 5 segundos</strong>, sino que se activar&#225;n <strong>todas las veces despu&#233;s de los primeros 5 segundos</strong>.<br/><br/>
Para poder comprender mejor el problema, se muestra a continuaci&#243;n un proceso que realiza una acci&#243;n, <strong>&#250;nicamente una vez</strong>, a los cinco segundos de haberse iniciado su ejecuci&#243;n.<br/><br/>
<strong>PROCESS proceso_ejemplo();</strong><br/>
<br/><br/>
<strong>PRIVATE</strong><br/>
<strong>acci&#243;n_realizada=FALSE;</strong><br/>
<br/><br/>
<strong>BEGIN</strong><br/>
<strong>timer[9]=0;</strong><br/>
// ...<br/>
<strong>LOOP</strong><br/>
<strong>IF (timer[9]&gt;=500) AND NOT acci&#243;n_realizada)</strong><br/>
// Acci&#243;n a realizar ...<br/>
<strong>acci&#243;n_realizada=TRUE;</strong><br/>
<strong>END</strong><br/>
// ...<br/>
<strong>FRAME;</strong><br/>
<strong>END</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Se utiliza una variable privada denominada <strong>acci&#243;n_realizada</strong> que, en un principio, ser&#225; <strong>falsa</strong>. Para realizar la acci&#243;n ahora se requerir&#225; que hayan pasado m&#225;s de cinco segundos y que <strong>no se haya realizado ya la acci&#243;n</strong>. Tras realizar &#233;sta, se pondr&#225; por tanto la variable <strong>acci&#243;n_realizada</strong> a <strong>cierto</strong>.<br/><br/>
Para que el ejemplo anterior ejecutara la acci&#243;n <strong>cada cinco segundos</strong> (indefinidamente), bastar&#237;a con volver a poner la sentencia <strong>timer[9]=0;</strong> tras la <strong>acci&#243;n a realizar</strong>, no siendo necesaria, en esta caso, la variable privada <strong>acci&#243;n_realizada</strong> ya que se necesitar&#237;an otros <strong>5</strong> segundos para que <strong>timer[9]</strong> fuera otra vez mayor o igual que <strong>500</strong>.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1106">GLOBAL text_z</h2><br/><br/>
<strong>text_z=-256;</strong> // Plano de profundidad de los textos<hr/>
<br/><br/>
En esta variable global se indica el plano de profundidad en el que deben aparecer los textos en pantalla, esto es, qu&#233; debe aparecer por encima de los textos y qu&#233; por debajo.<br/><br/>
Los planos de profundidad pueden ser cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>) y, cuanto mayor sea el n&#250;mero, m&#225;s al fondo se situar&#225; el texto o gr&#225;fico.<br/><br/>
Los gr&#225;ficos de los procesos tienen su variable <a href="#1125">local z</a> a <strong>0</strong> por defecto, los textos <strong>text_z</strong> a<strong> -256</strong> y el puntero del rat&#243;n tiene <a href="#1100">mouse.z</a> a<strong> -512</strong> por defecto.<br/><br/>
Esto quiere decir que, por defecto, si no se no modifican estos valores, aparecer&#225;n los textos sobre los gr&#225;ficos de los procesos y el puntero del rat&#243;n sobre los textos.<br/><br/>
Si, por ejemplo, se quisiera que aparecieran los textos sobre el puntero del rat&#243;n (al rev&#233;s de lo establecido por defecto), se podr&#237;an hacer dos cosas:<br/><br/>
<strong>a)</strong> Situar el plano del puntero m&#225;s abajo que el plano de los textos (un n&#250;mero mayor), como por ejemplo: <strong>mouse.z=-200;</strong> (ya que<strong> -200</strong> es un n&#250;mero mayor que<strong> -256</strong>).<br/><br/>
<strong>b)</strong> Situar el plano de los textos m&#225;s arriba que el plano del puntero, como por ejemplo <strong>text_z=-600;</strong> ya que<strong> -600</strong> es un n&#250;mero menor que<strong> -512</strong> y, por tanto, un plano de profundidad menor (menos profundo).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> La variable <strong>text_z</strong> es <a href="#1006">GLOBAL</a> para todos los textos, es decir, no se pueden definir textos en diferentes planos de profundidad.<br/><br/>
<strong>Nota 2:</strong> Los textos &#250;nicamente pueden imprimirse con la funci&#243;n <a href="#171">write()</a> (textos alfanum&#233;ricos) o con la funci&#243;n <a href="#172">write_int()</a> (valores num&#233;ricos de variables).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#171">write()</a> - <a href="#172">write_int()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1107">GLOBAL fading</h2><br/><br/>
<strong>fading=FALSE;</strong> // Indicador de fundido de pantalla<hr/>
<br/><br/>
Esta variable global indica si se est&#225; realizando un fundido de pantalla (una variaci&#243;n gradual de la paleta de colores del juego) en un momento determinado, cuyo valor ser&#225;:<br/><br/>
<a href="#1152">false (0)</a> - Si <strong>no</strong> se est&#225; realizando un fundido.<br/><br/>
<a href="#1151">true (1)</a> - Si se est&#225; realizando un fundido.<br/><br/>
La finalidad de esta variable es poder determinar cu&#225;ndo ha finalizado un fundido de pantalla iniciado con las funciones <a href="#110">fade()</a> o <a href="#112">fade_on()</a>.<br/><br/>
Al utilizar estas funciones se iniciar&#225; un fundido de los colores de la paleta que se ir&#225;n acercando gradualmente a los colores definitivos en las siguientes im&#225;genes del juego, es decir, cada sentencia <a href="#1029">FRAME</a> se realizar&#225; una parte del fundido.<br/><br/>
Cuando se inicie un fundido, la variable <strong>fading</strong> pasar&#225; autom&#225;ticamente a valer <strong>cierto</strong> (1) y al finalizar &#233;ste, volver&#225; de nuevo a su valor original, <strong>falso</strong> (0).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> Generalmente, esta variable se utiliza para controlar a la funci&#243;n <a href="#110">fade()</a>, y comprobar si ha terminado de ejecutarse (si ha terminado de realizarse el fundido); cuando se quiera, por ejemplo, detener la ejecuci&#243;n del programa hasta que finalice el fundido, lo que se puede hacer con una sentencia como la siguiente (justo a continuaci&#243;n de la llamada a la funci&#243;n <a href="#110">fade()</a>):<br/><br/>
<strong>WHILE (fading)</strong><br/>
<strong>FRAME;</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Literalmente esta sentencia define: &quot;<strong>mientras contin&#250;e realiz&#225;ndose el fundido, se debe visualizar otra nueva imagen</strong>&quot;.<br/><br/>
<strong>Nota 2:</strong> Todos los programas realizan un fundido (<a href="#112">fade_on()</a>) al inicio de su ejecuci&#243;n (autom&#225;ticamente), por lo que esta variable se pondr&#225; a <strong>cierto (1)</strong> al inicio de todos los programas hasta que finalice este fundido inicial (mientras dure el &quot;<strong>encendido</strong>&quot; de pantalla).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#110">fade()</a> - <a href="#112">fade_on()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1108">GLOBAL shift_status</h2><br/><br/>
<strong>shift_status=0;</strong> // Estado de las teclas especiales<hr/>
<br/><br/>
En esta variable global predefinida se indica el estado de distintas teclas especiales como pueden ser las teclas [<strong>ALT</strong>], [<strong>CONTROL</strong>], etc.<br/><br/>
Cada una de estas teclas tiene asignado un c&#243;digo que es el siguiente:<br/><br/>
Tecla SHIFT o may&#250;sculas derecho          = <strong>1</strong><br/>
Tecla SHIFT o may&#250;sculas izquierdo        = <strong>2</strong><br/>
Teclas CONTROL                            = <strong>4</strong><br/>
Teclas ALT y/o ALT GR                     = <strong>8</strong><br/>
Tecla BLOQ DESPL o bloqueo desplazamiento = <strong>16</strong><br/>
Tecla BLOQ NUM o de bloque num&#233;rico       = <strong>32</strong><br/>
Tecla BLOQ MAYUS o bloqueo de may&#250;sculas  = <strong>64</strong><br/>
Tecla INSERT o inserci&#243;n                  = <strong>128</strong><br/>
<br/><br/>
La variable <strong>shift_status</strong> contendr&#225; la <strong>suma de todos los c&#243;digos de las teclas que est&#233;n pulsadas o activadas</strong>.<br/><br/>
Por ejemplo, si estuviera pulsada la tecla [<strong>ALT</strong>] y activada la tecla [<strong>BLOQ MAYUS</strong>], la variable <strong>shift_status</strong> tendr&#237;a el valor <strong>72</strong> (8+64).<br/><br/>
Para comprobar si una tecla como [<strong>ALT</strong>] est&#225; pulsada, no se puede comprobar que <strong>shift_status</strong> sea igual a <strong>8</strong>, ya que &#233;sto implicar&#237;a que [<strong>ALT</strong>] es la <strong>&#250;nica</strong> tecla especial que est&#225; pulsada o activada.<br/><br/>
Para realizar esta comprobaci&#243;n correctamente se deber&#237;a realizar de la siguiente forma:<br/><br/>
<strong>IF (shift_status AND 8 == 8)</strong><br/>
// Est&#225; pulsada la tecla [ALT] ...<br/>
<strong>END</strong><br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Normalmente, para comprobar si una tecla est&#225; pulsada, se utiliza la funci&#243;n <a href="#128">key()</a>. Pero con esta funci&#243;n no se puede determinar si teclas como <strong>BLOQ MAYUS</strong> est&#225;n activadas, &#250;nicamente si est&#225;n pulsadas o no.<br/><br/>
Existen dos variables que contienen el c&#243;digo de la &#250;ltima tecla que se ha pulsado; <a href="#1110">scan_code</a> (c&#243;digo <strong>scan</strong> de la &#250;ltima tecla pulsada) y <a href="#1109">ascii</a> (c&#243;digo <strong>ascii</strong> de la &#250;ltima tecla pulsada).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#128">key()</a> - <a href="#1109">ascii</a> - <a href="#1110">scan_code</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1109">GLOBAL ascii</h2><br/><br/>
<strong>ascii=0;</strong> // C&#243;digo ASCII de la &#250;ltima tecla pulsada<hr/>
<br/><br/>
Esta variable global indica siempre el c&#243;digo ASCII de la <strong>&#250;ltima tecla pulsada</strong> en la &#250;ltima imagen del juego.<br/><br/>
La variable <strong>ascii</strong> estar&#225; a <strong>0</strong> si no se ha pulsado ninguna tecla en la imagen anterior del juego.<br/><br/>
Los c&#243;digos ASCII son una relaci&#243;n de car&#225;cteres (letras, n&#250;meros y s&#237;mbolos) enumerados del <strong>0</strong> al <strong>255</strong> que se han convertido en est&#225;ndar. Los c&#243;digos inferiores al 32 son los denominados car&#225;cteres de control, del 32 al 127 son el juego de car&#225;cteres internacional y, a partir del n&#250;mero 128, aparece el juego de car&#225;cteres extendido (seg&#250;n el est&#225;ndar de PC). A continuaci&#243;n, se muestran los car&#225;cteres ASCII internacionales y extendidos.<br/><br/>
<strong>Resumen de c&#243;digos ASCII est&#225;ndar del PC</strong><hr/>
033 21<strong> !</strong>│097 61<strong> a</strong>│161 A1<strong> &#237;</strong>│225 E1<strong> &#223;</strong><br/>
034 22<strong> &quot;</strong>│098 62<strong> b</strong>│162 A2<strong> &#243;</strong>│226 E2<strong> Γ</strong><br/>
035 23<strong> #</strong>│099 63<strong> c</strong>│163 A3<strong> &#250;</strong>│227 E3<strong> π</strong><br/>
036 24<strong> $</strong>│100 64<strong> d</strong>│164 A4<strong> &#241;</strong>│228 E4<strong> Σ</strong><br/>
037 25<strong> %</strong>│101 65<strong> e</strong>│165 A5<strong> &#209;</strong>│229 E5<strong> σ</strong><br/>
038 26<strong> &amp;</strong>│102 66<strong> f</strong>│166 A6<strong> &#170;</strong>│230 E6<strong> &#181;</strong><br/>
039 27<strong> &#39;</strong>│103 67<strong> g</strong>│167 A7<strong> &#186;</strong>│231 E7<strong> τ</strong><br/>
040 28<strong> (</strong>│104 68<strong> h</strong>│168 A8<strong> &#191;</strong>│232 E8<strong> Φ</strong><br/>
041 29<strong> )</strong>│105 69<strong> i</strong>│169 A9<strong> ⌐</strong>│233 E9<strong> Θ</strong><br/>
042 2A<strong> *</strong>│106 6A<strong> j</strong>│170 AA<strong> &#172;</strong>│234 EA<strong> Ω</strong><br/>
043 2B<strong> +</strong>│107 6B<strong> k</strong>│171 AB<strong> &#189;</strong>│235 EB<strong> δ</strong><br/>
044 2C<strong> ,</strong>│108 6C<strong> l</strong>│172 AC<strong> &#188;</strong>│236 EC<strong> ∞</strong><br/>
045 2D<strong> -</strong>│109 6D<strong> m</strong>│173 AD<strong> &#161;</strong>│237 ED<strong> φ</strong><br/>
046 2E<strong> .</strong>│110 6E<strong> n</strong>│174 AE<strong> &#171;</strong>│238 EE<strong> ε</strong><br/>
047 2F<strong> /</strong>│111 6F<strong> o</strong>│175 AF<strong> &#187;</strong>│239 EF<strong> ∩</strong><br/>
048 30<strong> 0</strong>│112 70<strong> p</strong>│176 B0<strong> ░</strong>│240 F0<strong> ≡</strong><br/>
049 31<strong> 1</strong>│113 71<strong> q</strong>│177 B1<strong> ▒</strong>│241 F1<strong> &#177;</strong><br/>
050 32<strong> 2</strong>│114 72<strong> r</strong>│178 B2<strong> ▓</strong>│242 F2<strong> ≥</strong><br/>
051 33<strong> 3</strong>│115 73<strong> s</strong>│179 B3<strong> │</strong>│243 F3<strong> ≤</strong><br/>
052 34<strong> 4</strong>│116 74<strong> t</strong>│180 B4<strong> ┤</strong>│244 F4<strong> ⌠</strong><br/>
053 35<strong> 5</strong>│117 75<strong> u</strong>│181 B5<strong> ╡</strong>│245 F5<strong> ⌡</strong><br/>
054 36<strong> 6</strong>│118 76<strong> v</strong>│182 B6<strong> ╢</strong>│246 F6<strong> &#247;</strong><br/>
055 37<strong> 7</strong>│119 77<strong> w</strong>│183 B7<strong> ╖</strong>│247 F7<strong> ≈</strong><br/>
056 38<strong> 8</strong>│120 78<strong> x</strong>│184 B8<strong> ╕</strong>│248 F8<strong> &#176;</strong><br/>
057 39<strong> 9</strong>│121 79<strong> y</strong>│185 B9<strong> ╣</strong>│249 F9<strong> ∙</strong><br/>
058 3A<strong> :</strong>│122 7A<strong> z</strong>│186 BA<strong> ║</strong>│250 FA<strong> ∙</strong><br/>
059 3B<strong> ;</strong>│123 7B<strong> {{</strong>}│187 BB<strong> ╗</strong>│251 FB<strong> √</strong><br/>
060 3C<strong> &lt;</strong>│124 7C<strong> |</strong>│188 BC<strong> ╝</strong>│252 FC<strong> ⁿ</strong><br/>
061 3D<strong> =</strong>│125 7D<strong> {</strong>}}│189 BD<strong> ╜</strong>│253 FD<strong> &#178;</strong><br/>
062 3E<strong> &gt;</strong>│126 7E<strong> ~</strong>│190 BE<strong> ╛</strong>│254 FE<strong> ■</strong><br/>
063 3F<strong> ?</strong>│127 7F<strong> </strong>│191 BF<strong> ┐</strong>│255 FF<strong> &#160;</strong><br/>
064 40<strong> @</strong>│128 80<strong> &#199;</strong>│192 C0<strong> └</strong><br/>
065 41<strong> A</strong>│129 81<strong> &#252;</strong>│193 C1<strong> ┴</strong><br/>
066 42<strong> B</strong>│130 82<strong> &#233;</strong>│194 C2<strong> ┬</strong><br/>
067 43<strong> C</strong>│131 83<strong> &#226;</strong>│195 C3<strong> ├</strong><br/>
068 44<strong> D</strong>│132 84<strong> &#228;</strong>│196 C4<strong> ─</strong><br/>
069 45<strong> E</strong>│133 85<strong> &#224;</strong>│197 C5<strong> ┼</strong><br/>
070 46<strong> F</strong>│134 86<strong> &#229;</strong>│198 C6<strong> ╞</strong><br/>
071 47<strong> G</strong>│135 87<strong> &#231;</strong>│199 C7<strong> ╟</strong><br/>
072 48<strong> H</strong>│136 88<strong> &#234;</strong>│200 C8<strong> ╚</strong><br/>
073 49<strong> I</strong>│137 89<strong> &#235;</strong>│201 C9<strong> ╔</strong><br/>
074 4A<strong> J</strong>│138 8A<strong> &#232;</strong>│202 CA<strong> ╩</strong><br/>
075 4B<strong> K</strong>│139 8B<strong> &#239;</strong>│203 CB<strong> ╦</strong><br/>
076 4C<strong> L</strong>│140 8C<strong> &#238;</strong>│204 CC<strong> ╠</strong><br/>
077 4D<strong> M</strong>│141 8D<strong> &#236;</strong>│205 CD<strong> ═</strong><br/>
078 4E<strong> N</strong>│142 8E<strong> &#196;</strong>│206 CE<strong> ╬</strong><br/>
079 4F<strong> O</strong>│143 8F<strong> &#197;</strong>│207 CF<strong> ╧</strong><br/>
080 50<strong> P</strong>│144 90<strong> &#201;</strong>│208 D0<strong> ╨</strong><br/>
081 51<strong> Q</strong>│145 91<strong> &#230;</strong>│209 D1<strong> ╤</strong><br/>
082 52<strong> R</strong>│146 92<strong> &#198;</strong>│210 D2<strong> ╥</strong><br/>
083 53<strong> S</strong>│147 93<strong> &#244;</strong>│211 D3<strong> ╙</strong><br/>
084 54<strong> T</strong>│148 94<strong> &#246;</strong>│212 D4<strong> ╘</strong><br/>
085 55<strong> U</strong>│149 95<strong> &#242;</strong>│213 D5<strong> ╒</strong><br/>
086 56<strong> V</strong>│150 96<strong> &#251;</strong>│214 D6<strong> ╓</strong><br/>
087 57<strong> W</strong>│151 97<strong> &#249;</strong>│215 D7<strong> ╫</strong><br/>
088 58<strong> X</strong>│152 98<strong> &#255;</strong>│216 D8<strong> ╪</strong><br/>
089 59<strong> Y</strong>│153 99<strong> &#214;</strong>│217 D9<strong> ┘</strong><br/>
090 5A<strong> Z</strong>│154 9A<strong> &#220;</strong>│218 DA<strong> ┌</strong><br/>
091 5B<strong> [</strong>│155 9B<strong> &#162;</strong>│219 DB<strong> █</strong><br/>
092 5C<strong> \</strong>│156 9C<strong> &#163;</strong>│220 DC<strong> ▄</strong><br/>
093 5D<strong> ]</strong>│157 9D<strong> &#165;</strong>│221 DD<strong> ▌</strong><br/>
094 5E<strong> ^</strong>│158 9E<strong> ₧</strong>│222 DE<strong> ▐</strong><br/>
095 5F<strong> _</strong>│159 9F<strong> ƒ</strong>│223 DF<strong> ▀</strong><br/>
096 60<strong> `</strong>│160 A0<strong> &#225;</strong>│224 E0<strong> α</strong><hr/>
<br/><br/>
Un c&#243;digo ASCII hace referencia, por tanto, al <strong>car&#225;cter que ha sido producido con la &#250;ltima pulsaci&#243;n del teclado</strong> (o combinaci&#243;n de pulsaciones, en casos como los de las letras acentuadas).<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Existe otra variable global predefinida, denominada <a href="#1110">scan_code</a>, que tambi&#233;n contiene el c&#243;digo de la &#250;ltima tecla pulsada pero, a diferencia de <strong>ascii</strong>, &#233;sta &#250;ltima guarda el <strong>c&#243;digo de rastreo</strong> (scan code) de la tecla, es decir, indica <strong>qu&#233; tecla ha sido pulsada</strong> y no <strong>qu&#233; car&#225;cter ha sido generado</strong> por la misma (como <strong>ascii</strong>).<br/><br/>
Existe una serie de constantes que designan estos <a href="#1176">c&#243;digos de teclas</a> (c&#243;digos de rastreo del teclado). Acceda a la ayuda sobre estos <a href="#1176">c&#243;digos de teclas</a> para observar, adem&#225;s, un <strong>programa ejemplo</strong> con las variables <strong>ascii</strong> y <strong>scan_code</strong>.<br/><br/>
Normalmente, para comprobar si una tecla est&#225; siendo pulsada, se utiliza simplemente la funci&#243;n <a href="#128">key()</a> del lenguaje, que recibe como par&#225;metro uno de estos <a href="#1176">c&#243;digos de teclas</a>, y devuelve <strong>0</strong> si la tecla no est&#225; pulsada o <strong>1</strong> cuando s&#237; lo est&#225;.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1110">scan_code</a> - <a href="#128">key()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1110">GLOBAL scan_code</h2><br/><br/>
<strong>scan_code=0;</strong> // C&#243;digo de rastreo de la &#250;ltima tecla pulsada<hr/>
<br/><br/>
Esta variable global indica siempre el c&#243;digo de rastreo (scan code) de la <strong>&#250;ltima tecla pulsada</strong> en la &#250;ltima imagen del juego.<br/><br/>
La variable <strong>scan_code</strong> estar&#225; a <strong>0</strong> si no se ha pulsado ninguna tecla en la imagen anterior del juego.<br/><br/>
Se utiliza muchas veces esta variable para esperar en un programa a que el usuario pulse una tecla (cualquiera), con una sentencia como la siguiente:<br/><br/>
<strong>WHILE (scan_code == 0)</strong><br/>
<strong>FRAME;</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Esta sentencia indica que mientras no se haya pulsado una tecla en la imagen anterior (mientras <strong>scan_code</strong> sea igual a <strong>0</strong>), se deben seguir visualizando im&#225;genes del juego.<br/><br/>
Los <strong>c&#243;digos de rastreo</strong> son simplemente una relaci&#243;n num&#233;rica de las teclas del PC; estos c&#243;digos pueden variar ligeramente (en alguna tecla) de un teclado a otro, ya que hay teclados de diferentes idiomas, con un n&#250;mero variado de teclas, etc.<br/><br/>
Sin embargo, se mantienen constantes casi todos los c&#243;digos de las principales teclas. Hay predefinida una lista de constantes (sin&#243;nimos para estos c&#243;digos) en el lenguaje que se puede ver accediendo a la ayuda sobre <a href="#1176">c&#243;digos de teclas</a> (o c&#243;digos de rastreo del teclado); son, precisamente, estos valores num&#233;ricos los que ser&#225;n asignados a la variable <strong>scan_code</strong> cuando las respectivas teclas sean pulsadas en el programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Existe otra variable global predefinida, denominada <a href="#1109">ascii</a>, que tambi&#233;n contiene el c&#243;digo de la &#250;ltima tecla pulsada pero, a diferencia de <strong>scan_code</strong>, &#233;sta &#250;ltima guarda el <strong>c&#243;digo ASCII</strong> (car&#225;cter) generado por la tecla, es decir, indica <strong>qu&#233; car&#225;cter ha generado la &#250;ltima tecla pulsada</strong> y no qu&#233; <strong>tecla ha sido pulsada</strong> (como <strong>scan_code</strong>).<br/><br/>
Acceda a la ayuda sobre los <a href="#1176">c&#243;digos de teclas</a> para observar un <strong>programa ejemplo</strong> con las variables <strong>ascii</strong> y <strong>scan_code</strong>.<br/><br/>
Normalmente, para comprobar si una tecla est&#225; siendo pulsada se utiliza simplemente la funci&#243;n <a href="#128">key()</a> del lenguaje, que recibe como par&#225;metro uno de estos <a href="#1176">c&#243;digos de teclas</a>, y devuelve <strong>0</strong> si la tecla no est&#225; pulsada o <strong>1</strong> cuando si lo est&#225;.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1109">ascii</a> - <a href="#128">key()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1111">GLOBAL joy_filter</h2><br/><br/>
<strong>joy_filter=10;</strong> // Filtro aplicado al joystick<hr/>
<br/><br/>
Esta variable global se utiliza para definir el filtro aplicado a las coordenadas le&#237;das del joystick.<br/><br/>
Se define como un porcentaje de <strong>0 %</strong> a <strong>99 %</strong>; por defecto <strong>joy_filter</strong> valdr&#225; <strong>10</strong> (se aplicar&#225; un filtro de un 10%).<br/><br/>
La utilidad de aplicar este filtro a las coordenadas del joystick es para suavizar los movimientos del mismo y evitar posibles &quot;<strong>picos</strong>&quot; en la lectura de las coordenadas; dichas coordenadas del joystick se deben obtener con la funci&#243;n <a href="#122">get_joy_position()</a>. La variable <strong>joy_filter</strong> &#250;nicamente ser&#225; de utilidad cuando se est&#233; utilizando &#233;sta &#250;ltima funci&#243;n.<br/><br/>
Cuanto mayor sea el filtro aplicado m&#225;s se suavizar&#225;n los movimientos del mismo, pero tambi&#233;n se retardar&#225; su respuesta.<br/><br/>
Dado que la funci&#243;n cometida por este &quot;<strong>filtro</strong>&quot; es algo dif&#237;cil de comprender, se muestra a continuaci&#243;n un ejemplo.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_joy_filter;
BEGIN
    write(0, 0, 0, 0, &quot;joy_filter=&quot;);
    write_int(0, 70, 0, 0, offset joy_filter);
    write(0, 160, 180, 1, &quot;El gr&#225;fico se muestra en las coordenadas del joystick&quot;);
    write(0, 160, 190, 1, &quot;Utilice las teclas arriba/abajo para variar el filtro&quot;);
    load_fpg(&quot;help\help.fpg&quot;);
    put_screen(0, 1);
    graph=100;
    LOOP
        IF (scan_code==_up AND joy_filter&lt;99)
            joy_filter++;
        END
        IF (scan_code==_down AND joy_filter&gt;0)
            joy_filter--;
        END
        x=get_joy_position(0);
        y=get_joy_position(1);
        FRAME;
    END
END
</pre>
Este programa imprime el gr&#225;fico de una bola en las coordenadas devueltas por el joystick principal mediante la funci&#243;n <a href="#122">get_joy_position()</a>.<br/><br/>
Se puede observar como, para valores peque&#241;os de <strong>joy_filter</strong>, se producen muchos &quot;<strong>picos</strong>&quot; (irregularidades) en la lectura, y como para valores muy grandes (como 95%) se produce una lectura de las coordenadas mucho m&#225;s suave y regular, pero ligeramente retardada.<br/><br/>
<strong>Nota:</strong> Es imprescindible tener un joystick (o gamepad) conectado al ordenador para que esta variable tenga utilidad. Si el joystick se conecta durante la ejecuci&#243;n del programa, el sistema no lo detectar&#225; (debe estar conectado desde el inicio). Ver la variable global <a href="#1112">joy_status</a>.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#122">get_joy_position()</a> - <a href="#1112">joy_status</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1112">GLOBAL joy_status</h2><br/><br/>
<strong>joy_status=0;</strong> // Estado del joystick<hr/>
<br/><br/>
En esta variable gobal se indica el estado del joystick (o gamepad) conectado al ordenador. Los valores que toma esta variable por defecto son:<br/><br/>
<strong>0</strong> - Si el sistema de lectura del joystick est&#225; desactivado. Este valor quiere decir que no se ha encontrado un joystick conectado al ordenador al inicio de la ejecuci&#243;n del programa, o bien que &#233;ste ha sido desconectado.<br/><br/>
<strong>1</strong> - Si el sistema de lectura del joystick est&#225; activo. &#201;ste es el valor inicial por defecto, pero si se desconecta el joystick (o no se encuentra ninguno conectado), se desactivar&#225; el sistema de lectura (indicando un <strong>0</strong> en la variable joy_status).<br/><br/>
Si el sistema est&#225; desactivado, se puede volver a activar simplemente asignando de nuevo un <strong>1</strong> a <strong>joy_status</strong> (con la sentencia <strong>joy_status=1;</strong>), pero si pasado un tiempo l&#237;mite no se detecta un joystick, el sistema se volver&#225; a desactivar.<br/><br/>
<hr/>
<br/><br/>
Existe un <strong>modo especial</strong> en el que el sistema de lectura del joystick <strong>no se desactivar&#225; nunca</strong>; este modo se define simplemente <strong>asignando un 2 a joy_status</strong>.<br/><br/>
<strong>joy_status=2;</strong> // Activa modo especial<br/>
<br/><br/>
No obstante, se debe tener cuidado ya que si el sistema de lectura del joystick est&#225; activado de este modo, sin haber un joystick conectado al ordenador, <strong>puede ralentizarse la ejecuci&#243;n del juego</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La lectura del joystick suele realizarse en los programas accediendo a la <a href="#1103">estructura global joy</a> que indica, siempre, la direcci&#243;n del mismo y el estado de sus botones (si est&#225;n pulsados o no).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1103">Estructura joy</a> - <a href="#1111">joy_filter</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1113">GLOBAL restore_type</h2><br/><br/>
<strong>restore_type=complete_restore;</strong> // Tipo de restauraci&#243;n<hr/>
<br/><br/>
Esta variable global indica el tipo de restauraci&#243;n que se debe realizar tras cada imagen en la pantalla.<br/><br/>
Se llama <strong>restauraci&#243;n del fondo</strong> a recuperar las zonas de pantalla en las que se han pintado gr&#225;ficos o escrito textos en la imagen anterior, es decir, &quot;<strong>despintar</strong>&quot; los gr&#225;ficos y &quot;<strong>desescribir</strong>&quot; los textos (borrarlos).<br/><br/>
Hay tres tipos de restauraci&#243;n aplicables que se corresponden, directamente, con tres constantes que pueden ser asignadas a la variable <strong>restore_type</strong>.<br/><br/>
<a href="#1172">no_restore</a>       - El m&#225;s r&#225;pido, no se restaura el fondo (-1)<br/>
<a href="#1173">partial_restore</a>  - Medio, restauraciones parciales (0)<br/>
<a href="#1174">complete_restore</a> - El m&#225;s lento, restauraci&#243;n completa (1)<br/>
<br/><br/>
Por defecto, el valor de <strong>restore_type</strong> es <strong>complete_restore</strong>, es decir, que si no se indica otro valor en esta variable se realizar&#225; una restauraci&#243;n completa de pantalla tras cada imagen del juego.<br/><br/>
Esta modalidad de restauraci&#243;n (completa) es la m&#225;s lenta de las tres, por lo que seguramente se podr&#225; ganar velocidad de ejecuci&#243;n en el juego (para que vaya m&#225;s fluido en los ordenadores lentos), si se le asigna otro valor a esta variable. Por ejemplo, para indicar una restauraci&#243;n parcial, se debe utilizar la siguiente sentencia:<br/><br/>
<strong>restore_type=partial_restore;</strong><br/><br/>
Con ella se indicar&#237;a al gestor de procesos de DIV Games Studio que, tras las siguientes im&#225;genes del juego, se debe restaurar parcialmente el fondo de la pantalla (&#250;nicamente las zonas de pantalla sobre las que se hayan puesto gr&#225;ficos o textos).<br/><br/>
La modalidad m&#225;s r&#225;pida es <strong>no_restore</strong> (no restaurar el fondo de la pantalla); sin embargo, &#233;sta es aplicable solamente cuando el juego se desarrolle dentro de una ventana de scroll o de modo 7 que ocupe toda la pantalla. En caso contrario los gr&#225;ficos dejar&#225;n rastros (de las im&#225;genes anteriores) al moverse por pantalla.<br/><br/>
Se puede cambiar la modalidad de restauraci&#243;n durante la ejecuci&#243;n de un programa tantas veces como sea necesario, seg&#250;n los requerimientos de las fases (o secciones) que se ejecuten en cada momento.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Existe otra variable global relacionada tambi&#233;n con la gesti&#243;n que DIV Games Studio realiza de la pantalla; &#233;sta es <a href="#1114">dump_type</a> que define el tipo de <strong>volcado</strong> de im&#225;genes que debe realizarse (qu&#233; informaci&#243;n debe enviarse al monitor tras cada imagen del juego).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1114">dump_type</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1114">GLOBAL dump_type</h2><br/><br/>
<strong>dump_type=complete_dump;</strong> // Tipo de volcado<hr/>
<br/><br/>
Esta variable global indica el tipo de volcado de im&#225;genes a pantalla que se debe realizar en cada imagen del juego.<br/><br/>
Se denomina <strong>volcado</strong> a cuando se env&#237;an las im&#225;genes del juego al monitor (a la memoria de v&#237;deo de la tarjeta gr&#225;fica).<br/><br/>
<hr/>
<br/><br/>
Hay dos tipos de volcado aplicables que se corresponden, directamente, con dos constantes que pueden ser asignadas a la variable <strong>dump_type</strong>.<br/><br/>
<a href="#1170">partial_dump</a> - Se realizar&#225;n <strong>volcados parciales</strong> si se indica con la siguiente sentencia:<br/><br/>
<strong>dump_type=partial_dump;</strong><br/><br/>
En este modo, s&#243;lo se volcar&#225;n en pantalla los gr&#225;ficos que se actualicen, que hayan variado respecto a la imagen anterior. Este volcado conviene activarlo <strong>para ganar velocidad</strong> cuando se programe un juego (o una secci&#243;n del mismo) sin una ventana de scroll o modo 7 que ocupe toda la pantalla, es decir, cuando el juego muestre movimientos de gr&#225;ficos sobre un fondo fijo, o bien cuando las ventanas activas de scroll o modo 7 sean m&#225;s peque&#241;as que la pantalla.<br/><br/>
<a href="#1171">complete_dump</a> - Se realizar&#225;n <strong>volcados completos</strong> si se indica con la siguiente sentencia:<br/><br/>
<strong>dump_type=complete_dump;</strong><br/><br/>
En este modo, se volcar&#225; toda la pantalla sin importar si los gr&#225;ficos han cambiado o no. &#201;ste es m&#225;s lento que el <strong>volcado parcial</strong>, sin embargo es el que se debe utilizar cuando el juego tenga una ventana de scroll o modo 7 que ocupe toda la pantalla.<br/><br/>
<hr/>
<br/><br/>
Por defecto, el valor de <strong>dump_type</strong> es <strong>complete_dump</strong>, es decir, que si no se indica otro valor en esta variable se realizar&#225;n <strong>volcados completos</strong> de la pantalla tras cada imagen del juego (lo que suele ser <strong>m&#225;s lento</strong> que realizar volcados parciales).<br/><br/>
Se puede cambiar la modalidad de volcado durante la ejecuci&#243;n de un programa tantas veces como sea necesario, seg&#250;n los requerimientos de las fases (o secciones) que se ejecuten en cada momento.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Existe otra variable global relacionada tambi&#233;n con la gesti&#243;n que DIV Games Studio realiza de la pantalla; &#233;sta es <a href="#1113">restore_type</a> que define el tipo de <strong>restauraci&#243;n</strong> que debe realizarse en la pantalla tras cada imagen del juego (qu&#233; gr&#225;ficos o qu&#233; textos deben ser borrados).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1113">restore_type</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1115">GLOBAL max_process_time</h2><br/><br/>
<strong>max_process_time=500;</strong> // Tiempo m&#225;ximo de ejecuci&#243;n<hr/>
<br/><br/>
Los programas est&#225;n dotados de un mecanismo <strong>anti-bloqueo</strong> que har&#225; que el gestor de procesos de DIV Games Studio interrumpa su ejecuci&#243;n cuando un proceso supere el <strong>tiempo m&#225;ximo de ejecuci&#243;n</strong> en una imagen del juego.<br/><br/>
Este tiempo m&#225;ximo es el que se indica en la variable global <strong>max_process_time</strong> en <strong>cent&#233;simas de segundo</strong>; su valor por defecto es de <strong>500 cent&#233;simas</strong> (<strong>5 segundos</strong>).<br/><br/>
Es decir, cuando un proceso tarde m&#225;s tiempo del aqu&#237; indicado en ejecutar una sentencia <a href="#1029">FRAME</a> (que indica que el proceso est&#225; ya preparado para la siguiente imagen del juego), se producir&#225; un error de ejecuci&#243;n.<br/><br/>
<strong>Nota:</strong> La utilidad que tiene la posibilidad de cambiar esta variable, asign&#225;ndole un nuevo valor, es para que en los programas en los que exista un proceso, que deba estar realizando c&#225;lculos durante bastante tiempo, no se produzca este error.<br/><br/>
Para indicar al gestor de procesos, por ejemplo, que no se debe interrumpir un proceso, a no ser que est&#233; m&#225;s de 30 segundos de ejecuci&#243;n en una imagen se debe utilizar una sentencia como la siguiente:<br/><br/>
<strong>max_process_time=3000;</strong><br/><br/>
Ya que 30 segundos son 3000 cent&#233;simas de segundo.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Se debe tener en cuenta que no todos los ordenadores tardan lo mismo en realizar los c&#225;lculos del programa, por lo que hay que definir este valor con cierto margen, para que no se supere el <strong>tiempo m&#225;ximo de ejecuci&#243;n</strong> cuando el juego sea ejecutado en ordenadores m&#225;s lentos.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1029">Sentencia FRAME</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1116">LOCAL STRUCT reserved</h2><br/><br/>
<strong>STRUCT reserved;</strong><br/>
<strong>process_id;</strong>     // Identificador del proceso<br/>
<strong>id_scan;</strong>        // Indice de procesos<br/>
<strong>process_type;</strong>   // Tipo de proceso<br/>
<strong>type_scan;</strong>      // Indice de tipos<br/>
<strong>status;</strong>         // Estado del proceso<br/>
<strong>param_offset;</strong>   // Direcci&#243;n de los par&#225;metros<br/>
<strong>program_index;</strong>  // Contador de programa<br/>
<strong>is_executed;</strong>    // Proceso ejecutado<br/>
<strong>is_painted;</strong>     // Proceso pintado<br/>
<strong>distance_1;</strong>     // Reservado modo 7<br/>
<strong>distance_2;</strong>     // Reservado modo 7<br/>
<strong>frame_percent;</strong>  // Porcentaje de imagen<br/>
<strong>box_x0, box_y0;</strong> // Inicio del gr&#225;fico del proceso<br/>
<strong>box_x1, box_y1;</strong> // Final del gr&#225;fico del proceso<br/>
<strong>m8_object;</strong>      // Objeto dentro del mundo m8<br/>
<strong>old_ctype;</strong>      // Antiguo Ctype<br/>
<strong>f_count;</strong>        // Contador de anidamiento de funci&#243;n<br/>
<strong>caller_id;</strong>      // Proceso o funci&#243;n llamadora (0 si fu&#233; el kernel)<br/>
<strong>stack_pointer;</strong>  // Puntero de pila del proceso<br/>
<strong>END</strong><br/>
<br/><br/>
En esta estructura se guardan distintas <strong>variables de uso interno</strong> (utilizadas por el <strong>gestor de procesos de DIV Games Studio</strong>).<br/><br/>
Son variables locales reservadas para el sistema. No es necesario conocer estas variables ya que la gran mayor&#237;a no son de utilidad en la creaci&#243;n de programas.<br/><br/>
<strong>Importante:</strong> Modificar los valores de estas variables provocar&#225;, muy probablemente, un <strong>bloqueo</strong> del ordenador, un funcionamiento indebido del <strong>gestor de procesos</strong> o problemas al utilizar muchas de las funciones internas. No se asume ninguna responsabilidad por tanto, sobre los posibles problemas derivados del uso indebido de la estructura <strong>reserved</strong>.<br/><br/>
<hr/>
<br/><br/>
Se mostrar&#225;, por tanto, una <strong>breve descripci&#243;n</strong> de cada uno de estos campos, &#250;nicamente con fines documentativos.<br/><br/>
<strong>process_id</strong> - <a href="#1039">C&#243;digo identificador</a> del proceso; este valor se obtiene normalmente con la palabra reservada <a href="#1092">ID</a> y no se debe modificar el valor de este campo.<br/><br/>
<strong>id_scan</strong> - Se utiliza internamente al detectar las colisiones para guardar registro del <a href="#1039">c&#243;digo identificador</a> del &#250;ltimo proceso que ha colisionado con el proceso actual.<br/><br/>
<strong>process_type</strong> - Tipo del proceso actual, que se obtiene normalmente con el operador <a href="#1042">TYPE</a>, indicando el nombre del proceso a continuaci&#243;n (ver <a href="#1042">Tipos de procesos</a>).<br/><br/>
<strong>type_scan</strong> - Se utiliza internamente para detectar colisiones u obtener c&#243;digos identificadores de procesos de un tipo determinado.<br/><br/>
<strong>status</strong> - Estado actual del proceso. Los valores que puede adoptar este campo son los siguientes:<br/><br/>
<strong>0</strong> - proceso inexistente.<br/>
<strong>1</strong> - proceso que ha recibido una se&#241;al <strong>s_kill</strong>.<br/>
<strong>2</strong> - proceso vivo o despierto (s_wakeup).<br/>
<strong>3</strong> - proceso dormido (s_sleep).<br/>
<strong>4</strong> - proceso congelado (s_freeze).<br/>
<br/><br/>
<strong>param_offset</strong> - Direcci&#243;n de la memoria del ordenador en la que est&#225;n situados los par&#225;metros que ha recibido el proceso.<br/><br/>
<strong>program_index</strong> - Contador de programa. Direcci&#243;n de la memoria del ordenador en la que se encuentra la primera sentencia que debe ejecutar el proceso en la siguiente imagen.<br/><br/>
<strong>is_executed</strong> - Indica si este proceso ha sido ya ejecutado en la imagen actual.<br/><br/>
<strong>is_painted</strong> - Indica si el gr&#225;fico del proceso ha sido ya pintado en la imagen actual del juego.<br/><br/>
<strong>distance_1</strong> - Distancia vertical del proceso (reservado para procesos que se visualicen en una ventana de modo 7).<br/><br/>
<strong>distance_2</strong> - Distancia horizontal del proceso (ocurre lo mismo que en la sentencia anterior).<br/><br/>
<strong>frame_percent</strong> - Porcentaje de la siguiente imagen completado por el proceso; &#233;ste valor ser&#225; de utilidad cuando se utilice la sentencia <a href="#1029">FRAME</a> indicando un porcentaje. En caso contrario valdr&#225; simplemente 0 (0%) cuando el proceso no ha sido ejecutado y 100 (100%) cuando ya lo haya sido.<br/><br/>
<strong>box_x0, box_y0</strong> - Coordenada superior izquierda del gr&#225;fico en la imagen anterior del juego (donde se situ&#243; el gr&#225;fico en coordenadas de pantalla).<br/><br/>
<strong>box_x1, box_y1</strong> - Coordenada inferior derecha del gr&#225;fico en la imagen anterior del juego.<br/><br/>
<strong>m8_object</strong> - N&#250;mero de objeto dentro de un modo 8, se indica un ordinal relativo al mapa de sectores.<br/><br/>
<strong>old_ctype</strong> - Antiguo valor de la variable local ctype, se utiliza para controlar cambios de &#225;mbito en las coordenadas de un proceso.<br/><br/>
<strong>f_count</strong> - Contador de anidamiento de funcion, para controlar el n&#250;mero de retornos y poder nivelar la pila para cada proceso.<br/><br/>
<strong>caller_id</strong> - C&#243;digo identificador del proceso o funcion que ha invocado a este (0 si fu&#233; el kernel qui&#233;n lanz&#243; este proceso en esta imagen).<br/><br/>
<strong>stack_pointer</strong>  - Puntero de pila local de cada proceso, mantiene la direcci&#243;n de la pila a la entrada del proceso, con los par&#225;metros apilados.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1117">LOCAL father</h2><br/><br/>
<strong>father;</strong> // <a href="#1039">C&#243;digo identificador</a> del proceso padre<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>father</strong>.<br/><br/>
Esta variable contiene siempre el <a href="#1039">c&#243;digo identificador</a> del proceso que cre&#243; (llam&#243;) al proceso actual (el que posee esta variable), es decir, indica qu&#233; proceso fue el que lo invoc&#243;.<br/><br/>
Dentro del lenguaje se denomina proceso padre al que llama a otro proceso, y proceso hijo al que ha sido llamado. Para m&#225;s informaci&#243;n ver las <a href="#1041">jerarqu&#237;as de procesos</a> en el lenguaje.<br/><br/>
El <strong>gestor de procesos</strong> de DIV es el proceso denominado <strong>div_main</strong> y es el encargado de crear el proceso principal del programa (<strong>PROGRAM</strong>) al comienzo de la ejecuci&#243;n del juego. Por lo tanto, &#233;ste ser&#225; el padre del programa principal, as&#237; como el padre de todos los procesos que queden hu&#233;rfanos (procesos cuyo padre haya muerto o finalizado antes que ellos, ver <a href="#1040">estados de un proceso</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El <a href="#1039">c&#243;digo identificador</a> del proceso hijo se indica en la variable local predefinida <a href="#1118">son</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1039">C&#243;digo identificador</a> - <a href="#1041">Jerarquias de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1118">LOCAL son</h2><br/><br/>
<strong>son=0;</strong> // <a href="#1039">C&#243;digo identificador</a> del proceso hijo<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>son</strong>.<br/><br/>
Esta variable contiene siempre el <a href="#1039">c&#243;digo identificador</a> del <strong>&#250;ltimo</strong> proceso que ha creado (llamado) el proceso actual, es decir, indica cu&#225;l es el <strong>&#250;ltimo</strong> proceso invocado.<br/><br/>
Dentro del lenguaje se denomina proceso padre al que llama a otro proceso, y proceso hijo al que ha sido llamado. Para m&#225;s informaci&#243;n ver las <a href="#1041">jerarqu&#237;as de procesos</a> en el lenguaje.<br/><br/>
Esta variable estar&#225; por defecto a <strong>0</strong> hasta que el proceso realice una llamada a otro proceso, momento en el cual se crear&#225; el nuevo proceso indicando su <a href="#1039">c&#243;digo identificador</a> en <strong>son</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El <a href="#1039">c&#243;digo identificador</a> del proceso padre se indica en la variable local predefinida <a href="#1117">father</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1039">C&#243;digo identificador</a> - <a href="#1041">Jerarqu&#237;as de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1119">LOCAL smallbro</h2><br/><br/>
<strong>smallbro=0;</strong> // <a href="#1039">C&#243;digo identificador</a> del hermano menor<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>smallbro</strong>.<br/><br/>
Esta variable contiene siempre el <a href="#1039">c&#243;digo identificador</a> del siguiente proceso que cre&#243; el padre del proceso actual tras &#233;l, es decir, cuando el proceso que invoc&#243; al actual invocara a alg&#250;n otro despu&#233;s, esta variable indicar&#225; cu&#225;l.<br/><br/>
A este proceso se le denomina <strong>hermano menor</strong> dentro del lenguaje. Para m&#225;s informaci&#243;n ver las <a href="#1041">jerarqu&#237;as de procesos</a> en el lenguaje.<br/><br/>
Esta variable estar&#225; por defecto a <strong>0</strong> hasta que el proceso padre realice una llamada a otro proceso, momento en el cual se crear&#225; el nuevo proceso (el hermano menor de &#233;ste), indicando su <a href="#1039">c&#243;digo identificador</a> en <strong>smallbro</strong> (de &quot;small brother&quot;).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El <a href="#1039">c&#243;digo identificador</a> del <strong>hermano mayor</strong> se indica en la variable local predefinida <a href="#1120">bigbro</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1039">C&#243;digo identificador</a> - <a href="#1041">Jerarqu&#237;as de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1120">LOCAL bigbro</h2><br/><br/>
<strong>bigbro=0;</strong> // <a href="#1039">C&#243;digo identificador</a> del hermano mayor<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>bigbro</strong>.<br/><br/>
Esta variable contiene siempre el <a href="#1039">c&#243;digo identificador</a> del proceso que cre&#243; el padre justo antes de crear al proceso actual, es decir, cuando el proceso que invoc&#243; al actual hubiera creado otro antes, &#233;sta variable indicar&#225; cu&#225;l.<br/><br/>
A este proceso se le denomina <strong>hermano mayor</strong> dentro del lenguaje. Para m&#225;s informaci&#243;n ver las <a href="#1041">jerarqu&#237;as de procesos</a> en el lenguaje.<br/><br/>
Esta variable estar&#225; a <strong>0</strong> si el proceso padre (el que invoc&#243; al proceso actual) no hubiera creado ning&#250;n otro antes. En caso de que hubiera creado uno, o m&#225;s de uno, <strong>bigbro</strong> (de &quot;big brother&quot;) indicar&#237;a el <a href="#1039">c&#243;digo identificador</a> del &#250;ltimo de ellos.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El <a href="#1039">c&#243;digo identificador</a> del <strong>hermano menor</strong> se indica en la variable local predefinida <a href="#1119">smallbro</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1039">C&#243;digo identificador</a> - <a href="#1041">Jerarqu&#237;as de procesos</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1121">LOCAL priority</h2><br/><br/>
<strong>priority=0;</strong> // Nivel de prioridad del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>priority</strong>.<br/><br/>
En la preparaci&#243;n de cada imagen todos los procesos ser&#225;n ejecutados en el orden de prioridad establecido por la variable local <strong>priority</strong>.<br/><br/>
Cuanto mayor sea el valor de <strong>priority</strong> en un proceso, antes ser&#225; procesado &#233;ste en cada imagen. El valor de priority puede fijarse como cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>); por ejemplo, para establecer el nivel de prioridad de un proceso a <strong>10</strong> se debe utilizar la siguiente sentencia:<br/><br/>
<strong>priority=10;</strong><br/><br/>
Todos los procesos activos en el programa que tengan <strong>el mismo nivel de prioridad</strong> ser&#225;n ejecutados en un <strong>orden indeterminado</strong> que, adem&#225;s, puede variar de unas ejecuciones del juego a otras.<br/><br/>
Por defecto la variable local <strong>priority</strong> estar&#225; inicializada a <strong>0</strong> en todos los procesos creados en el programa, por lo que &#233;stos podr&#225;n ser ejecutados en cualquier orden, si no se define el valor de esta variable.<br/><br/>
Si se fija la <strong>priority</strong> de un s&#243;lo proceso a un n&#250;mero positivo, como 1, &#233;ste ser&#225; ejecutado antes que el resto de los procesos, y si se fija a un n&#250;mero negativo, como -1, entonces ser&#225; ejecutado tras el resto (suponiendo que la variable <strong>priority</strong> del resto no se ha modificado, por lo que sigue valiendo <strong>0</strong>).<br/><br/>
<strong>Cuando se debe fijar la prioridad de los procesos</strong><hr/>
<br/><br/>
Cuando un proceso necesite utilizar en sus c&#225;lculos datos de otro proceso, suele ser conveniente que se ejecute tras &#233;l, definiendo su prioridad m&#225;s baja, para que al leer los datos del otro proceso, &#233;stos ya est&#233;n actualizados.<br/><br/>
Por ejemplo, si el proceso <strong>B</strong> debe situar su gr&#225;fico 8 puntos m&#225;s abajo que el gr&#225;fico del proceso <strong>A</strong>, se debe fijar la prioridad de <strong>A</strong> mayor que la de <strong>B</strong>, para que &#233;ste se ejecute primero.<br/><br/>
De esta forma, cuando el proceso <strong>B</strong> obtenga su coordenada <strong>y</strong> sumando 8 a la del proceso <strong>A</strong>, se realice este c&#225;lculo con la coordenada <strong>y</strong> del proceso <strong>A</strong> ya actualizada para la siguiente imagen (para asegurar que en cada imagen primero se fijar&#225; la coordenada <strong>y</strong> del proceso <strong>A</strong> y despu&#233;s la del proceso <strong>B</strong>).<br/><br/>
Para conseguir &#233;sto, como ambas prioridades estar&#225;n por defecto a <strong>0</strong>, bastar&#237;a con definir la prioridad de <strong>A</strong> como <strong>1</strong>, o bien definir la prioridad de <strong>B</strong> como<strong> -1</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El nivel de prioridad del proceso no tiene nada que ver con el plano de profundidad en el que aparece su gr&#225;fico en pantalla, ya que &#233;ste se indica en la variable <a href="#1125">local z</a>. Es decir, que un gr&#225;fico se procese antes no implica que su gr&#225;fico se pinte antes.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1122">LOCAL ctype</h2><br/><br/>
<strong>ctype=c_screen;</strong> // Sistema de coordenadas<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>ctype</strong>.<br/><br/>
En esta variable se indica el <strong>sistema de coordenadas</strong> utilizado por el proceso, es decir, c&#243;mo deben ser interpretadas las coordenadas del proceso (contenidas en las variables locales <a href="#1123">x</a> e <a href="#1124">y</a>).<br/><br/>
Se pueden utilizar tres sistemas de coordenadas diferentes, que se corresponden directamente con tres constantes que pueden ser asignadas a la variable <strong>ctype</strong>.<br/><br/>
<a href="#1167">c_screen</a> - Coordenadas de pantalla<br/>
<a href="#1168">c_scroll</a> - Coordenadas de scroll<br/>
<a href="#1169">c_m7</a>     - Coordenadas de modo 7<br/>
<a href="#1412">c_m8</a>     - Coordenadas de modo 8<br/>
<br/><br/>
<strong>El valor por defecto de ctype es</strong> <a href="#1167">c_screen</a>, el utilizado para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a la pantalla, donde la esquina superior izquierda es la (0, 0).<br/><br/>
Se asignar&#225; <a href="#1168">c_scroll</a> a <strong>ctype</strong> con la siguiente sentencia:<br/><br/>
<strong>ctype=c_scroll;</strong><br/><br/>
Para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a una ventana de scroll, a coordenadas sobre el gr&#225;fico del primer plano.<br/><br/>
Se asignar&#225; <a href="#1169">c_m7</a> a <strong>ctype</strong> con la siguiente sentencia:<br/><br/>
<strong>ctype=c_m7;</strong><br/><br/>
Para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a una ventana de modo 7, a coordenadas sobre el gr&#225;fico principal, abatido tridimensionalmente en dicha ventana.<br/><br/>
Se asignar&#225; <a href="#1412">c_m8</a> a <strong>ctype</strong> con la siguiente sentencia:<br/><br/>
<strong>ctype=c_m8;</strong><br/><br/>
Para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a una ventana de modo 8, a coordenadas sobre un mapa de sectores tridimensional.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Existe otra variable local que tambi&#233;n afecta al modo en el que deben ser interpretadas las coordenadas del proceso; &#233;sta es <a href="#1135">resolution</a> y establece la resoluci&#243;n (escala) en la que se definen las coordenadas.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1167">c_screen</a> - <a href="#1168">c_scroll</a> - <a href="#1169">c_m7</a> - <a href="#1412">c_m8</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1123">LOCAL x</h2><br/><br/>
<strong>x=0;</strong> // Coordenada horizontal del gr&#225;fico<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>x</strong>.<br/><br/>
La variables locales <strong>x</strong> e <a href="#1124">y</a> de los procesos definen d&#243;nde debe situarse el gr&#225;fico de los mismos (definido en la variable local <a href="#1126">graph</a>).<br/><br/>
La variable local <strong>x</strong> define la <strong>coordenada horizontal</strong> del proceso, que se puede definir como un n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>), situ&#225;ndose las coordenadas positivas hacia la derecha y las negativas hacia la izquierda.<br/><br/>
Por defecto, estas coordenadas se especificar&#225;n en <strong>puntos</strong> (p&#237;xeles), referidos a coordenadas de pantalla, donde la esquina superior izquierda es el punto situado en (<strong>0</strong>, <strong>0</strong>).<br/><br/>
<strong>Tipo de coordenadas</strong><hr/>
<br/><br/>
Hay varios sistemas de coordenadas que pueden ser utilizados por los procesos y que se definen con la variable local <a href="#1122">ctype</a>, el sistema por defecto son las coordenadas relativas a la pantalla.<br/><br/>
<strong>Resoluci&#243;n de las coordenadas</strong><hr/>
<br/><br/>
La variable local <a href="#1135">resolution</a> indica la precisi&#243;n de las coordenadas del proceso; por defecto, esta variable valdr&#225; <strong>0</strong> y las coordenadas (<strong>x</strong>, <a href="#1124">y</a>) se especifican en puntos.<br/><br/>
Cuanto mayor sea el valor de <a href="#1135">resolution</a>, m&#225;s peque&#241;a (y precisa) ser&#225; la unidad en la que se interpretan las coordenadas, a continuaci&#243;n se muestran algunos ejemplos:<br/><br/>
<strong>resolution=1;</strong> - Las coordenadas se especifican en puntos.<br/><br/>
<strong>resolution=10;</strong> - Se especifican en d&#233;cimas de puntos.<br/><br/>
<strong>resolution=100;</strong> - Se especifican en cent&#233;simas de puntos.<br/><br/>
<strong>resolution=2;</strong> - Se especifican en mitades de punto.<br/><br/>
...<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede definir para cada proceso un tipo y resoluci&#243;n de coordenadas diferente, as&#237; como cambiarlos en tiempo de ejecuci&#243;n cuando sea necesario.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Cuando se sit&#250;a un gr&#225;fico en unas coordenadas determinadas, normalmente ser&#225; el <strong>centro</strong> del gr&#225;fico el que se sit&#250;e en dichas coordenadas.<br/><br/>
Esto se puede cambiar definiendo en el <strong>editor gr&#225;fico</strong> el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong> del gr&#225;fico del proceso (cuyo <strong>c&#243;digo de gr&#225;fico</strong> se indica en la variable <a href="#1126">graph</a>).<br/><br/>
Si se ha definido el punto de control, ser&#225; &#233;ste el que se sit&#250;e en las coordenadas especificadas.<br/><br/>
Por ejemplo, si se sit&#250;a el punto de control <strong>0</strong> en la esquina superior izquierda del gr&#225;fico y, posteriormente, se pone el gr&#225;fico en las coordenadas (100, 100), se posicionar&#225; la esquina superior izquierda del gr&#225;fico en dichas coordenadas.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1122">ctype</a> - <a href="#1135">resolution</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1124">LOCAL y</h2><br/><br/>
<strong>y=0;</strong> // Coordenada vertical del gr&#225;fico<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>y</strong>.<br/><br/>
La variables locales <a href="#1123">x</a> e <strong>y</strong> de los procesos definen d&#243;nde debe situarse el gr&#225;fico de los mismos (definido en la variable local <a href="#1126">graph</a>).<br/><br/>
La variable local <strong>y</strong> define la <strong>coordenada vertical</strong> del proceso, que se puede definir como un n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>), situ&#225;ndose las coordenadas positivas hacia abajo y las negativas hacia arriba.<br/><br/>
Por defecto, estas coordenadas se especificar&#225;n en <strong>puntos</strong> (p&#237;xeles), referidos a coordenadas de pantalla, donde la esquina superior izquierda es el punto situado en (<strong>0</strong>, <strong>0</strong>).<br/><br/>
<strong>Tipo de coordenadas</strong><hr/>
<br/><br/>
Hay varios sistemas de coordenadas que pueden ser utilizados por los procesos y que se definen con la variable local <a href="#1122">ctype</a>, el sistema por defecto son las coordenadas relativas a la pantalla.<br/><br/>
<strong>Resoluci&#243;n de las coordenadas</strong><hr/>
<br/><br/>
La variable local <a href="#1135">resolution</a> indica la precisi&#243;n de las coordenadas del proceso; por defecto, &#233;sta variable valdr&#225; <strong>0</strong> y las coordenadas (<a href="#1123">x</a>,<strong>y</strong>) se especifican en puntos.<br/><br/>
Cuanto mayor sea el valor de <a href="#1135">resolution</a>, m&#225;s peque&#241;a (y precisa) ser&#225; la unidad en la que se interpretan las coordenadas, a continuaci&#243;n se muestran algunos ejemplos:<br/><br/>
<strong>resolution=1;</strong> - Las coordenadas se especifican en puntos.<br/><br/>
<strong>resolution=10;</strong> - Se especifican en d&#233;cimas de puntos.<br/><br/>
<strong>resolution=100;</strong> - Se especifican en cent&#233;simas de puntos.<br/><br/>
<strong>resolution=2;</strong> - Se especifican en mitades de punto.<br/><br/>
...<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se puede definir para cada proceso un tipo y una resoluci&#243;n de coordenadas diferente, as&#237; como cambiarlos en tiempo de ejecuci&#243;n cuando sea necesario.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Cuando se sit&#250;a un gr&#225;fico en unas coordenadas determinadas, normalmente ser&#225; el <strong>centro</strong> del gr&#225;fico el que se sit&#250;e en dichas coordenadas.<br/><br/>
&#201;sto se puede cambiar definiendo en el <strong>editor gr&#225;fico</strong> el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong> del gr&#225;fico del proceso (cuyo <strong>c&#243;digo de gr&#225;fico</strong> se indica en la variable <a href="#1126">graph</a>).<br/><br/>
Si se ha definido el punto de control, ser&#225; &#233;ste el que se sit&#250;e en las coordenadas especificadas.<br/><br/>
Por ejemplo, si se sit&#250;a el punto de control <strong>0</strong> en la esquina superior izquierda del gr&#225;fico y, posteriormente, se pone el gr&#225;fico en las coordenadas (100, 100), se posicionar&#225; la esquina superior izquierda del gr&#225;fico en dichas coordenadas.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1122">ctype</a> - <a href="#1135">resolution</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1125">LOCAL z</h2><br/><br/>
<strong>z=0;</strong> // Plano de profundidad del gr&#225;fico del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>z</strong>.<br/><br/>
La variable local <strong>z</strong> define en qu&#233; plano de profundidad debe situarse el gr&#225;fico del proceso en la pantalla (el gr&#225;fico se define en la variable local <a href="#1126">graph</a>). Es decir, qu&#233; debe aparecer por encima del gr&#225;fico del proceso y qu&#233; por debajo.<br/><br/>
Los planos de profundidad pueden ser cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>), y cuanto mayor sea el n&#250;mero, m&#225;s al fondo se situar&#225; el gr&#225;fico (a mayor profundidad).<br/><br/>
<hr/>
<br/><br/>
Por defecto, los planos de profundidad est&#225;n dispuestos de la siguiente forma:<br/><br/>
<strong> (+) Mayor profundidad</strong><br/><br/>
<strong> +512</strong> - Ventanas de scroll (ver <a href="#1101">scroll[].z</a>)<br/>
<strong> +256</strong> - Ventanas de modo 7 (ver <a href="#1102">m7[].z</a>)<br/>
<strong>  0</strong>   - Gr&#225;ficos de los procesos (local <strong>z</strong>)<br/>
<strong> -256</strong> - Textos (ver <a href="#1106">text_z</a>)<br/>
<strong> -512</strong> - Puntero del rat&#243;n (ver <a href="#1100">mouse.z</a>)<br/>
<br/><br/>
<strong> (-) Menor profundidad</strong><br/><br/>
Es decir, la variable local <strong>z</strong> que define el plano de profundidad de los gr&#225;ficos de los procesos estar&#225; inicializada a <strong>0</strong>. Los gr&#225;ficos de los procesos se situar&#225;n debajo del puntero del rat&#243;n y los textos, y sobre las ventanas de scroll y modo 7 (si no se modifican los valores por defecto).<br/><br/>
<hr/>
<br/><br/>
Todos los objetos (textos, gr&#225;ficos, ventanas, ...) que se sit&#250;en en el mismo plano de profundidad aparecer&#225;n en pantalla (al superponerse unos sobre otros) en un <strong>orden indeterminado</strong>, que puede variar de unas ejecuciones del programa a otras.<br/><br/>
Si se quisiera, por ejemplo, que el gr&#225;fico de un proceso apareciera sobre todos los objetos del programa, se podr&#237;a fijar para el mismo un plano de profundidad por encima del resto (como -1000}, con la siguiente sentencia:<br/><br/>
<strong>z=-1000;</strong><br/><br/>
Inicialmente, todos los procesos tienen su variable <strong>z</strong> igual a <strong>0</strong>, luego los gr&#225;ficos de los procesos aparecer&#225;n en cualquier orden si no se define en qu&#233; plano debe situarse cada uno.<br/><br/>
Se puede variar el plano de profundidad de un proceso (asignando un nuevo valor a su variable <strong>z</strong>) tantas veces como sea necesario dentro de un programa.<br/><br/>
Los planos de profundidad del resto de objetos (ventanas, textos y puntero del rat&#243;n) tambi&#233;n pueden variarse en cualquier momento del programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> Los procesos que pertenezcan a una <strong>ventana de scroll</strong> (que tengan su variable <a href="#1122">ctype</a><strong>=</strong><a href="#1168">c_scroll</a>) se pintar&#225;n en el <strong>plano de profundidad de la ventana de scroll</strong>; no obstante, dentro de dicha ventana, todos los gr&#225;ficos de los procesos aparecer&#225;n <strong>ordenados por su plano de profundidad</strong>.<br/><br/>
Es decir, el plano de profundidad del proceso (indicado como siempre en la variable <strong>z</strong>) ser&#225; entonces <strong>relativo a la ventana de scroll</strong> en la que aparece el proceso (ver <a href="#163">start_scroll()</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 2:</strong> Los procesos que pertenezcan a una <strong>ventana de modo 7</strong> (que tengan su variable <a href="#1122">ctype</a><strong>=</strong><a href="#1167">c_m7</a>) aparecer&#225;n en dicha ventana <strong>ordenados por estricto orden de profundidad en el plano tridimensional</strong> ignor&#225;ndose el valor de su variable local <strong>z</strong>.<br/><br/>
El &#250;nico sentido que tiene la variable local <strong>z</strong> en procesos de un <strong>modo 7</strong> es definir el orden en el que deben superponerse los procesos que est&#233;n <strong>exactamente</strong> en las mismas coordenadas del plano abatido, es decir, si se sit&#250;an dos procesos en el plano tridimensional en las mismas coordenadas entonces se podr&#225;, con la variable <strong>z</strong>, definir cu&#225;l de ellos debe aparecer sobre el otro (ver <a href="#162">start_mode7()</a>).<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1100">mouse.z</a> - <a href="#1101">scroll[].z</a> - <a href="#1102">m7[].z</a> - <a href="#1106">text_z</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1126">LOCAL graph</h2><br/><br/>
<strong>graph=0;</strong> // C&#243;digo del gr&#225;fico del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>graph</strong>.<br/><br/>
Normalmente, la mayor&#237;a de procesos se corresponden con un objeto gr&#225;fico visualizado en pantalla que se situar&#225; en las coordenadas indicadas en las variables locales <a href="#1123">x</a> e <a href="#1123">y</a>. Se debe definir qu&#233; gr&#225;fico es el correspondiente a dicho proceso asignando un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <strong>graph</strong>.<br/><br/>
Por defecto, esta variable valdr&#225; <strong>0</strong> lo que implica que no se visualizar&#225; ning&#250;n gr&#225;fico para este proceso.<br/><br/>
Los gr&#225;ficos se deben crear primero en el <strong>editor gr&#225;fico</strong> de DIV Games Studio (con la opci&#243;n &quot;<strong>Nuevo...</strong>&quot; del men&#250; de mapas) y, despu&#233;s, se pueden guardar en un <strong>archivo MAP o PCX</strong> (que contendr&#225; este gr&#225;fico), o en un <strong>fichero FPG</strong> junto a otros gr&#225;ficos (se puede crear un fichero nuevo con la opci&#243;n &quot;<strong>Nuevo...</strong>&quot; del men&#250; de ficheros).<br/><br/>
Es decir, los gr&#225;ficos utilizados en un programa pueden provenir de un <strong>archivo MAP o PCX</strong> (que contiene un s&#243;lo gr&#225;fico) o de un <strong>fichero FPG</strong> (que puede contener muchos gr&#225;ficos).<br/><br/>
<strong>Nota:</strong> Un mismo gr&#225;fico puede ser utilizado por muchos procesos a la vez en un programa.<br/><br/>
<strong>Archivos MAP o PCX</strong><hr/>
<br/><br/>
Para utilizar en el programa un gr&#225;fico de un <strong>archivo MAP o PCX</strong> se debe cargar este llamando a las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a>, que devolver&#225;n el <strong>c&#243;digo del gr&#225;fico</strong> que se debe ser asignado a la variable <strong>graph</strong>.<br/><br/>
Normalmente se utiliza una variable <a href="#1006">GLOBAL</a> para guardar este <strong>c&#243;digo de gr&#225;fico</strong> y despu&#233;s se asigna &#233;sta a la variable <strong>graph</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_graph;

GLOBAL
    gr&#225;fico1;

BEGIN
    gr&#225;fico1=load_map(&quot;help\help.map&quot;);

    graph=gr&#225;fico1; // Se define el gr&#225;fico del proceso.

    LOOP
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
</pre>
Si bien en el ejemplo anterior se podr&#237;a haber prescindido de la variable global <strong>gr&#225;fico1</strong> y haber asignado directamente el c&#243;digo devuelto por la funci&#243;n <a href="#174">load_map()</a> a la variable <strong>graph</strong> con la siguiente sentencia:<br/><br/>
<strong>graph=load_map(&quot;help\help.map&quot;);</strong><br/><br/>
los <strong>c&#243;digos de gr&#225;fico</strong> que devuelve esta funci&#243;n son simplemente n&#250;meros enteros a partir de <strong>1000</strong>.<br/><br/>
<strong>Ficheros FPG</strong><hr/>
<br/><br/>
Para incluir un gr&#225;fico que se ha realizado en el <strong>editor gr&#225;fico</strong> en un <strong>fichero FPG</strong> de debe <strong>arrastrar la ventana del gr&#225;fico a la ventana del fichero</strong> (pulsar en el gr&#225;fico, moverse hasta el fichero y soltar), entonces el programa pedir&#225; el <strong>c&#243;digo del gr&#225;fico</strong>, con lo que se debe introducir aqu&#237; un n&#250;mero entero entre <strong>1</strong> y <strong>999</strong>.<br/><br/>
Para utilizar entonces el gr&#225;fico en un programa, se debe primero cargar el <strong>fichero FPG</strong> que lo contiene con la funci&#243;n <a href="#132">load_fpg()</a> y, despu&#233;s, asignar el <strong>c&#243;digo del gr&#225;fico</strong> a la variable <strong>graph</strong>.<br/><br/>
Se muestra, a continuaci&#243;n, un ejemplo es necesario saber antes que un gr&#225;fico de una <strong>bola marr&#243;n</strong> se introdujo en el <strong>fichero HELP.FPG</strong> indicando el <strong>c&#243;digo de gr&#225;fico 100</strong>.<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_graph;
BEGIN
    load_fpg(&quot;help\help.fpg&quot;);

    graph=100; // Se define el gr&#225;fico del proceso.

    LOOP
        x=mouse.x;
        y=mouse.y;
        FRAME;
    END
END
</pre>
Se pueden cargar <strong>varios ficheros FPG</strong> en un programa; en ese caso se deber&#225; indicar, adem&#225;s del <strong>c&#243;digo del gr&#225;fico</strong> en la variable local <strong>graph</strong>, el <strong>c&#243;digo de fichero</strong> que devuelve la funci&#243;n <a href="#132">load_fpg()</a> en la variable local <a href="#1131">file</a>.<br/><br/>
Si s&#243;lo se carga un fichero &#233;sto no ser&#225; necesario, ya que la variable <a href="#1131">file</a> vale <strong>0</strong> por defecto en todos los procesos y <strong>0</strong> ser&#225; siempre el <strong>c&#243;digo del primer fichero</strong> que se cargue en el programa.<br/><br/>
<hr/>
<br/><br/>
Existen m&#225;s variables locales relacionadas con el gr&#225;fico de un proceso, las principales son las siguientes:<br/><br/>
<strong>graph</strong>  - C&#243;digo del gr&#225;fico<br/>
<a href="#1131">file</a>   - C&#243;digo del fichero<br/>
<a href="#1123">x</a>, <a href="#1124">y</a>   - Coordenadas del gr&#225;fico<br/>
<a href="#1125">z</a>      - Plano de profundidad<br/>
<a href="#1129">angle</a>  - &#225;ngulo del gr&#225;fico<br/>
<a href="#1128">size</a>   - Tama&#241;o del gr&#225;fico<br/>
<a href="#1127">flags</a>  - Espejados y transparencias<br/>
<a href="#1130">region</a> - Ventana de visualizaci&#243;n<br/>
<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1127">LOCAL flags</h2><br/><br/>
<strong>flags=0;</strong> // Indicador de espejados y transparencia<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>flags</strong>.<br/><br/>
La variable local <strong>flags</strong> indica los espejados y transparencias con los que se imprimir&#225; el gr&#225;fico del proceso; los posibles valores son:<br/><br/>
<strong>0</strong>-Gr&#225;fico normal.<br/>
<strong>1</strong>-Espejado horizontal.<br/>
<strong>2</strong>-Espejado vertical.<br/>
<strong>3</strong>-Espejado horizontal y vertical (180&#176;).<br/>
<strong>4</strong>-Gr&#225;fico transparente.<br/>
<strong>5</strong>-Transparente y espejado horizontal.<br/>
<strong>6</strong>-Transparente y espejado vertical.<br/>
<strong>7</strong>-Transparente, espejado horizontal y vertical.<br/>
<br/><br/>
El valor por defecto de la variable <strong>flags</strong> es <strong>0</strong>, es decir, que si no se modifica el gr&#225;fico se mostrar&#225; opaco (sin transparencia) y sin espejar.<br/><br/>
Se definen a continuaci&#243;n los t&#233;rminos de <strong>espejado</strong> y <strong>transparencia</strong>:<br/><br/>
- <strong>Espejado horizontal</strong>, el gr&#225;fico se invertir&#225; horizontalmente, es decir, si estaba mirando hacia la izquierda, mirar&#225; a la derecha y viceversa.<br/><br/>
- <strong>Espejado vertical</strong>, el gr&#225;fico se invertir&#225; verticalmente, es decir, si estaba mirando hacia arriba, mirar&#225; hacia abajo y viceversa.<br/><br/>
- <strong>Transparencia</strong> (o <strong>ghost-layering</strong>), el gr&#225;fico se mostrar&#225; semitransparente, es decir, se podr&#225; ver lo que haya detr&#225;s del gr&#225;fico, como si &#233;ste fuera una cristalera de colores, en contraposici&#243;n a los gr&#225;ficos opacos que se muestran normalmente.<br/><br/>
Por ejemplo, para que el gr&#225;fico de un proceso se muestre transparente se debe utilizar la siguiente sentencia:<br/><br/>
<strong>flags=4;</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El gr&#225;fico de un proceso se debe indicar asignando un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <a href="#1126">graph</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1128">LOCAL size</h2><br/><br/>
<strong>size=100;</strong> // Tama&#241;o (en porcentaje) del gr&#225;fico<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>size</strong>.<br/><br/>
La variable local <strong>size</strong> define el tama&#241;o en el que se debe ver el gr&#225;fico del proceso, en un porcentaje relativo a su tama&#241;o original.<br/><br/>
El valor por defecto de esta variable ser&#225; <strong>100</strong> (100%) para todos los procesos, y cuando sea modificado el gr&#225;fico se <strong>escalar&#225;</strong> (reduci&#233;ndose o ampli&#225;ndose) para ajustarse al nuevo tama&#241;o.<br/><br/>
Es decir, para mostrar el gr&#225;fico al <strong>doble</strong> de su tama&#241;o se deber&#225; especificar un <strong>200%</strong>, lo que se har&#225; con la siguiente sentencia:<br/><br/>
<strong>size=200;</strong><br/><br/>
Por lo tanto, si este valor es menor que <strong>100</strong> el gr&#225;fico se ver&#225; m&#225;s peque&#241;o, y si es mayor, m&#225;s grande.<br/><br/>
En un principio no hay ning&#250;n l&#237;mite para el tama&#241;o del gr&#225;fico, pero si se pone la variable local <strong>size</strong> a <strong>0</strong> (0%), entonces no se ver&#225; el gr&#225;fico del proceso.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El gr&#225;fico de un proceso se debe indicar asignando un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <a href="#1126">graph</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1129">LOCAL angle</h2><br/><br/>
<strong>angle=0;</strong> // &#225;ngulo del gr&#225;fico del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>angle</strong>.<br/><br/>
La variable local <strong>angle</strong> define el &#225;ngulo en el que se debe ver el gr&#225;fico del proceso, indicando un &#225;ngulo respecto al gr&#225;fico original en <strong>mil&#233;simas de grado</strong> (ver <a href="#1044">Uso de &#225;ngulos en el lenguaje</a>).<br/><br/>
El valor por defecto de esta variable ser&#225; <strong>0</strong> (0 grados) para todos los procesos, pero cuando sea modificado el gr&#225;fico se <strong>rotar&#225;</strong> para ajustarse al nuevo &#225;ngulo.<br/><br/>
El &#225;ngulo puede definirse como cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
Se muestran a continuaci&#243;n algunos ejemplos de los &#225;ngulos que definen ciertos valores en la variable local <strong>angle</strong> (se recuerda que los &#225;ngulos se expresan en <strong>mil&#233;simas</strong> de grado):<br/><br/>
...<br/>
<strong> -180000</strong> - <a href="#1044">Angulo</a> hacia la izquierda<br/>
<strong>  -90000</strong> - <a href="#1044">Angulo</a> hacia abajo<br/>
<strong>  -45000</strong> - <a href="#1044">Angulo</a> de la diagonal abajo/derecha<br/>
<strong>       0</strong> - <a href="#1044">Angulo</a> hacia la derecha<br/>
<strong>  +45000</strong> - <a href="#1044">Angulo</a> de la diagonal derecha/arriba<br/>
<strong>  +90000</strong> - <a href="#1044">Angulo</a> hacia arriba<br/>
<strong> +180000</strong> - <a href="#1044">Angulo</a> hacia la izquierda<br/>
<strong> +270000</strong> - <a href="#1044">Angulo</a> hacia abajo<br/>
...<br/>
<br/><br/>
<strong>Importante:</strong> Cuando se pretenda rotar el gr&#225;fico de un proceso, <strong>es conveniente dibujarlo orientado hacia la derecha</strong>, ya que as&#237; es como se mostrar&#225; por defecto (con la variable local <strong>angle</strong> igual a <strong>0</strong>).<br/><br/>
De esta forma, cuando se especifique otro &#225;ngulo, el gr&#225;fico aparecer&#225; orientado exactamente hacia &#233;l.<br/><br/>
Por ejemplo, para que un gr&#225;fico que ha sido dibujado hacia la derecha se vea orientado hacia arriba (hacia el &#225;ngulo de 90 grados), bastar&#225; con indicar la siguiente sentencia:<br/><br/>
<strong>angle=90000;</strong> // 90 mil&#233;simas de grado (90 grados).<br/><br/>
Es decir, si un gr&#225;fico se dibujara orientado hacia otro &#225;ngulo, por ejemplo hacia abajo, quedar&#237;a orientado hacia abajo por defecto, <strong>en el &#225;ngulo 0</strong>, lo que puede provocar confusiones a la hora de orientar el gr&#225;fico hacia otro &#225;ngulo.<br/><br/>
<hr/>
<br/><br/>
Para hacer que el gr&#225;fico de un proceso avance sus coordenadas (<a href="#1123">x</a>, <a href="#1124">y</a>) hacia su &#225;ngulo (el especificado en la variable local <strong>angle</strong> del proceso) una distancia determinada, se puede utilizar la funci&#243;n <a href="#101">advance()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El gr&#225;fico de un proceso se debe indicar asignando un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <a href="#1126">graph</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1130">LOCAL region</h2><br/><br/>
<strong>region=0;</strong> // Regi&#243;n de pantalla asignada al proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>region</strong>.<br/><br/>
La variable local <strong>region</strong> define en qu&#233; zona de pantalla debe ser visible el gr&#225;fico del proceso, indicando el <strong>n&#250;mero de regi&#243;n</strong>.<br/><br/>
Una regi&#243;n es una zona rectangular de pantalla, como una ventana, que est&#225; asociada a un n&#250;mero.<br/><br/>
Por defecto, esta variable valdr&#225; <strong>0</strong> en todos los procesos haciendo referencia a la <strong>regi&#243;n n&#250;mero 0</strong> que es <strong>la pantalla entera</strong>.<br/><br/>
Es decir, que por defecto los gr&#225;ficos de los procesos ser&#225;n visibles en toda la pantalla (en cualquier punto de la misma en el que est&#233;n).<br/><br/>
En un principio, &#250;nicamente est&#225; definida la <strong>regi&#243;n numero 0</strong>. Para definir nuevas regiones de pantalla se debe utilizar la funci&#243;n <a href="#106">define_region()</a>.<br/><br/>
<hr/>
<br/><br/>
Por ejemplo, para que el gr&#225;fico de un proceso fuera visible s&#243;lo dentro de una caja de 100 por 100 puntos situada en la esquina superior izquierda de la pantalla (en las coordenadas 0, 0), primero se deber&#237;a definir la nueva regi&#243;n la siguiente forma, suponiendo que se defina la regi&#243;n n&#250;mero <strong>1</strong>:<br/><br/>
<strong>define_region(1, 0, 0, 100, 100);</strong><br/><br/>
y, despu&#233;s, se deber&#237;a asignar el n&#250;mero de regi&#243;n (<strong>1</strong>) a la variable local <strong>region</strong> del proceso con la siguiente sentencia:<br/><br/>
<strong>region=1;</strong><br/><br/>
Las regiones pueden redefinirse en cualquier momento dentro de un programa; esto es, se pueden cambiar de posici&#243;n o de tama&#241;o siempre que sea necesario.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El gr&#225;fico de un proceso se debe indicar asignando un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <a href="#1126">graph</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#106">define_region()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1131">LOCAL file</h2><br/><br/>
<strong>file=0;</strong> // C&#243;digo del fichero del gr&#225;fico del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>file</strong>.<br/><br/>
La variable local <strong>file</strong> indica, en los casos en los que se hayan cargado varios <strong>ficheros FPG</strong> de gr&#225;ficos en un programa, cu&#225;l es el fichero que contiene el gr&#225;fico que est&#225; utilizando el proceso.<br/><br/>
El gr&#225;fico de un proceso se debe indicar asignando un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <a href="#1126">graph</a>.<br/><br/>
Si &#250;nicamente se ha cargado un fichero en el programa, no ser&#225; necesario asignar ning&#250;n valor a <strong>file</strong>, ya que el <strong>c&#243;digo del primer fichero cargado</strong> ser&#225; el <strong>0</strong> y &#233;ste es el valor por defecto de la variable.<br/><br/>
Si el gr&#225;fico se ha cargado con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx()</a>, tampoco ser&#225; necesario asignar ning&#250;n valor a <strong>file</strong>, ya que los gr&#225;ficos cargados con estas funciones se utilizan como si pertenecieran al fichero n&#250;mero <strong>0</strong> (al primero que se cargue en el programa).<br/><br/>
Cuando se cargue m&#225;s de un fichero, se debe indicar en cada proceso en cu&#225;l de ellos se encuentra su gr&#225;fico; esto se debe hacer asignando el <strong>c&#243;digo de fichero</strong> que ha devuelto la funci&#243;n <a href="#132">load_fpg()</a> (al cargar dicho <strong>fichero FPG</strong>) a la variable local <strong>file</strong>.<br/><br/>
<strong>Nota:</strong> Normalmente, si se cargan varios ficheros en un programa secuencialmente, el primero tendr&#225; el c&#243;digo <strong>0</strong>, el segundo el <strong>1</strong>, el tercero el <strong>2</strong> y, as&#237; sucesivamente.<br/><br/>
<hr/>
<br/><br/>
En general, es una buena pr&#225;ctica, si se utilizan varios ficheros, tener el mismo n&#250;mero de variables globales (denominadas por ejemplo <strong>fichero1</strong>, <strong>fichero2</strong>, ...) que contengan el c&#243;digo de cada uno de los ficheros, para utilizarlas en los procesos a la hora de definir su variable <strong>file</strong> (el <strong>fichero FPG</strong> que se debe emplear).<br/><br/>
Las variables se definir&#237;an dentro de la secci&#243;n <a href="#1006">GLOBAL</a> de la siguiente forma:<br/><br/>
<strong>GLOBAL</strong><br/>
<strong>fichero1;</strong> // C&#243;digo del primer fichero<br/>
<strong>fichero2;</strong> // C&#243;digo del segundo<br/>
...<br/><br/>
Despu&#233;s, se les asignar&#237;a a estas variables los <strong>c&#243;digos de fichero</strong> al cargar &#233;stos con la funci&#243;n <a href="#132">load_fpg()</a> de la siguiente forma (suponiendo que el nombre de los ficheros es <strong>nombre1.fpg</strong>, <strong>nombre2.fpg</strong>, etc.):<br/><br/>
<strong>fichero1=load_fpg(&quot;nombre1.fpg&quot;);</strong> // Carga de ficheros<br/>
<strong>fichero2=load_fpg(&quot;nombre2.fpg&quot;);</strong><br/>
...<br/><br/>
Generalmente, esta carga de ficheros se realiza al inicio del programa; posteriormente, dentro de cada proceso, solamente habr&#237;a que definir el fichero utilizado con la siguiente sentencia (suponiendo que el proceso utilice gr&#225;ficos contenidos en el fichero <strong>nombre1.fpg</strong>):<br/><br/>
<strong>file=fichero1;</strong> // Se utiliza el primer fichero<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se recuerda que definir la variable local <strong>file</strong> no sirve para nada, a no ser que tambi&#233;n se asigne un <strong>c&#243;digo de gr&#225;fico</strong> a la variable local <a href="#1126">graph</a>.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1132">LOCAL xgraph</h2><br/><br/>
<strong>xgraph=0;</strong> // OFFSET de la tabla gr&#225;fica del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>xgraph</strong>.<br/><br/>
Esta variable es de nivel avanzado, por lo que requiere cierta experiencia para su utilizaci&#243;n.<br/><br/>
La variable local <strong>xgraph</strong> (<strong>extended graphic</strong>) sirve para utilizar <strong>gr&#225;ficos m&#250;ltiples</strong>. Para definir el gr&#225;fico de un proceso como un <strong>conjunto de gr&#225;ficos</strong> de los cuales se debe ver <strong>el m&#225;s acorde con el &#225;ngulo del proceso</strong> (especificado en la variable local <a href="#1129">angle</a>).<br/><br/>
Es decir, si se define la variable <strong>xgraph</strong>, <strong>se ignorar&#225; la </strong>variable local <a href="#1126">graph</a> que normalmente define el gr&#225;fico del proceso y se utilizar&#225; un gr&#225;fico u otro en funci&#243;n de la variable <a href="#1129">angle</a>.<br/><br/>
Por lo tanto, al cambiar el &#225;ngulo del proceso <strong>ya no aparecer&#225; el gr&#225;fico del proceso rotado</strong>, sino que utilizar&#225; este &#225;ngulo como seleccionador del gr&#225;fico del proceso (dentro del conjunto definido).<br/><br/>
Por defecto la variable <strong>xgraph</strong> valdr&#225; <strong>0</strong> en todos los procesos, lo que indica que &#233;stos no van a utilizar <strong>gr&#225;ficos m&#250;ltiples</strong>.<br/><br/>
<hr/>
<br/><br/>
La utilidad de los gr&#225;ficos m&#250;ltiples reside en poder realizar juegos en <strong>perspectiva</strong>, donde un cambio de &#225;ngulo en un proceso no implica una rotaci&#243;n de su gr&#225;fico, sino el cambio del gr&#225;fico por otro dibujado con otra <strong>perspectiva</strong> (dibujado con otro &#225;ngulo dentro de dicha perspectiva).<br/><br/>
<strong>Forma de empleo de los gr&#225;ficos m&#250;ltiples</strong><hr/>
<br/><br/>
1 - En primer lugar se deben realizar los diferentes dibujos que van a representar al gr&#225;fico del proceso con diferentes &#225;ngulos en la perspectiva. &#201;stos ser&#225;n un n&#250;mero finito de vistas del gr&#225;fico, como puede ser <strong>4</strong>, <strong>8</strong>, <strong>12</strong>, etc., (o cualquier otro n&#250;mero entero mayor que <strong>1</strong>).<br/><br/>
Se debe tener en cuenta que si se definen 4 vistas, se estar&#225; definiendo una vista diferente cada 90 grados, si se definen 8 vistas, cada 45 grados, etc.<br/><br/>
2 - Se deben ordenar dichos gr&#225;ficos seg&#250;n su &#225;ngulo; primero el gr&#225;fico que se corresponder&#225; con el &#225;ngulo 0 (hacia la derecha) y, despu&#233;s, el resto en sentido contrario a las agujas del reloj.<br/><br/>
3 - Se debe crear una tabla, generalmente <a href="#1006">GLOBAL</a>, inicializada con los siguientes valores:<br/><br/>
<strong>N&#250;mero de vistas del gr&#225;fico</strong>,<br/>
<strong>C&#243;digo del gr&#225;fico para el </strong>&#225;ngulo <strong>0 (primera vista)</strong>,<br/>
<strong>C&#243;digo del siguiente &#225;ngulo (segunda vista)</strong>,<br/>
...<br/><br/>
<strong>Nota:</strong> Esta tabla debe ser de datos simples (de tipo <a href="#1402">INT</a>, enteros de 32 bit con signo).<br/><br/>
Es indiferente el nombre que se le de a dicha tabla, por ejemplo, si se define un gr&#225;fico m&#250;ltiple con 4 vistas, que deben ser los gr&#225;ficos con el c&#243;digo 10, 11, 12, y 13, la definici&#243;n de la tabla podr&#237;a ser:<br/><br/>
<strong>GLOBAL</strong><br/>
<strong>tabla_gr&#225;fico1[]=4, 10, 11, 12, 13;</strong><br/>
....<br/><br/>
4 - Por &#250;ltimo, se debe asignar la direcci&#243;n de esta tabla dentro de la memoria del ordenador a la variable local <strong>xgraph</strong> del proceso, lo que se har&#237;a con la siguiente sentencia (dentro del proceso en cuesti&#243;n):<br/><br/>
<strong>xgraph=OFFSET tabla_gr&#225;fico1;</strong><br/><br/>
El operador <a href="#1085">OFFSET</a> sirve para obtener la direcci&#243;n en la memoria de un dato del programa.<br/><br/>
<hr/>
<br/><br/>
Una vez definido el <strong>gr&#225;fico m&#250;ltiple</strong>, el sistema utilizar&#225; en cada imagen del juego el gr&#225;fico correspondiente al &#225;ngulo <strong>que m&#225;s se aproxima al &#225;ngulo del proceso</strong> (el indicado en su variable <a href="#1129">angle</a>).<br/><br/>
Para desactivar el sistema de <strong>gr&#225;ficos m&#250;ltiples</strong> en un proceso, simplemente se debe volver a poner a <strong>0</strong> la variable <strong>xgraph</strong>.<br/><br/>
<strong>Importante:</strong> Si dentro de la tabla que define el conjunto de gr&#225;ficos se pone alg&#250;n c&#243;digo de gr&#225;fico con <strong>signo negativo</strong>, entonces aparecer&#225; este gr&#225;fico <strong>espejado horizontalmente</strong>, es decir, si el gr&#225;fico estaba mirando hacia la derecha, aparecer&#225; mirando hacia la izquierda, y viceversa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El sistema de gr&#225;ficos m&#250;ltiples se suele utilizar en las <strong>ventanas de modo 7</strong>, ya que en el plano tridimensional abatido los gr&#225;ficos se deben ver de distinta forma seg&#250;n el &#225;ngulo desde el que se miren.<br/><br/>
Para m&#225;s informaci&#243;n sobre esta t&#233;cnica, ver la funci&#243;n <a href="#162">start_mode7()</a> utilizada para activar una <strong>ventana de modo 7</strong> en el programa.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1133">LOCAL height</h2><br/><br/>
<strong>height=0;</strong> // Altura del gr&#225;fico (en el modo 7)<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>height</strong>.<br/><br/>
La variable local <strong>height</strong> se utiliza <strong>exclusivamente</strong> en los procesos que pertenecen a <strong>ventanas de modo 7</strong>, es decir, procesos que tienen su sistema de coordenadas dentro de una ventana tridimensional (su variable local <a href="#1122">ctype</a>=<a href="#1169">c_m7</a>).<br/><br/>
Se utiliza para definir la altura a la que deben situarse los gr&#225;ficos de los procesos sobre el plano tridimensional. No se utiliza para esto la variable <a href="#1125">local z</a>, porque &#233;sta sigue utiliz&#225;ndose para definir el plano de profundidad de los gr&#225;ficos (aunque ahora &#250;nicamente sea &#250;til para procesos situados en las mismas coordenadas).<br/><br/>
La altura del proceso puede definirse como cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>), si bien se suelen utilizar normalmente n&#250;meros positivos, ya que la altura (<strong>height</strong>) del suelo es la <strong>0</strong> y los procesos se sit&#250;an por encima de &#233;ste.<br/><br/>
El valor por defecto de la variable <strong>height</strong> es <strong>0</strong> para todos los procesos, lo que quiere decir que si no se especifica otro valor, los gr&#225;ficos de los procesos aparecer&#225;n justo sobre el suelo del <strong>modo 7</strong> (sobre el plano tridimensionalmente abatido).<br/><br/>
En un principio se situar&#225; en la altura indicada en <strong>height</strong> la <strong>base del gr&#225;fico</strong> del proceso, a no ser que se defina el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong>, en cuyo caso ser&#225; este punto el que se sit&#250;e en esa altura.<br/><br/>
<strong>Nota:</strong> Para m&#225;s informaci&#243;n sobre las <strong>ventanas de modo 7</strong> y c&#243;mo situar gr&#225;ficos dentro de estas ventanas, se debe ver la ayuda sobre la funci&#243;n <a href="#162">start_mode7()</a> que es la utilizada para activarlas en el programa.<br/><br/>
<hr/>
<br/><br/>
En los procesos que no son de <strong>modo 7</strong> se puede utilizar esta variable con cualquier otra finalidad, ya que el sistema la ignorar&#225; por completo.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#162">start_mode7()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1134">LOCAL cnumber</h2><br/><br/>
<strong>cnumber=0;</strong> // N&#250;meros de ventanas de scroll o modo 7<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>cnumber</strong>.<br/><br/>
La variable local <strong>cnumber</strong> se utiliza <strong>exclusivamente</strong> cuando en un juego aparezcan varias <strong>ventanas de scroll</strong> o varias <strong>ventanas de modo 7</strong> simult&#225;neamente en pantalla.<br/><br/>
- Para m&#225;s informaci&#243;n sobre las <strong>ventanas de scroll</strong>, se debe ver la ayuda sobre la funci&#243;n <a href="#163">start_scroll()</a>, que es la utilizada para activarlas en el programa.<br/><br/>
- Para m&#225;s informaci&#243;n sobre las <strong>ventanas de modo 7</strong>, se debe ver la ayuda sobre la funci&#243;n <a href="#162">start_mode7()</a>, que es la utilizada para activarlas en el programa.<br/><br/>
<hr/>
<br/><br/>
La utilidad de <strong>cnumber</strong> reside en indicar <strong>en cu&#225;les de estas ventanas debe verse el gr&#225;fico del proceso</strong>. Evidentemente, esta variable se debe definir s&#243;lo en procesos visibles dentro de las <strong>ventanas de scroll</strong> o de las <strong>ventanas de modo 7</strong>; para el resto de procesos (los procesos de pantalla o los que no tengan gr&#225;fico) esta variable carece de utilidad.<br/><br/>
<strong>Si el proceso debe verse en todas las ventanas</strong>, entonces no ser&#225; necesario modificar esta variable, ya que el valor por defecto de <strong>cnumber</strong> (que es <strong>0</strong>) indica precisamente esto.<br/><br/>
Puede activarse hasta <strong>10</strong> ventanas, tanto de un tipo como del otro, con los n&#250;meros del <strong>0</strong> al <strong>9</strong>. Existen diez constantes predefinidas que se utilizan para definir el valor de <strong>cnumber</strong>; estas son <a href="#1175">c_0, c_1, c_2, ..., c_9</a> y se corresponden directamente con las <strong>10</strong> posibles ventanas de estos tipos.<br/><br/>
Se debe asignar a <strong>cnumber la suma de las constantes</strong> correspondientes a las <strong>ventanas en las que el proceso debe ser visible</strong>.<br/><br/>
Por ejemplo, si en un programa hay <strong>4 ventanas de scroll</strong> que son las n&#250;mero <strong>0</strong>, <strong>1</strong>, <strong>2</strong> y <strong>3</strong>, y se quiere definir que un proceso determinado debe ser visible tan s&#243;lo dentro de las ventanas <strong>0</strong> y <strong>2</strong>, se debe utilizar para esto la siguiente sentencia:<br/><br/>
<strong>cnumber=c_0+c_2;</strong><br/><br/>
El valor de <strong>cnumber</strong> puede variarse durante la ejecuci&#243;n del proceso siempre que sea necesario.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Se recuerda que para que el gr&#225;fico del proceso se vea en todas las ventanas no es necesario hacer nada, ya que &#233;sta es la opci&#243;n por defecto.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#1175">c_0...c_9</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1135">LOCAL resolution</h2><br/><br/>
<strong>resolution=0;</strong> // Resoluci&#243;n de las coordenadas del proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>resolution</strong>.<br/><br/>
Normalmente, las coordenadas de un proceso (indicadas en las variables locales <a href="#1123">x</a> e <a href="#1124">y</a>) se definen en puntos (de pantalla).<br/><br/>
La variable local <strong>resolution</strong> se debe utilizar cuando se quieran definir las coordenadas en <strong>unidades m&#225;s peque&#241;as</strong> que el punto.<br/><br/>
Es decir, que esta variable indica la precisi&#243;n de las coordenadas del proceso.<br/><br/>
Por defecto la variable valdr&#225; <strong>0</strong> y las coordenadas se especificar&#225;n en puntos.<br/><br/>
Cuanto mayor sea el valor de <a href="#1135">resolution</a>, m&#225;s peque&#241;a (y precisa) ser&#225; la unidad en la que se interpretan las coordenadas; a continuaci&#243;n se muestran algunos ejemplos:<br/><br/>
<strong>resolution=1;</strong> - Las coordenadas se especifican en puntos (al igual que con <strong>resolution=0</strong>, que es el valor por defecto).<br/><br/>
<strong>resolution=10;</strong> - Se especifican en d&#233;cimas de puntos.<br/><br/>
<strong>resolution=100;</strong> - Se especifican en cent&#233;simas de puntos.<br/><br/>
<strong>resolution=2;</strong> - Se especifican en mitades de punto.<br/><br/>
...<br/><br/>
Por ejemplo, un proceso situado en <strong>160</strong>, <strong>100</strong> con <strong>resolution</strong> igual a <strong>0</strong> (o <strong>1</strong>), estar&#225; en la misma posici&#243;n que un proceso situado en <strong>1600</strong>, <strong>1000</strong> y con <strong>resolution</strong> igual a <strong>10</strong>.<br/><br/>
El valor de <strong>resolution</strong> se define normalmente como un <strong>n&#250;mero entero positivo m&#250;ltiplo de 10</strong> (10, 100, 1000, ...).<br/><br/>
<hr/>
<br/><br/>
En resumen, cuando se defina el valor de <strong>resolution</strong>, el gestor de procesos de DIV Games Studio <strong>dividir&#225;</strong> las coordenadas de los procesos entre <strong>resolution</strong> a la hora de pintar los gr&#225;ficos de los mismos en pantalla.<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Se deben extremar las precauciones cuando en un programa existan varios procesos con diferentes resoluciones de coordenadas, ya que algunas funciones, como <a href="#117">get_dist()</a> (para obtener la distancia entre dos procesos), devolver&#225;n <strong>resultados incorrectos</strong> cuando se est&#233; accediendo a dos procesos que utilicen diferente resoluci&#243;n de coordenadas.<br/><br/>
Suele ser conveniente que todos los procesos activos en el juego, al menos todos los que interact&#250;en entre ellos (se detecten, modifiquen o puedan colisionar) utilicen la misma resoluci&#243;n.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1136">Puntos de control</h2><br/><br/>
Los <strong>puntos de control</strong> se definen dentro del <strong>editor gr&#225;fico</strong> con la barra de puntos de control, indicada con este icono.<br/><br/>
Para acceder al <strong>editor gr&#225;fico</strong> basta con hacer &quot;<strong>doble-click</strong>&quot; con el rat&#243;n (dos pulsaciones seguidas del bot&#243;n izquierdo del rat&#243;n) sobre un gr&#225;fico dentro del entorno (sobre una ventana de un mapa).<br/><br/>
Los <strong>puntos de control</strong> son simplemente puntos que pueden localizarse dentro de un gr&#225;fico, para diferentes funciones.<br/><br/>
La <strong>barra de puntos de control</strong> permite situar hasta <strong>1000</strong> puntos diferentes dentro de un gr&#225;fico, cada uno ser&#225; identificado por su n&#250;mero (del <strong>0</strong> al <strong>999</strong>).<br/><br/>
Para situar uno de estos puntos, basta con seleccionar el <strong>n&#250;mero de punto</strong> con los <strong>iconos flecha izquierda</strong> y <strong>flecha derecha</strong> y, despu&#233;s, pulsar sobre el gr&#225;fico.<br/><br/>
Para <strong>borrar</strong> (deseleccionar) un punto de control, se debe volver a pulsar sobre el mismo en el gr&#225;fico una segunda vez.<br/><br/>
<hr/>
<br/><br/>
El &#250;nico <strong>punto de control</strong> que utiliza el sistema es el punto de control n&#250;mero <strong>0</strong> (el primero); &#233;ste es el punto que define cu&#225;l es el <strong>centro virtual del gr&#225;fico</strong> y que tiene m&#250;ltiples aplicaciones dentro del lenguaje.<br/><br/>
Cuando no se defina el <strong>punto de control n&#250;mero 0</strong>, el sistema actuar&#225; como si el centro virtual del gr&#225;fico fuera el <strong>centro real del mismo</strong> (un punto situado en la mitad del ancho y la mitad del alto del gr&#225;fico).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Una vez definidos los puntos de control, para que &#233;stos tengan efecto dentro de un programa, debe grabarse el <strong>archivo MAP</strong> (en los archivos PCX no se pueden guardar los puntos de control) o volverse a incluir el gr&#225;fico en el <strong>fichero FPG</strong> arrastr&#225;ndolo hasta el mismo (seg&#250;n cu&#225;l de ambos se cargue en el programa).<br/><br/>
<hr/>
<br/><br/>
<h2 id="1150">Modos de v&#237;deo</h2><br/><br/>
Constantes: <strong>m320x200</strong> ... <strong>m1024x768</strong> <hr/>
<br/><br/>
Esta constantes sirven para indicar el modo de v&#237;deo en la funci&#243;n <a href="#157">set_mode()</a>. La lista completa de constantes es la siguiente:<br/><br/>
m320x200<br/>
m320x240<br/>
m320x400<br/>
m360x240<br/>
m360x360<br/>
m376x282<br/>
m640x400<br/>
m640x480<br/>
m800x600<br/>
m1024x768<br/>
<br/><br/>
Cada constante indica el modo de v&#237;deo de la siguiente manera: primero, la letra <strong>m</strong> y, luego, la resoluci&#243;n horizontal y vertical del modo separadas por una <strong>x</strong>.<br/><br/>
Los valores definidos para dichas constantes son los siguientes.<br/><br/>
m320x200  = 320200<br/>
m320x240  = 320240<br/>
m320x400  = 320400<br/>
m360x240  = 360240<br/>
m360x360  = 360360<br/>
m376x282  = 376282<br/>
m640x400  = 640400<br/>
m640x480  = 640480<br/>
m800x600  = 800600<br/>
m1024x768 = 1024768<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Adem&#225;s de estos modos de v&#237;deo est&#225;ndar, la estructura global <a href="#1415">video_modes</a> contiene una lista de todos los modos compatibles con el est&#225;ndar VESA encontrados en el adaptador de v&#237;deo del sistema.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#157">set_mode()</a> - <a href="#1415">video_modes</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1151">true</h2><br/><br/>
Constante: <strong>true</strong> <hr/>
<br/><br/>
Esta constante se utiliza para indicar valores <strong>ciertos</strong>, para inicializar variables l&#243;gicas o definir par&#225;metros l&#243;gicos, es decir, que deben ser evaluados como una condici&#243;n.<br/><br/>
Su valor es <strong>1</strong>, y como en el lenguaje se interpretan como <strong>ciertos</strong> todos los n&#250;meros <strong>impares</strong>, &#233;sta constante ser&#225; evaluada como una condici&#243;n que siempre se cumple (<strong>cierta</strong>).<br/><br/>
<hr/>
<br/><br/>
La constante <a href="#1152">false</a> es la opuesta a &#233;sta: la utilizada para indicar valores l&#243;gicos <strong>falsos</strong>.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1152">false</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1152">false</h2><br/><br/>
Constante: <strong>false</strong> <hr/>
<br/><br/>
Esta constante se utiliza para indicar valores <strong>falsos</strong>, para inicializar variables l&#243;gicas o definir par&#225;metros l&#243;gicos, es decir, que deben ser evaluados como una condici&#243;n.<br/><br/>
Su valor es <strong>0</strong>, y como en el lenguaje se interpretan como <strong>falsos</strong> todos los n&#250;meros <strong>pares</strong>, esta constante ser&#225; evaluada como una condici&#243;n que nunca se cumple (<strong>falsa</strong>).<br/><br/>
<hr/>
<br/><br/>
La constante <a href="#1152">true</a> es la opuesta a &#233;sta: la utilizada para indicar valores l&#243;gicos <strong>ciertos</strong>.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1151">true</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1153">s_kill</h2><br/><br/>
Constante: <strong>s_kill</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>0</strong>.<br/><br/>
Esta se&#241;al transmite a los procesos la orden imperativa <strong>kill</strong> (muerte). Se utiliza para eliminar procesos en el programa (para hacer desaparecer ciertos objetos del juego).<br/><br/>
Es decir, al enviarle una se&#241;al <strong>s_kill</strong> a un proceso, &#233;ste ser&#225; eliminado y ya no aparecer&#225; en las siguientes im&#225;genes del juego.<br/><br/>
Una constante relacionada directamente con &#233;sta es <a href="#1157">s_kill_tree</a>, con la diferencia de que, al enviar esta se&#241;al, se eliminar&#225; al proceso indicado y a sus <strong>hijos</strong>, que son los procesos que &#233;ste hubiera creado.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa, es:<br/><br/>
<strong>s_kill</strong><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1157">s_kill_tree</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1154">s_wakeup</h2><br/><br/>
Constante: <strong>s_wakeup</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>1</strong>.<br/><br/>
Esta se&#241;al transmite a los procesos la orden imperativa <strong>wakeup</strong> (despierta). Se utiliza para devolver al estado normal los procesos que han sido dormidos (con la se&#241;al <a href="#1155">s_sleep</a>), o congelados (con la se&#241;al <a href="#1156">s_freeze</a>).<br/><br/>
Es decir, al enviarle una se&#241;al <strong>s_wakeup</strong> a un proceso, &#233;ste ser&#225; reactivado en las siguientes im&#225;genes del juego (se volver&#225; a ver y a procesar).<br/><br/>
Una constante relacionada directamente con &#233;sta es <a href="#1158">s_wakeup_tree</a>, con la diferencia de que, al enviar esta se&#241;al, se despertar&#225; al proceso indicado y a sus <strong>hijos</strong>, que son los procesos que &#233;ste hubiera creado.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa, es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<strong>s_wakeup</strong><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1158">s_wakeup_tree</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1155">s_sleep</h2><br/><br/>
Constante: <strong>s_sleep</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>2</strong>.<br/><br/>
Esta se&#241;al transmite a los procesos la orden imperativa <strong>sleep</strong> (duerme). Se utiliza para dormir a un proceso. Un proceso dormido no aparecer&#225; en las siguientes im&#225;genes del juego, pero no ser&#225; eliminado, como con la se&#241;al <a href="#1153">s_kill</a>, sino que podr&#225; volver a <strong>despertarse</strong> en cualquier momento con una se&#241;al <a href="#1154">s_wakeup</a>.<br/><br/>
Es decir, al enviarle una se&#241;al <strong>s_sleep</strong> a un proceso, &#233;ste dejar&#225; de aparecer en las siguientes im&#225;genes del juego (hasta que sea despertado o eliminado).<br/><br/>
Una constante relacionada directamente con &#233;sta es <a href="#1159">s_sleep_tree</a>, con la diferencia de que, al enviar esta se&#241;al, se dormir&#225; al proceso indicado y a sus <strong>hijos</strong>, que son los procesos que &#233;ste hubiera creado.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa, es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1154">s_wakeup</a><br/>
<strong>s_sleep</strong><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1159">s_sleep_tree</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1156">s_freeze</h2><br/><br/>
Constante: <strong>s_freeze</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>3</strong>.<br/><br/>
Esta se&#241;al transmite a los procesos la orden imperativa <strong>freeze</strong> (congelar). Se utiliza para congelar (inmovilizar) a un proceso. Un proceso congelado seguir&#225; apareciendo en las siguientes im&#225;genes del juego, pero no ser&#225; procesado, por lo que permanecer&#225; inm&#243;vil. Este proceso podr&#225; volver a <strong>activarse</strong> en cualquier momento si se le env&#237;a una se&#241;al <a href="#1154">s_wakeup</a>.<br/><br/>
Es decir, al enviarle una se&#241;al <strong>s_freeze</strong> a un proceso, &#233;ste dejar&#225; de procesar (interpretar sus sentencias) en las siguientes im&#225;genes del juego (hasta que sea activado o eliminado con <a href="#1153">s_kill</a>).<br/><br/>
Una constante relacionada directamente con &#233;sta es <a href="#1160">s_freeze_tree</a>, con la diferencia de que, al enviar esta se&#241;al, se congelar&#225; al proceso indicado y a sus <strong>hijos</strong>, que son los procesos que &#233;ste hubiera creado.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#1155">s_sleep</a><br/>
<strong>s_freeze</strong><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1160">s_freeze_tree</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1157">s_kill_tree</h2><br/><br/>
Constante: <strong>s_kill_tree</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>100</strong>.<br/><br/>
Esta se&#241;al se utiliza para que un proceso y todos los procesos que &#233;ste haya creado sean <strong>eliminados</strong> envi&#225;ndoles la orden imperativa <strong>kill</strong> (muerte). Es una versi&#243;n de la se&#241;al <a href="#1153">s_kill</a>, que elimina al proceso, pero no a los procesos que &#233;ste haya creado.<br/><br/>
Es decir, con <strong>s_kill_tree</strong> se <strong>eliminar&#225;</strong> al proceso y a toda su descendencia, con lo que ya no aparecer&#225; ninguno de ellos en las siguientes im&#225;genes del juego.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales, pueden ser enviadas a los diferentes procesos de un programa es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1156">s_freeze</a><br/>
<strong>s_kill_tree</strong><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1153">s_kill</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1158">s_wakeup_tree</h2><br/><br/>
Constante: <strong>s_wakeup_tree</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>101</strong>.<br/><br/>
Esta se&#241;al se utiliza para que un proceso y todos los procesos que &#233;ste haya creado sean <strong>despertados</strong> envi&#225;ndoles la orden imperativa <strong>wakeup</strong> (despertar). Es una versi&#243;n de la se&#241;al <a href="#1154">s_wakeup</a>, que despierta al proceso, pero no a los procesos que &#233;ste haya creado.<br/><br/>
Es decir, con <strong>s_wakeup_tree</strong> se <strong>despertar&#225;</strong> al proceso y a toda su descendencia, volviendo todos estos procesos a su estado normal en las siguientes im&#225;genes del juego.<br/><br/>
Se puede despertar (reactivar) a procesos que han sido <strong>dormidos</strong> con la se&#241;al <a href="#1159">s_sleep_tree</a> o <strong>congelados</strong> con la se&#241;al <a href="#1160">s_freeze_tree</a>.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<strong>s_wakeup_tree</strong><br/>
<a href="#1159">s_sleep_tree</a><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1154">s_wakeup</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1159">s_sleep_tree</h2><br/><br/>
Constante: <strong>s_sleep_tree</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>102</strong>.<br/><br/>
Esta se&#241;al se utiliza para que un proceso y todos los procesos que &#233;ste haya creado sean <strong>dormidos</strong> envi&#225;ndoles la orden imperativa <strong>sleep</strong> (dormir). Es una versi&#243;n de la se&#241;al <a href="#1155">s_sleep</a>, que duerme al proceso, pero no a los procesos que &#233;ste haya creado.<br/><br/>
Es decir, con <strong>s_sleep_tree</strong> se <strong>dormir&#225;</strong> al proceso y a toda su descendencia, desapareciendo todos estos procesos en las siguientes im&#225;genes del juego (pero sin ser eliminados).<br/><br/>
Se puede despertar (reactivar) a estos procesos <strong>dormidos</strong> con la se&#241;al <a href="#1158">s_wakeup_tree</a>.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<strong>s_sleep_tree</strong><br/>
<a href="#1160">s_freeze_tree</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1155">s_sleep</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1160">s_freeze_tree</h2><br/><br/>
Constante: <strong>s_freeze_tree</strong> <hr/>
<br/><br/>
Esta constante se utiliza como par&#225;metro de la funci&#243;n <a href="#158">signal()</a> (para mandar se&#241;ales a los procesos). Su valor es <strong>103</strong>.<br/><br/>
Esta se&#241;al se utiliza para que un proceso y todos los procesos que &#233;ste haya creado sean <strong>congelados</strong> (inmovilizados) envi&#225;ndoles la orden imperativa <strong>freeze</strong> (congelar). Es una versi&#243;n de la se&#241;al <a href="#1156">s_freeze</a>, que congela al proceso, pero no a los procesos que &#233;ste haya creado.<br/><br/>
Es decir, con <strong>s_freeze_tree</strong> se <strong>congelar&#225;</strong> al proceso y a toda su descendencia, dejando de procesar todos estos procesos en las siguientes im&#225;genes del juego (quedar&#225;n inmovilizados, pues no ejecutar&#225;n sus sentencias).<br/><br/>
Se puede descongelar (reactivar) a estos procesos <strong>congelados</strong> con la se&#241;al <a href="#1158">s_wakeup_tree</a>.<br/><br/>
La lista completa de las constantes que utilizadas como se&#241;ales pueden ser enviadas a los diferentes procesos de un programa es:<br/><br/>
<a href="#1153">s_kill</a><br/>
<a href="#1154">s_wakeup</a><br/>
<a href="#1155">s_sleep</a><br/>
<a href="#1156">s_freeze</a><br/>
<a href="#1157">s_kill_tree</a><br/>
<a href="#1158">s_wakeup_tree</a><br/>
<a href="#1159">s_sleep_tree</a><br/>
<strong>s_freeze_tree</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#158">signal()</a> - <a href="#1156">s_freeze</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1161">all_text</h2><br/><br/>
Constante: <strong>all_text</strong> <hr/>
<br/><br/>
Esta constante se usa como par&#225;metro de la funci&#243;n <a href="#107">delete_text()</a>, para eliminar <strong>todos</strong> los textos visualizados en el programa con las funciones <a href="#171">write()</a> y <a href="#172">write_int()</a>.<br/><br/>
Es decir, para que desaparezcan todos los textos que aparecen en pantalla se debe ejecutar la siguiente sentencia:<br/><br/>
<strong>delete_text(all_text);</strong><br/><br/>
El valor que tiene asignado esta constante es <strong>0</strong>.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#107">delete_text()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1162">all_sound</h2><br/><br/>
Constante: <strong>all_sound</strong> <hr/>
<br/><br/>
Esta constante se usa como par&#225;metro de la funci&#243;n <a href="#167">stop_sound()</a>, para parar <strong>todos</strong> los efectos de sonido previamente activados con la funci&#243;n <a href="#159">sound()</a>.<br/><br/>
Es decir, para detener todos los canales de sonido activos en un momento determinado se debe ejecutar la siguiente sentencia:<br/><br/>
<strong>stop_sound(all_sound);</strong><br/><br/>
El valor que tiene asignado esta constante es<strong> -1</strong>.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#167">stop_sound()</a> - <a href="#159">sound()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1163">g_wide</h2><br/><br/>
Constante: <strong>g_wide</strong> <hr/>
<br/><br/>
Esta constante se usa como par&#225;metro de la funci&#243;n <a href="#126">graphic_info()</a>, para pedir informaci&#243;n sobre el <strong>ancho</strong> (en puntos) de un gr&#225;fico determinado. Su valor es <strong>0</strong>.<br/><br/>
Las constantes que pueden utilizarse como par&#225;metros de esta funci&#243;n son:<br/><br/>
<strong>g_wide</strong><br/>
<a href="#1164">g_height</a><br/>
<a href="#1165">g_x_center</a><br/>
<a href="#1166">g_y_center</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#126">graphic_info()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1164">g_height</h2><br/><br/>
Constante: <strong>g_height</strong> <hr/>
<br/><br/>
Esta constante se usa como par&#225;metro de la funci&#243;n <a href="#126">graphic_info()</a>, para pedir informaci&#243;n sobre el <strong>alto</strong> (en puntos) de un gr&#225;fico determinado. Su valor es <strong>1</strong>.<br/><br/>
Las constantes que pueden utilizarse como par&#225;metros de esta funci&#243;n son:<br/><br/>
<a href="#1163">g_wide</a><br/>
<strong>g_height</strong><br/>
<a href="#1165">g_x_center</a><br/>
<a href="#1166">g_y_center</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#126">graphic_info()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1165">g_x_center</h2><br/><br/>
Constante: <strong>g_x_center</strong> <hr/>
<br/><br/>
Esta constante se usa como par&#225;metro de la funci&#243;n <a href="#126">graphic_info()</a>, para pedir informaci&#243;n sobre el <strong>centro horizontal</strong> de un gr&#225;fico determinado. Su valor es <strong>2</strong>.<br/><br/>
El <strong>centro horizontal</strong> de un gr&#225;fico ser&#225; la mitad del ancho (en puntos), si no se ha definido en la herramienta de dibujo el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong> (centro del gr&#225;fico).<br/><br/>
Las constantes que pueden utilizarse como par&#225;metros de esta funci&#243;n son:<br/><br/>
<a href="#1163">g_wide</a><br/>
<a href="#1164">g_height</a><br/>
<strong>g_x_center</strong><br/>
<a href="#1166">g_y_center</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#126">graphic_info()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1166">g_y_center</h2><br/><br/>
Constante: <strong>g_y_center</strong> <hr/>
<br/><br/>
Esta constante se usa como par&#225;metro de la funci&#243;n <a href="#126">graphic_info()</a>, para pedir informaci&#243;n sobre el <strong>centro vertical</strong> de un gr&#225;fico determinado. Su valor es <strong>3</strong>.<br/><br/>
El <strong>centro vertical</strong> de un gr&#225;fico ser&#225; la mitad del alto (en puntos), si no se ha definido en la herramienta de dibujo el <a href="#1136">punto de control</a> n&#250;mero <strong>0</strong> (centro del gr&#225;fico).<br/><br/>
Las constantes que pueden utilizarse como par&#225;metros de esta funci&#243;n son:<br/><br/>
<a href="#1163">g_wide</a><br/>
<a href="#1164">g_height</a><br/>
<a href="#1165">g_x_center</a><br/>
<strong>g_y_center</strong><br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#126">graphic_info()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1167">c_screen</h2><br/><br/>
Constante: <strong>c_screen</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable local predefinida <a href="#1122">ctype</a> que sirve para definir el tipo de coordenadas que tendr&#225; un proceso. Su valor es <strong>0</strong>.<br/><br/>
<strong>Este es el valor por defecto de</strong> <a href="#1122">ctype</a>, el utilizado para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a la pantalla, donde la esquina superior izquierda es la (0, 0).<br/><br/>
Existen otras constantes utilizadas para otros sistemas de coordenadas, la lista completa es la siguiente:<br/><br/>
<strong>c_screen</strong> - Coordenadas de pantalla<br/>
<a href="#1168">c_scroll</a> - Coordenadas de scroll<br/>
<a href="#1169">c_m7</a>     - Coordenadas de modo 7<br/>
<a href="#1412">c_m8</a>     - Coordenadas de modo 8<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1122">ctype</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1168">c_scroll</h2><br/><br/>
Constante: <strong>c_scroll</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable local predefinida <a href="#1122">ctype</a> que sirve para definir el tipo de coordenadas que tendr&#225; un proceso. Su valor es <strong>1</strong>.<br/><br/>
&#201;ste es el valor asignado a <a href="#1122">ctype</a> para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a una ventana de scroll, a coordenadas sobre el gr&#225;fico del primer plano.<br/><br/>
Para m&#225;s informaci&#243;n sobre las <strong>ventanas de scroll</strong>, se puede acceder a la funci&#243;n <a href="#163">start_scroll()</a> utilizada para activarlas.<br/><br/>
Existen otras constantes utilizadas para otros sistemas de coordenadas, la lista completa es la siguiente:<br/><br/>
<a href="#1167">c_screen</a> - Coordenadas de pantalla<br/>
<strong>c_scroll</strong> - Coordenadas de scroll<br/>
<a href="#1169">c_m7</a>     - Coordenadas de modo 7<br/>
<a href="#1412">c_m8</a>     - Coordenadas de modo 8<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1122">ctype</a> - <a href="#163">start_scroll()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1169">c_m7</h2><br/><br/>
Constante: <strong>c_m7</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable local predefinida <a href="#1122">ctype</a> que sirve para definir el tipo de coordenadas que tendr&#225; un proceso. Su valor es <strong>2</strong>.<br/><br/>
&#201;ste es el valor asignado a <a href="#1122">ctype</a> para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a una ventana de modo 7, a coordenadas sobre el gr&#225;fico principal, abatido tridimensionalmente en dicha ventana.<br/><br/>
Para m&#225;s informaci&#243;n sobre las <strong>ventanas de modo 7</strong>, se puede acceder a la funci&#243;n <a href="#162">start_mode7()</a>, utilizada para activarlas.<br/><br/>
Existen otras constantes utilizadas para otros sistemas de coordenadas, la lista completa es la siguiente:<br/><br/>
<a href="#1167">c_screen</a> - Coordenadas de pantalla<br/>
<a href="#1168">c_scroll</a> - Coordenadas de scroll<br/>
<strong>c_m7</strong>     - Coordenadas de modo 7<br/>
<a href="#1412">c_m8</a>     - Coordenadas de modo 8<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1122">ctype</a> - <a href="#162">start_mode7()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1170">partial_dump</h2><br/><br/>
Constante: <strong>partial_dump</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable global predefinida <a href="#1114">dump_type</a> que sirve para definir el tipo de volcado que se har&#225; a pantalla. Su valor es <strong>0</strong>.<br/><br/>
Se utiliza en la siguiente sentencia:<br/><br/>
<strong>dump_type=partial_dump;</strong><br/><br/>
Con esta sentencia se indica al gestor de procesos de DIV Games Studio que los siguientes volcados deben ser <strong>parciales</strong>.<br/><br/>
Se denomina <strong>volcado</strong> al procedimiento de enviar las im&#225;genes del juego al monitor (a la memoria de v&#237;deo de la tarjeta gr&#225;fica).<br/><br/>
Hay dos tipos de volcados:<br/><br/>
<strong>Parcial</strong>: S&#243;lo se volcar&#225;n en pantalla los gr&#225;ficos que se actualicen, que hayan variado respecto a la imagen anterior. Este volcado conviene activarlo <strong>para ganar velocidad</strong> cuando se programe un juego (o una secci&#243;n del mismo) sin una ventana de scroll o modo 7 que ocupe toda la pantalla, es decir, cuando el juego muestre movimientos de gr&#225;ficos sobre un fondo fijo, o bien cuando las ventanas activas de scroll o modo 7 sean m&#225;s peque&#241;as que la pantalla.<br/><br/>
<strong>Completo</strong>: Se volcar&#225; toda la pantalla, sin importar si los gr&#225;ficos han cambiado o no. &#201;ste es el volcado por defecto y <strong>es m&#225;s lento que el volcado parcial</strong>, sin embargo, es el que se debe utilizar cuando el juego tenga una ventana de scroll o modo 7 que ocupe toda la pantalla.<br/><br/>
<hr/>
<br/><br/>
La otra constante que se utiliza para designar el tipo de volcado es <a href="#1171">complete_dump</a> que, al contrario de &#233;sta, define un volcado <strong>completo</strong>.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1114">dump_type</a> - <a href="#1171">complete_dump</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1171">complete_dump</h2><br/><br/>
Constante: <strong>complete_dump</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable global predefinida <a href="#1114">dump_type</a> que sirve para definir el tipo de volcado que se har&#225; a pantalla. Su valor es <strong>1</strong>.<br/><br/>
&#201;ste es el <strong>valor por defecto</strong> de la variable <a href="#1114">dump_type</a>. Para establecer este valor se debe utilizar la siguiente sentencia:<br/><br/>
<strong>dump_type=complete_dump;</strong><br/><br/>
Con esta sentencia se indica al gestor de procesos de DIV Games Studio que los siguientes volcados deben ser <strong>completos</strong>.<br/><br/>
Se denomina <strong>volcado</strong> al proceso de enviar las im&#225;genes del juego al monitor (a la memoria de v&#237;deo de la tarjeta gr&#225;fica).<br/><br/>
Hay dos tipos de volcados:<br/><br/>
<strong>Parcial</strong>: S&#243;lo se volcar&#225;n en pantalla los gr&#225;ficos que se actualicen, que hayan variado respecto a la imagen anterior. Este volcado conviene activarlo <strong>para ganar velocidad</strong> cuando se programe un juego (o una secci&#243;n del mismo) sin una ventana de scroll o modo 7 que ocupe toda la pantalla, es decir, cuando el juego muestre movimientos de gr&#225;ficos sobre un fondo fijo, o bien cuando las ventanas activas de scroll o modo 7 sean m&#225;s peque&#241;as que la pantalla.<br/><br/>
<strong>Completo</strong>: Se volcar&#225; toda la pantalla, sin importar si los gr&#225;ficos han cambiado o no. &#201;ste es el volcado por defecto y <strong>es m&#225;s lento que el volcado parcial</strong>, sin embargo, es el que se debe utilizar cuando el juego tenga una ventana de scroll o modo 7 que ocupe toda la pantalla.<br/><br/>
<hr/>
<br/><br/>
La otra constante que se utiliza para designar el tipo de volcado es <a href="#1170">partial_dump</a> que, al contrario de &#233;sta, define un volcado <strong>parcial</strong>.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1114">dump_type</a> - <a href="#1170">partial_dump</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1172">no_restore</h2><br/><br/>
Constante: <strong>no_restore</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable global predefinida <a href="#1113">restore_type</a> que sirve para definir el tipo de restauraci&#243;n que se debe aplicar al fondo de la pantalla tras cada imagen del juego. Su valor es<strong> -1</strong>.<br/><br/>
Se denomina <strong>restauraci&#243;n del fondo</strong> a recuperar las zonas de pantalla en las que se han pintado gr&#225;ficos o escrito textos en la imagen anterior, es decir, &quot;<strong>despintar</strong>&quot; los gr&#225;ficos y &quot;<strong>desescribir</strong>&quot; los textos (borrarlos).<br/><br/>
Para establecer este valor se debe utilizar la siguiente sentencia:<br/><br/>
<strong>restore_type=no_restore;</strong><br/><br/>
Con esta sentencia se indica al gestor de procesos de DIV Games Studio que tras las siguientes im&#225;genes del juego <strong>no es necesario que se restaure el fondo de pantalla</strong>.<br/><br/>
Si no se restaura el fondo, se <strong>ganar&#225; velocidad</strong> de ejecuci&#243;n en el juego (ir&#225; m&#225;s fluido en los ordenadores lentos). Pero esta modalidad de restauraci&#243;n (<strong>no_restore</strong>) es aplicable &#250;nicamente en juegos o secciones de los mismos, en los que <strong>exista una ventana de scroll o de modo 7 que ocupe la pantalla completa</strong>.<br/><br/>
Los tres tipos de restauraci&#243;n aplicables se corresponden con estas tres constantes:<br/><br/>
<strong>no_restore</strong>       - El m&#225;s r&#225;pido, no se restaura el fondo<br/>
<a href="#1173">partial_restore</a>  - Medio, restauraciones parciales<br/>
<a href="#1174">complete_restore</a> - El m&#225;s lento, restauraci&#243;n completa<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1113">restore_type</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1173">partial_restore</h2><br/><br/>
Constante: <strong>partial_restore</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable global predefinida <a href="#1113">restore_type</a> que sirve para definir el tipo de restauraci&#243;n que se debe aplicar al fondo de la pantalla tras cada imagen del juego. Su valor es<strong> 0</strong>.<br/><br/>
Se denomina <strong>restauraci&#243;n del fondo</strong> a recuperar las zonas de pantalla en las que se han pintado gr&#225;ficos o escrito textos en la imagen anterior, es decir, &quot;<strong>despintar</strong>&quot; los gr&#225;ficos y &quot;<strong>desescribir</strong>&quot; los textos (borrarlos).<br/><br/>
Para establecer este valor se debe utilizar la siguiente sentencia:<br/><br/>
<strong>restore_type=partial_restore;</strong><br/><br/>
Con esta sentencia se indica al gestor de procesos de DIV Games Studio que, tras las siguientes im&#225;genes del juego, <strong>se deben restaurar &#250;nicamente las zonas de pantalla en las que se hayan pintado gr&#225;ficos o escrito textos</strong>.<br/><br/>
Esta modalidad de restauraci&#243;n (<strong>partial_restore</strong>) es m&#225;s r&#225;pida que una restauraci&#243;n completa (opci&#243;n por defecto), pero debe aplicarse &#250;nicamente en juegos, o secciones de los mismos, en los que <strong>NO exista una ventana de scroll o de modo 7 que ocupe la pantalla completa</strong>.<br/><br/>
Los tres tipos de restauraci&#243;n aplicables se corresponden con estas tres constantes:<br/><br/>
<a href="#1172">no_restore</a>       - El m&#225;s r&#225;pido, no se restaura el fondo<br/>
<strong>partial_restore</strong>  - Medio, restauraciones parciales<br/>
<a href="#1174">complete_restore</a> - El m&#225;s lento, restauraci&#243;n completa<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1113">restore_type</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1174">complete_restore</h2><br/><br/>
Constante: <strong>complete_restore</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable global predefinida <a href="#1113">restore_type</a> que sirve para definir el tipo de restauraci&#243;n que se debe aplicar al fondo de la pantalla tras cada imagen del juego. Su valor es<strong> 1</strong>.<br/><br/>
Se denomina <strong>restauraci&#243;n del fondo</strong> a recuperar las zonas de pantalla en las que se han pintado gr&#225;ficos o escrito textos en la imagen anterior, es decir, &quot;<strong>despintar</strong>&quot; los gr&#225;ficos y &quot;<strong>desescribir</strong>&quot; los textos (borrarlos).<br/><br/>
<strong>&#201;ste es el valor por defecto de la variable</strong> <a href="#1113">restore_type</a> y, de las tres modalidades de restauraci&#243;n disponible, es la <strong>m&#225;s lenta</strong>. Para establecer este valor se debe utilizar la siguiente sentencia:<br/><br/>
<strong>restore_type=complete_restore;</strong><br/><br/>
Con esta sentencia se indica al gestor de procesos de DIV Games Studio que tras las siguientes im&#225;genes del juego <strong>se debe restaurar completamente el fondo de la pantalla</strong>.<br/><br/>
Esta modalidad de restauraci&#243;n (<strong>complete_restore</strong>) es la m&#225;s lenta de todas (y es la opci&#243;n por defecto), por lo que puede cambiarse por otra para <strong>ganar velocidad</strong> de ejecuci&#243;n en el juego (con lo que ir&#225; m&#225;s fluido en los ordenadores lentos).<br/><br/>
En realidad, esta modalidad interesa &#250;nicamente en juegos, o secciones de los mismos, que <strong>no</strong> tengan una ventana de scroll o de modo 7 que ocupe toda la pantalla, pero que tengan una gran cantidad de gr&#225;ficos movi&#233;ndose por pantalla.<br/><br/>
Los tres tipos de restauraci&#243;n aplicables se corresponden con estas tres constantes:<br/><br/>
<a href="#1172">no_restore</a>       - El m&#225;s r&#225;pido, no se restaura el fondo<br/>
<a href="#1173">partial_restore</a>  - Medio, restauraciones parciales<br/>
<strong>complete_restore</strong> - El m&#225;s lento, restauraci&#243;n completa<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1113">restore_type</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1175">N&#250;meros de ventana</h2><br/><br/>
Constantes: <strong>c_0</strong> ... <strong>c_9</strong> <hr/>
<br/><br/>
Estas constantes se utilizan para asignarlas a la variable local predefinida <a href="#1134">cnumber</a> que sirve para definir las ventanas de scroll o modo 7 en las que debe aparecer el gr&#225;fico de un proceso.<br/><br/>
<strong>&#201;sto ser&#225; necesario solamente cuando se hayan activado varias ventanas de scroll o varias ventanas de modo 7, y NO se quiera que el gr&#225;fico del proceso se visualice en todas ellas</strong>.<br/><br/>
Pueden definirse hasta 10 ventanas de estos tipos, con los n&#250;meros del <strong>0</strong> al <strong>9</strong>, y que se corresponder&#225;n directamente con las constantes <strong>c_0</strong>, <strong>c_1</strong>, <strong>c_2</strong> ... <strong>c_9</strong>.<br/><br/>
Para que el gr&#225;fico de un proceso aparezca s&#243;lo en una de estas ventanas, se debe asignar la constante correspondiente a su variable local <a href="#1134">cnumber</a>. Por ejemplo, si se quisiera que el gr&#225;fico de un proceso apareciera &#250;nicamente en la ventana n&#250;mero 3 (de scroll o modo 7), se deber&#237;a incluir en su c&#243;digo la siguiente sentencia:<br/><br/>
<strong>cnumber=c_3;</strong><br/><br/>
Si se quiere que el gr&#225;fico de un proceso aparezca en varias ventanas de estas ventanas, entonces se deber&#225;n sumar las constantes. Por ejemplo, para que un proceso aparezca en las ventanas 0, 4, y 5 se realizar&#225; la siguiente asignaci&#243;n:<br/><br/>
<strong>cnumber=c_0+c_4+c_5;</strong><br/><br/>
Para que el gr&#225;fico aparezca en todas las ventanas, basta con asignar un <strong>0</strong> a la variable <a href="#1134">cnumber</a>. Aspecto que no ser&#225; necesario si esta variable no se ha modificado, pues &#233;se es su valor por defecto.<br/><br/>
Los valores a los que equivalen estas constantes se corresponden con las siguientes potencias de 2:<br/><br/>
<strong>c_0</strong> = 1   scroll / modo 7 n&#250;mero 0<br/>
<strong>c_1</strong> = 2   scroll / modo 7 n&#250;mero 1<br/>
<strong>c_2</strong> = 4   scroll / modo 7 n&#250;mero 2<br/>
<strong>c_3</strong> = 8   scroll / modo 7 n&#250;mero 3<br/>
<strong>c_4</strong> = 16  scroll / modo 7 n&#250;mero 4<br/>
<strong>c_5</strong> = 32  scroll / modo 7 n&#250;mero 5<br/>
<strong>c_6</strong> = 64  scroll / modo 7 n&#250;mero 6<br/>
<strong>c_7</strong> = 128 scroll / modo 7 n&#250;mero 7<br/>
<strong>c_8</strong> = 256 scroll / modo 7 n&#250;mero 8<br/>
<strong>c_9</strong> = 512 scroll / modo 7 n&#250;mero 9<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1134">cnumber</a>.<br/><br/>
<hr/>
<br/><br/>
<h2 id="1176">C&#243;digos de las teclas</h2><br/><br/>
Constantes: <strong>C&#243;digos de las teclas</strong> <hr/>
<br/><br/>
Estas constantes se utilizan normalmente como par&#225;metro de la funci&#243;n <a href="#128">key()</a>, para indicar qu&#233; tecla es la que se desea saber si est&#225; pulsada.<br/><br/>
Tambi&#233;n se pueden utilizar para comparar la variable global <a href="#1110">scan_code</a>, que contiene el c&#243;digo de la &#250;ltima tecla que se ha pulsado, con estos valores.<br/><br/>
Normalmente, para designar a cada constante se suele usar el car&#225;cter <strong>_</strong> (subrayado) seguido del nombre de la tecla, por ejemplo para la tecla [<strong>A</strong>], la constante referida a su c&#243;digo ser&#225; <strong>_a</strong>.<br/><br/>
La lista completa de estas constantes, con sus respectivos valores, es la siguiente (seg&#250;n la disposici&#243;n est&#225;ndar del teclado):<br/><br/>
<strong>_esc</strong>         = 1   [ESC] o escape<br/>
<strong>_f1</strong>          = 59  [F1] o funci&#243;n 1<br/>
<strong>_f2</strong>          = 60  [F2] o funci&#243;n 2<br/>
<strong>_f3</strong>          = 61  [F3] o funci&#243;n 3<br/>
<strong>_f4</strong>          = 62  [F4] o funci&#243;n 4<br/>
<strong>_f5</strong>          = 63  [F5] o funci&#243;n 5<br/>
<strong>_f6</strong>          = 64  [F6] o funci&#243;n 6<br/>
<strong>_f7</strong>          = 65  [F7] o funci&#243;n 7<br/>
<strong>_f8</strong>          = 66  [F8] o funci&#243;n 8<br/>
<strong>_f9</strong>          = 67  [F9] o funci&#243;n 9<br/>
<strong>_f10</strong>         = 68  [F10] o funci&#243;n 10<br/>
<strong>_f11</strong>         = 87  [F11] o funci&#243;n 11<br/>
<strong>_f12</strong>         = 88  [F12] o funci&#243;n 12 (TRAZADOR)<br/>
<strong>_prn_scr</strong>     = 55  [IMPR PANT] o impresi&#243;n pantalla<br/>
<strong>_scroll_lock</strong> = 70  [BLOQ DESPL] o bloqueo desplazamiento<br/>
<br/><br/>
<strong>_wave</strong>        = 41  Tecla [&#186;] o [&#170;]<br/>
<strong>_1</strong>           = 2   Tecla con el n&#250;mero &quot;1&quot;<br/>
<strong>_2</strong>           = 3   Tecla con el n&#250;mero &quot;2&quot;<br/>
<strong>_3</strong>           = 4   Tecla con el n&#250;mero &quot;3&quot;<br/>
<strong>_4</strong>           = 5   Tecla con el n&#250;mero &quot;4&quot;<br/>
<strong>_5</strong>           = 6   Tecla con el n&#250;mero &quot;5&quot;<br/>
<strong>_6</strong>           = 7   Tecla con el n&#250;mero &quot;6&quot;<br/>
<strong>_7</strong>           = 8   Tecla con el n&#250;mero &quot;7&quot;<br/>
<strong>_8</strong>           = 9   Tecla con el n&#250;mero &quot;8&quot;<br/>
<strong>_9</strong>           = 10  Tecla con el n&#250;mero &quot;9&quot;<br/>
<strong>_0</strong>           = 11  Tecla con el n&#250;mero &quot;0&quot;<br/>
<strong>_minus</strong>       = 12  Tecla con el s&#237;mbolo &quot;?&quot;<br/>
<strong>_plus</strong>        = 13  Tecla con el s&#237;mbolo &quot;&#191;&quot;<br/>
<br/><br/>
<strong>_backspace</strong>   = 14  Tecla de borrado ( &lt;- )<br/>
<strong>_tab</strong>         = 15  Tecla de tabulador [TAB]<br/>
<strong>_q</strong>           = 16  Tecla con la letra &quot;Q&quot;<br/>
<strong>_w</strong>           = 17  Tecla con la letra &quot;W&quot;<br/>
<strong>_e</strong>           = 18  Tecla con la letra &quot;E&quot;<br/>
<strong>_r</strong>           = 19  Tecla con la letra &quot;R&quot;<br/>
<strong>_t</strong>           = 20  Tecla con la letra &quot;T&quot;<br/>
<strong>_y</strong>           = 21  Tecla con la letra &quot;Y&quot;<br/>
<strong>_u</strong>           = 22  Tecla con la letra &quot;U&quot;<br/>
<strong>_i</strong>           = 23  Tecla con la letra &quot;I&quot;<br/>
<strong>_o</strong>           = 24  Tecla con la letra &quot;O&quot;<br/>
<strong>_p</strong>           = 25  Tecla con la letra &quot;P&quot;<br/>
<strong>_l_brachet</strong>   = 26  Tecla [^] o [`]<br/>
<strong>_r_brachet</strong>   = 27  Tecla [*] o [+]<br/>
<strong>_enter</strong>       = 28  [ENTER] (Intro o Retorno)<br/>
<br/><br/>
<strong>_caps_lock</strong>   = 58  [BLOQ MAYUS] o bloqueo may&#250;sculas<br/>
<strong>_a</strong>           = 30  Tecla con la letra &quot;A&quot;<br/>
<strong>_s</strong>           = 31  Tecla con la letra &quot;S&quot;<br/>
<strong>_d</strong>           = 32  Tecla con la letra &quot;D&quot;<br/>
<strong>_f</strong>           = 33  Tecla con la letra &quot;F&quot;<br/>
<strong>_g</strong>           = 34  Tecla con la letra &quot;G&quot;<br/>
<strong>_h</strong>           = 35  Tecla con la letra &quot;H&quot;<br/>
<strong>_j</strong>           = 36  Tecla con la letra &quot;J&quot;<br/>
<strong>_k</strong>           = 37  Tecla con la letra &quot;K&quot;<br/>
<strong>_l</strong>           = 38  Tecla con la letra &quot;L&quot;<br/>
<strong>_semicolon</strong>   = 39  Tecla con la letra &quot;&#209;&quot;<br/>
<strong>_apostrophe</strong>  = 40  Tecla [<strong>{</strong>]<br/>
<strong>_backslash</strong>   = 43  Tecla [<strong></strong>}]<br/>
<br/><br/>
<strong>_l_shift</strong>     = 42  [SHIFT] o may&#250;sculas izquierdo<br/>
<strong>_z</strong>           = 44  Tecla con la letra &quot;Z&quot;<br/>
<strong>_x</strong>           = 45  Tecla con la letra &quot;X&quot;<br/>
<strong>_c</strong>           = 46  Tecla con la letra &quot;C&quot;<br/>
<strong>_v</strong>           = 47  Tecla con la letra &quot;V&quot;<br/>
<strong>_b</strong>           = 48  Tecla con la letra &quot;B&quot;<br/>
<strong>_n</strong>           = 49  Tecla con la letra &quot;N&quot;<br/>
<strong>_m</strong>           = 50  Tecla con la letra &quot;M&quot;<br/>
<strong>_comma</strong>       = 51  Tecla [;] o [,]<br/>
<strong>_point</strong>       = 51  Tecla [:] o [.]<br/>
<strong>_slash</strong>       = 51  Tecla [_] o [-]<br/>
<strong>_r_shift</strong>     = 54  [SHIFT] o may&#250;sculas derecho<br/>
<br/><br/>
<strong>_control</strong>     = 29  Teclas [CONTROL]<br/>
<strong>_alt</strong>         = 56  Tecla [ALT] o [ALT GR]<br/>
<strong>_space</strong>       = 57  [SPACE] o barra espaciadora<br/>
<br/><br/>
<strong>_ins</strong>         = 82  [INSERT] o insertar<br/>
<strong>_home</strong>        = 71  [INICIO] o inicio de p&#225;gina<br/>
<strong>_pgup</strong>        = 73  [RE PAG] o retroceso de p&#225;gina<br/>
<strong>_del</strong>         = 83  [SUPR] o suprimir<br/>
<strong>_end</strong>         = 79  [FIN] o fin de p&#225;gina<br/>
<strong>_pgdn</strong>        = 81  [AV PAG] o avance de p&#225;gina<br/>
<br/><br/>
<strong>_up</strong>          = 72  Cursor para arriba<br/>
<strong>_down</strong>        = 80  Cursor para abajo<br/>
<strong>_left</strong>        = 75  Cursor para izquierda<br/>
<strong>_right</strong>       = 77  Cursor para derecha<br/>
<br/><br/>
<strong>_num_lock</strong>    = 69  [BLOQ NUM] o bloqueo num&#233;rico<br/>
<strong>_c_backslash</strong> = 53  S&#237;mbolo [/] del teclado num&#233;rico<br/>
<strong>_c_asterisk</strong>  = 55  S&#237;mbolo [*] del teclado num&#233;rico<br/>
<strong>_c_minus</strong>     = 74  S&#237;mbolo [-] del teclado num&#233;rico<br/>
<strong>_c_home</strong>      = 71  [INICIO] del teclado num&#233;rico<br/>
<strong>_c_up</strong>        = 72  Cursor arriba del teclado num&#233;rico<br/>
<strong>_c_pgup</strong>      = 73  [RE PAG] del teclado num&#233;rico<br/>
<strong>_c_left</strong>      = 75  Cursor izquierda del teclado num&#233;rico<br/>
<strong>_c_center</strong>    = 76  Tecla [5] del teclado num&#233;rico<br/>
<strong>_c_right</strong>     = 77  Cursor derecha del teclado num&#233;rico<br/>
<strong>_c_end</strong>       = 79  [FIN] del teclado num&#233;rico<br/>
<strong>_c_down</strong>      = 80  Cursor abajo del teclado num&#233;rico<br/>
<strong>_c_pgdn</strong>      = 81  [AV PAG] del teclado num&#233;rico<br/>
<strong>_c_ins</strong>       = 82  [INS] del teclado num&#233;rico<br/>
<strong>_c_del</strong>       = 83  [SUPR] del teclado num&#233;rico<br/>
<strong>_c_plus</strong>      = 78  S&#237;mbolo [+] del teclado num&#233;rico<br/>
<strong>_c_enter</strong>     = 28  [ENTER] del teclado num&#233;rico<br/>
<br/><br/>
Resulta indiferente utilizar estas constantes o los valores num&#233;ricos que representan, es decir, se puede llamar a la funci&#243;n <a href="#128">key()</a>, para comprobar si est&#225; pulsada la tecla [<strong>A</strong>], como <strong>key(_a)</strong> o bien como <strong>key(30)</strong> (se puede comprobar en la lista anterior que <strong>30</strong> es el valor num&#233;rico de la constante <strong>_a</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Importante:</strong> Algunos de estos c&#243;digos pueden diferir en ciertos teclados, en caso de duda se puede ejecutar el siguiente programa ejemplo, que muestra en pantalla una tabla, correspondiente con la funci&#243;n <a href="#128">key()</a> (indicando los <strong>c&#243;digos de las teclas que est&#225;n pulsadas</strong> en cada momento), adem&#225;s de los valores de las variables <a href="#1110">scan_code</a>, <a href="#1109">ascii</a> y <a href="#1108">shift_status</a> (relacionados igualmente con la lectura del teclado).<br/><br/>
<strong>Programa ejemplo:</strong><br/>
<pre>
PROGRAM ejemplo_c&#243;digos_del_teclado;

GLOBAL
    teclas[128];

BEGIN
    write(0, 0, 0, 0, &quot;C&#243;digos de las teclas pulsadas, seg&#250;n key()&quot;);
    FROM x=0 TO 127;
        write_int(0, (x%16)*20, (x/16)*10+20, 0, OFFSET teclas[x]);
    END
    write(0, 0, 160, 0, &quot;C&#243;digo de la &#250;ltima tecla pulsada (scan_code):&quot;);
    write_int(0, 320, 160, 2, OFFSET scan_code);
    write(0, 0, 180, 0, &quot;C&#243;digo ASCII de la &#250;ltima tecla (ascii):&quot;);
    write_int(0, 320, 180, 2, OFFSET ascii);
    write(0, 0, 190, 0, &quot;Estado de las teclas especiales (shift_status):&quot;);
    write_int(0, 320, 190, 2, OFFSET shift_status);
    LOOP
        FROM x=1 TO 127;
            IF (key(x))
                teclas[x]=x;
            ELSE
                teclas[x]=0;
            END
        END
        FRAME;
    END
END
</pre>
Este programa se puede utilizar (pulsando con el rat&#243;n sobre el texto &quot;<strong>Programa ejemplo:</strong>&quot; y despu&#233;s la tecla [<strong>F10</strong>]) para averiguar el c&#243;digo que tiene alguna tecla en concreto.<br/><br/>
Despu&#233;s podr&#225; utilizarse dicho c&#243;digo num&#233;rico como par&#225;metro de la funci&#243;n <a href="#128">key()</a>, para comprobar en el juego si dicha tecla est&#225; pulsada en un momento determinado.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#128">key()</a> - <a href="#1110">scan_code</a> - <a href="#1109">ascii</a> - <a href="#1108">shift_status</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1177">min_int</h2><br/><br/>
Constante: <strong>min_int</strong> <hr/>
<br/><br/>
Esta constante define el valor m&#237;nimo que puede almacenar cualquier dato en este lenguaje. Este valor es<strong> -2147483648</strong>.<br/><br/>
Todos los datos son <strong>enteros</strong> con signo de 32 bits en este lenguaje. Por ello, &#250;nicamente se pueden manejar n&#250;meros enteros dentro del rango (<strong> -2147483648</strong> ...<strong> +2147483647</strong> ).<br/><br/>
Cuando el resultado de una operaci&#243;n aritm&#233;tica exceda dicho rango, el sistema no advertir&#225; de ning&#250;n error, por lo que se deben extremar las precauciones para que &#233;sto no suceda.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1178">max_int</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1178">max_int</h2><br/><br/>
Constante: <strong>max_int</strong> <hr/>
<br/><br/>
Esta constante define el valor m&#225;ximo que puede almacenar cualquier dato en este lenguaje. Este valor es<strong> 2147483647</strong>.<br/><br/>
Todos los datos son <strong>enteros</strong> con signo de 32 bits en este lenguaje, de ah&#237; que, &#250;nicamente, se pueden manejar n&#250;meros enteros dentro del rango (<strong> -2147483648</strong> ...<strong> +2147483647</strong> ).<br/><br/>
Cuando el resultado de una operaci&#243;n aritm&#233;tica exceda dicho rango, el sistema no advertir&#225; de ning&#250;n error, por lo que se deben extremar las precauciones para que esto no suceda.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1177">min_int</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1179">pi</h2><br/><br/>
Constante: <strong>pi</strong> <hr/>
<br/><br/>
Esta constante define la equivalencia en <strong>mil&#233;simas de grado</strong> de la constante matem&#225;tica <strong>pi</strong> (aproximadamente <strong>3.14159265</strong> radianes).<br/><br/>
Su valor es <strong>180000</strong> mil&#233;simas de grado (180 grados), equivalente a <strong>pi radianes</strong>.<br/><br/>
Se suele utilizar para definir &#225;ngulos; por ejemplo, se podr&#237;a definir <strong>180 grados</strong> como <strong>pi</strong>,<strong> -90 grados</strong> como<strong> -pi/2</strong>, <strong>45 grados</strong> como <strong>pi/4</strong>, etc.<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1044">Uso de &#225;ngulos en el lenguaje</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1200">Datos globales predefinidos</h2><br/><br/>
A continuaci&#243;n se describe cada uno de los datos globales predefinidos.<br/><br/>
<a href="#1413">STRUCT dirinfo</a>         - Lista de archivos de un directorio<br/>
<a href="#1414">STRUCT fileinfo</a>        - Informaci&#243;n sobre un archivo<br/>
<a href="#1103">STRUCT joy</a>             - Par&#225;metros del joystick<br/>
<a href="#1102">STRUCT m7[9]</a>           - Control de las ventanas de modo 7<br/>
<a href="#1411">STRUCT m8[9]</a>           - Control de las ventanas de modo 8<br/>
<a href="#1100">STRUCT mouse</a>           - Par&#225;metros del rat&#243;n<br/>
<a href="#1410">STRUCT net</a>             - Par&#225;metros del hardware de red<br/>
<a href="#1101">STRUCT scroll[9]</a>       - Control de las ventanas de scroll<br/>
<a href="#1104">STRUCT setup</a>           - Control de la tarjeta de sonido<br/>
<a href="#1415">STRUCT video_modes[31]</a> - Modos de v&#237;deo disponibles<br/>
<br/><br/>
<a href="#1409">argc</a>             - N&#250;mero de argumentos<br/>
<a href="#1409">argv[]</a>           - Argumentos del programa<br/>
<a href="#1109">ascii</a>            - Lectura de c&#243;digos ASCII del teclado<br/>
{#1416,channel[31]       - Canales de sonido<br/>
<a href="#1418">draw_z</a>           - Plano de profundidad de las primitivas<br/>
<a href="#1114">dump_type</a>        - Tipo de volcado de la pantalla<br/>
<a href="#1107">fading</a>           - Indicador de fundido de pantalla<br/>
<a href="#1426">fps</a>              - N&#250;mero de im&#225;genes por segundo<br/>
<a href="#1111">joy_filter</a>       - Filtro aplicado al joystick<br/>
<a href="#1112">joy_status</a>       - Estado del joystick<br/>
<a href="#1115">max_process_time</a> - Tiempo m&#225;ximo de ejecuci&#243;n de un proceso<br/>
<a href="#1419">num_video_modes</a>  - N&#250;mero de modos de v&#237;deo detectados<br/>
<a href="#1113">restore_type</a>     - Tipo de restauraci&#243;n de la pantalla<br/>
<a href="#1110">scan_code</a>        - Lectura de c&#243;digos del teclado<br/>
<a href="#1108">shift_status</a>     - Estado de las teclas especiales<br/>
<a href="#1106">text_z</a>           - Plano de profundidad de los textos<br/>
<a href="#1105">timer[9]</a>         - Contadores de tiempo<br/>
<a href="#1420">unit_size</a>        - Tama&#241;o de la unidad de lectura/escritura<br/>
<a href="#1417">vsync</a>            - Esperar al retrazo vertical<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1201">Datos locales</a> - <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1201">Datos locales predefinidos</h2><br/><br/>
A continuaci&#243;n se describe cada uno de los datos locales predefinidos.<br/><br/>
<a href="#1116">STRUCT reserved</a> - Par&#225;metros internos de los procesos<br/>
<br/><br/>
<a href="#1129">angle</a>           - &#225;ngulo del gr&#225;fico del proceso<br/>
<a href="#1120">bigbro</a>          - Identificador del hermano mayor del proceso<br/>
<a href="#1134">cnumber</a>         - N&#250;meros de ventanas de scroll o modo 7<br/>
<a href="#1122">ctype</a>           - Tipo de coordenadas utilizadas por el proceso<br/>
<a href="#1117">father</a>          - Identificador de padre del proceso<br/>
<a href="#1131">file</a>            - C&#243;digo del fichero del gr&#225;fico del proceso<br/>
<a href="#1127">flags</a>           - Indicadores de espejado y transparencia<br/>
<a href="#1126">graph</a>           - C&#243;digo del gr&#225;fico asignado al proceso<br/>
<a href="#1133">height</a>          - Altura del proceso en ventanas de modo 7<br/>
<a href="#1424">m8_nextsector</a>   - Sector hacia el que se dirige el proceso<br/>
<a href="#1423">m8_sector</a>       - N&#250;mero de sector en el que est&#225; el proceso<br/>
<a href="#1425">m8_step</a>         - Altura que puede subir el proceso<br/>
<a href="#1422">m8_wall</a>         - Pared del mapa contra la que se colisiona<br/>
<a href="#1121">priority</a>        - Prioridad de ejecuci&#243;n del proceso<br/>
<a href="#1421">radius</a>          - Radio de los procesos de modo 8<br/>
<a href="#1130">region</a>          - Regi&#243;n de pantalla asignada al proceso<br/>
<a href="#1135">resolution</a>      - Resoluci&#243;n de las coordenadas del proceso<br/>
<a href="#1128">size</a>            - Tama&#241;o del gr&#225;fico del proceso<br/>
<a href="#1119">smallbro</a>        - Identificador del hermano peque&#241;o del proceso<br/>
<a href="#1118">son</a>             - Identificador del hijo del proceso<br/>
<a href="#1132">xgraph</a>          - OFFSET de la tabla gr&#225;fica del proceso<br/>
<a href="#1123">x</a>               - Coordenada horizontal del proceso<br/>
<a href="#1124">y</a>               - Coordenada vertical del proceso<br/>
<a href="#1125">z</a>               - Plano de profundidad del gr&#225;fico del proceso<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1200">Datos globales</a> - <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1202">Constantes predefinidas</h2><br/><br/>
A continuaci&#243;n se describe cada una de las constantes predefinidas.<br/><br/>
<a href="#1176">_a, _b, _c, ...</a>       - C&#243;digos del teclado<br/>
<a href="#1400">_case_sensitive</a>       - Distingir may&#250;sculas y min&#250;sculas<br/>
<a href="#1400">_extended_conditions</a>  - Condiciones complejas<br/>
<a href="#1400">_free_sintax</a>          - Sint&#225;xis libre<br/>
<a href="#231">_hidden</a>               - Archivo oculto<br/>
<a href="#1400">_ignore_errors</a>        - Ignorar todos los errores<br/>
<a href="#1400">_max_process</a>          - N&#250;mero m&#225;ximo de procesos<br/>
<a href="#1400">_no_check</a>             - No comprobar errores de ejecuci&#243;n<br/>
<a href="#1400">_no_id_check</a>          - No comprobar los identificadores<br/>
<a href="#1400">_no_null_check</a>        - No comprobar accesos a NULL<br/>
<a href="#1400">_no_optimization</a>      - No optimizar el c&#243;digo<br/>
<a href="#1400">_no_range_check</a>       - No comprobar el rango<br/>
<a href="#1400">_no_strfix</a>            - No ampliar las cadenas de texto<br/>
<a href="#231">_normal</a>               - Archivo normal<br/>
<a href="#1400">_simple_conditions</a>    - Condiciones simples<br/>
<a href="#231">_subdir</a>               - Subdirectorio<br/>
<a href="#231">_system</a>               - Archivo de sistema<br/>
<a href="#231">_volid</a>                - Etiqueta de volumen<br/>
<a href="#250">all_drawing</a>           - Indicador de todas las primitivas<br/>
<a href="#1162">all_sound</a>             - Indicador de todos los sonidos<br/>
<a href="#1161">all_text</a>              - Indicador de todos los textos<br/>
<a href="#1175">c_0 .. c_9</a>            - Indicadores de ventanas<br/>
<a href="#1169">c_m7</a>                  - Coordenadas de ventana de modo7<br/>
<a href="#1412">c_m8</a>                  - Coordenadas de ventana de modo8<br/>
<a href="#1167">c_screen</a>              - Coordenadas de pantalla<br/>
<a href="#1168">c_scroll</a>              - Coordenadas de ventana de scroll<br/>
<a href="#1171">complete_dump</a>         - Volcado de fondo completo<br/>
<a href="#1174">complete_restore</a>      - Restauraci&#243;n de pantalla completa<br/>
<a href="#1152">false</a>                 - Valores falso<br/>
<a href="#1104">fast_mixer</a>            - Mezclado r&#225;pido<br/>
<a href="#1164">g_height</a>              - Indicador de alto<br/>
<a href="#1163">g_wide</a>                - Indicador de ancho<br/>
<a href="#1165">g_x_center</a>            - Indicador de centro horizontal<br/>
<a href="#1166">g_y_center</a>            - Indicador de centro vertical<br/>
<a href="#1150">m320x200 .. m1024x768</a> - Modos de v&#237;deo<br/>
<a href="#1178">max_int</a>               - Valor m&#225;ximo de datos<br/>
<a href="#1177">min_int</a>               - Valor m&#237;nimo de datos<br/>
<a href="#1172">no_restore</a>            - Restauraci&#243;n de pantalla desactivada<br/>
<a href="#1170">partial_dump</a>          - Volcado de fondo parcial<br/>
<a href="#1173">partial_restore</a>       - Restauraci&#243;n de pantalla parcial<br/>
<a href="#1179">pi</a>                    - Valor matem&#225;tico de pi<br/>
<a href="#1104">quality_mixer</a>         - Mezclado de calidad<br/>
<a href="#1160">s_freeze_tree</a>         - Se&#241;al de congelar procesos e hijos<br/>
<a href="#1156">s_freeze</a>              - Se&#241;al de congelar procesos<br/>
<a href="#1157">s_kill_tree</a>           - Se&#241;al de matar procesos e hijos<br/>
<a href="#1153">s_kill</a>                - Se&#241;al de matar procesos <br/>
<a href="#1159">s_sleep_tree</a>          - Se&#241;al de dormir procesos e hijos<br/>
<a href="#1155">s_sleep</a>               - Se&#241;al de dormir procesos<br/>
<a href="#1158">s_wakeup_tree</a>         - Se&#241;al de despertar procesos e hijos<br/>
<a href="#1154">s_wakeup</a>              - Se&#241;al de despertar procesos<br/>
<a href="#227">seek_cur</a>              - Posici&#243;n actual del archivo<br/>
<a href="#227">seek_end</a>              - Posici&#243;n final del archivo<br/>
<a href="#227">seek_set</a>              - Comienzo del archivo<br/>
<a href="#1104">sound_bits_16</a>         - Muestras de 16 bit<br/>
<a href="#1104">sound_bits_8</a>          - Muestras de 8 bit<br/>
<a href="#1151">true</a>                  - Valor verdadero<br/>
<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1201">Datos locales</a> - <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1291">Comandos en el entorno gr&#225;fico</h2><br/><br/>
<strong>Comandos en el entorno gr&#225;fico</strong><br/><br/>
<hr/>
<br/><br/>
<strong>ALT+X</strong>         - Salir del entorno gr&#225;fico al sistema operativo.<br/>
<strong>ESC+Control</strong>   - Salir directamente del entorno y de los programas.<br/>
<br/><br/>
<strong>ALT+S</strong>         - Ejecutar una sesi&#243;n del sistema operativo MS-DOS.<br/>
<br/><br/>
<strong>ESC</strong>           - Para anular o cancelar un cuadro de di&#225;logo.<br/>
<strong>TAB</strong>           - Para elegir el control seleccionado de una ventana o cuadro.<br/>
<strong>Enter</strong>         - Para activar el control seleccionado.<br/>
<br/><br/>
<strong>F1</strong>            - Invocar la ventana de ayuda.<br/>
<br/><br/>
<strong>F2</strong>            - Guardar el programa seleccionado.<br/>
<strong>F4</strong>            - Abrir un programa.<br/>
<strong>F10</strong>           - Guardar y ejecutar el programa seleccionado.<br/>
<strong>F11</strong>           - Compilar el programa seleccionado.<br/>
<strong>F12</strong>           - Guardar y trazar el programa seleccionado.<br/>
<br/><br/>
<strong>Control+ALT+P</strong> - Grabar una captura del entorno gr&#225;fico (DIV_*.PCX)<br/>
<br/><br/>
<hr/>
<br/><br/>
<h2 id="1292">Comandos comunes en los juegos</h2><br/><br/>
<strong>Comandos comunes en los juegos</strong><br/><br/>
<hr/>
<br/><br/>
<strong>ALT+X</strong>        - Salir del juego.<br/>
<strong>ESC+Control</strong>  - Salir del juego.<br/>
<br/><br/>
<strong>Contro+ALT+P</strong> - Grabar una captura del juego (SNAP*.PCX)<br/>
<strong>F12</strong>          - Invocar al trazador de programas.<br/>
<strong>Pausa</strong>        - Detener el juego moment&#225;neamente.<br/>
<br/><br/>
<hr/>
<br/><br/>
<h2 id="1293">Comandos en el trazador de programas</h2><br/><br/>
<strong>Comandos en el trazador de programas</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Cursores</strong>  - Movimiento por el listado.<br/>
<strong>Re.P&#225;g.</strong>   - P&#225;gina anterior.<br/>
<strong>Av.Pag.</strong>   - Siguiente p&#225;gina.<br/>
<br/><br/>
<strong>F4</strong>        - Ejecutar hasta llegar a la l&#237;nea seleccionada.<br/>
<strong>F5</strong>        - Ver el listado de un proceso.<br/>
<strong>F6</strong>        - Ejecutar el proceso actual.<br/>
<strong>F7</strong>        - Ver o editar datos.<br/>
<strong>F8</strong>        - Trazar sentencia.<br/>
<strong>F9</strong>        - Fijar un punto de ruptura.<br/>
<strong>F10</strong>       - Ejecutar la siguiente sentencia o llamada a proceso.<br/>
<strong>F11</strong>       - Ver los perfiles de tiempo del programa.<br/>
<strong>F12</strong>       - Invocar al trazador / Avanzar im&#225;genes.<br/>
<br/><br/>
<strong>F</strong>             - Ejectuar hasta la siguiente imagen.<br/>
<br/><br/>
<strong>TAB</strong>           - Seleccionar bot&#243;n.<br/>
<strong>Enter</strong>         - Activar bot&#243;n.<br/>
<strong>ESC</strong>           - Salir del trazador.<br/>
<br/><br/>
<hr/>
<br/><br/>
<h2 id="1294">Comandos en el editor de programas</h2><br/><br/>
<strong>Comandos en el editor de programas</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Comandos gen&#233;ricos</strong><br/><br/>
<hr/>
<br/><br/>
<strong>F5</strong>        - Saltar al inicio de un proceso del programa.<br/>
<strong>Control+Z</strong> - Ampliar la ventana de programa seleccionada.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Comandos de movimiento y edici&#243;n b&#225;sicos</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Cursores</strong>                  - Movimiento b&#225;sico del cursor.<br/>
<strong>Inicio</strong>                    - Saltar al inicio de la l&#237;nea.<br/>
<strong>Fin</strong>                       - Saltar al final de la l&#237;nea.<br/>
<strong>Av.P&#225;g.</strong>                   - Siguiente p&#225;gina.<br/>
<strong>Re.P&#225;g.</strong>                   - P&#225;gina anterior.<br/>
<strong>Insertar</strong>                  - Conmutar entre inserci&#243;n y sobreescritura.<br/>
<strong>Suprimir</strong>                  - Borrar el car&#225;cter del cursor.<br/>
<strong>Borrar</strong>                    - Borrar el car&#225;cter anterior al cursor.<br/>
<strong>TAB</strong>                       - Saltar a la siguiente tabulaci&#243;n.<br/>
<strong>May&#250;sculas+TAB</strong>            - Destabular.<br/>
<strong>Control+Borrar, Control+Y</strong> - Borrar l&#237;nea actual.<br/>
<strong>Control+Derecha</strong>           - Siguiente palabra.<br/>
<strong>Control+Izquierda</strong>         - Palabra anterior.<br/>
<strong>Control+Re.P&#225;g.</strong>           - Saltar al inicio del programa.<br/>
<strong>Control+Av.P&#225;g.</strong>           - Saltar al final delprograma.<br/>
<strong>Control+Inicio</strong>            - Saltar al incio de la p&#225;gina.<br/>
<strong>Control+Fin</strong>               - Saltar al final de la p&#225;gina.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Comandos de b&#250;squeda y sustituci&#243;n</strong><br/><br/>
<hr/>
<br/><br/>
<strong>ALT+F, Control+F</strong>     - Buscar un texto.<br/>
<strong>ALT+N, F3, Control+L</strong> - Repetir b&#250;squeda.<br/>
<strong>ALT+R, Control+R</strong>     - Sustituir texto.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Comandos de bloques tipo QEDIT</strong><br/><br/>
<hr/>
<br/><br/>
<strong>ALT+A</strong>        - Marcar el inicio o final de un bloque permanente.<br/>
<strong>ALT+U</strong>        - Desmarcar el bloque permanente.<br/>
<strong>ALT+C</strong>        - Copiar el bloque a la posici&#243;n actual.<br/>
<strong>ALT+M</strong>        - Mover el bloque a la posici&#243;n actual.<br/>
<strong>ALT+D, ALT+G</strong> - Borrar el bloque.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Comandos de bloques tipo EDIT</strong><br/><br/>
<hr/>
<br/><br/>
<strong>May&#250;sculas+Movimiento</strong>    - Marcar bloque vol&#225;til (Teclas de movimiento: <strong>Cursores, Control + Derecha, Control + Izquierda, Re.P&#225;g, Av.P&#225;g., Inicio, Fin</strong>).<br/>
<br/><br/>
<strong>May&#250;sculas+Insertar</strong> - Pegar bloque.<br/>
<strong>Control+Insertar</strong>    - Copiar bloque.<br/>
<strong>May&#250;sculas+Suprimir</strong> - Cortar bloque.<br/>
<br/><br/>
<strong>Control+X</strong>           - Cortar bloque.<br/>
<strong>Control+C</strong>           - Copiar bloque.<br/>
<strong>Control+V</strong>           - Pegar bloque.<br/>
<br/><br/>
<strong>Suprimir</strong>            - Borrar bloque.<br/>
<br/><br/>
<hr/>
<br/><br/>
<h2 id="1295">Comandos en el editor gr&#225;fico</h2><br/><br/>
<strong>Comandos en el editor gr&#225;fico</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Comandos gen&#233;ricos</strong><br/><br/>
<hr/>
<br/><br/>
<strong>F1</strong>                    - Invocar la ventana de ayuda.<br/>
<br/><br/>
<strong>ESC</strong>                   - Salir del editor gr&#225;fico.<br/>
<br/><br/>
<strong>Cursores, OP/QA</strong>       - Movimiento del cursor.<br/>
<strong>Barra espaciadora</strong>     - Equivale a pulsar con bot&#243;n izquierdo del rat&#243;n.<br/>
<strong>May&#250;sculas+Movimiento</strong> - Movimiento de 8 en 8 puntos.<br/>
<strong>May&#250;sculas+Bot&#243;n izq.</strong> - Coger color de pantalla.<br/>
<br/><br/>
<strong>W, S</strong>                  - Elegir color dentro de la gama actual.<br/>
<strong>May&#250;sculas+W, S</strong>       - Elegir gama actual.<br/>
<strong>Control+Cursores</strong>      - Elegir color y gama.<br/>
<br/><br/>
<strong>Borrar</strong>                - Deshacer.<br/>
<strong>May&#250;sculas+Borrar</strong>     - Repetir acci&#243;n (rehacer).<br/>
<br/><br/>
<strong>0</strong>                     - Seleccionar el color transparente.<br/>
<strong>B</strong>                     - Resaltar el color transparente.<br/>
<strong>C</strong>                     - Ventana de colores.<br/>
<strong>M</strong>                     - Ventana de m&#225;scara.<br/>
<strong>T</strong>                     - Seleccionar pincel.<br/>
<strong>U</strong>                     - Seleccionar textura.<br/>
<strong>X</strong>                     - Visualizar textura.<br/>
<strong>Z</strong>                     - Cambiar nivel de ampliaci&#243;n.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Comandos de selecci&#243;n de herramienta</strong><br/><br/>
<hr/>
<br/><br/>
<strong>F2</strong>             - L&#225;piz, para el trazo a mano alzada.<br/>
<strong>F3</strong>             - L&#237;neas rectas.<br/>
<strong>F4</strong>             - Multil&#237;nea, l&#237;neas encadenadas.<br/>
<strong>F5</strong>             - Curvas b&#233;zier.<br/>
<strong>F6</strong>             - Multicurva, curvas encadenadas.<br/>
<strong>F7</strong>             - Rect&#225;ngulos y cajas.<br/>
<strong>F8</strong>             - C&#237;rculos y circunferencias.<br/>
<strong>F9</strong>             - Spray de pintura.<br/>
<strong>F10</strong>            - Relleno de superficies.<br/>
<strong>F11</strong>            - Edici&#243;n de bloques.<br/>
<strong>F12</strong>            - Deshacer y rehacer acciones.<br/>
<strong>May&#250;sculas+F1</strong>  - Escribir textos.<br/>
<strong>May&#250;sculas+F2</strong>  - Situar puntos de control.<br/>
<strong>May&#250;sculas+F3</strong>  - Barra de punteado.<br/>
<br/><br/>
<hr/>
<br/><br/>
<strong>Comandos espec&#237;ficos</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Control</strong>  - Mover selecci&#243;n (barra: seleccionar bloque).<br/>
<strong>Control</strong>  - Igualar ancho y alto (barras: rect&#225;ngulos y c&#237;rculos).<br/>
<strong>D</strong>        - Difuminar (barras: l&#225;piz, l&#237;neas, curvas y spray).<br/>
<strong>H</strong>        - Esconder cursor (barra: mover bloque).<br/>
<strong>K</strong>        - Copiar a ventana (barra: seleccionar bloque).<br/>
<strong> +, -</strong>    - Variar tensi&#243;n (barra: multicurva).<br/>
<strong> +, -</strong>    - Cambiar punto de control (barra: putos de control).<br/>
<br/><br/>
<hr/>
<br/><br/>
<h2 id="1300">Preguntas comunes sobre DIV</h2><br/><br/>
<strong>&#191;Donde puedo encontrar m&#225;s informaci&#243;n sobre DIV?</strong><br/><br/>
Existen muchos usuarios que est&#225;n apoyando el programa con p&#225;ginas en Internet, estas se pueden acceder a partir de <strong>WWW.DIVGAMES.COM</strong>, que es la p&#225;gina oficial del producto. Adem&#225;s existen <strong>listas de correo</strong> donde se solucionan problemas, y canales de CHAT sobre el lenguaje de programaci&#243;n (el canal<strong> #div</strong> de IRC Hispano).<br/><br/>
<strong>&#191;Como obtener ayuda sobre ... ?</strong><br/><br/>
Todas las opciones accesibles desde cualquier men&#250; de opciones se describen exclusivamente en el <strong>manual de usuario</strong> de DIV Games Studio 2.<br/><br/>
<strong>&#191;Como resolver un problema de configuraci&#243;n?</strong><br/><br/>
Para problemas de sonido, instalaciones incompletas, etc., vea el apartado de <a href="#2003">resoluci&#243;n de problemas</a> de esta ayuda electr&#243;nica.<br/><br/>
<strong>&#191;Cuales son las mejoras de esta versi&#243;n?</strong><br/><br/>
Estas se dividen en dos grupos: las <a href="#2001">novedades del lenguaje</a> (explicadas en esta <strong>ayuda</strong>), y las <a href="#2002">novedades del entorno</a> (explicadas en el <strong>manual de usuario</strong>).<br/><br/>
<strong>&#191;Porqu&#233; me dice &quot;No se reconoce el tipo de fichero&quot;?</strong><br/><br/>
Es posible que est&#233; intentando cargar un archivo con el men&#250; incorrecto, es decir, el men&#250; de paletas s&#243;lo sirve para cargar paletas, el de ficheros s&#243;lo para cargar ficheros de gr&#225;ficos (grupos de gr&#225;ficos), el de programas para cargar programas o archivos de texto, etc.<br/><br/>
Tambi&#233;n es posible que est&#233; intentando cargar un mapa PCX o BMP True Color, esta versi&#243;n de DIV &#250;nicamente puede trabajar a 256 colores, no siendo posible importar este tipo de archivos. Deber&#225; convertir el gr&#225;fico que quiere cargar en DIV a 256 colores con otra herramienta primero.<br/><br/>
<strong>&#191;Como se debe arrastrar un gr&#225;fico?</strong><br/><br/>
Para arrastrar un gr&#225;fico se debe pulsar con el bot&#243;n izquierdo del rat&#243;n sobre la ventana del mapa, pero no sobre la barra de t&#237;tulo, sino sobre el propio gr&#225;fico contenido en la ventana. Despu&#233;s bastar&#225; con mover el rat&#243;n hasta la posici&#243;n en la que se desea dejar el gr&#225;fico y soltar entonces el bot&#243;n izquierdo (se pueden arrastrar mapas a ficheros, a la papelera, al tapiz de fondo, a otros mapas o al generador de fuentes).<br/><br/>
<strong>&#191;Como extraer un gr&#225;fico contenido en otro?</strong><br/><br/>
Se debe acceder a la barra de edici&#243;n de bloques para seleccionar la parte del gr&#225;fico que se quiere extraer. La selecci&#243;n se puede realizar de varias formas, como un rect&#225;ngulo, dibujando el contorno, etc.<br/><br/>
Una vez realizada la selecci&#243;n aparecer&#225;n algunos iconos nuevos en la barra de herramientas, entre ellos el icono de <strong>cortar a ventana</strong>. Al pulsar sobre este icono <strong>se crea una nueva ventana de mapa</strong> en el escritorio <strong>y se pega la zona seleccionada</strong> en el mismo.<br/><br/>
<strong>&#191;Como se cortan y copian gr&#225;ficos?</strong><br/><br/>
Ver tambi&#233;n la pregunta anterior. Para cortar y mover gr&#225;ficos se debe acceder a la <strong>barra de edici&#243;n de bloques</strong>, dentro del programa de dibujo, seleccionando el icono que muestra unas tijeras.<br/><br/>
Desde el escritorio se pueden realizar algunas operaciones, como copiar un gr&#225;fico a otro, esto se puede hacer arrastrando el primer gr&#225;fico hasta el segundo. Tambi&#233;n se puede crear una copia de un gr&#225;fico si se arrastra el mismo hasta el tapiz de fondo (una zona del escritorio que no contenga ninguna ventana).<br/><br/>
<strong>&#191;Que debo hacer si el sistema se vuelve inestable?</strong><br/><br/>
DIV Games Studio es un programa muy complejo y, aunque es bastante s&#243;lido en su ejecuci&#243;n, puede que el alg&#250;n equipo de alg&#250;n error al realizar una acci&#243;n determinada, o bien se bloquee el ordenador.<br/><br/>
En estos casos, para volver el sistema a su estado original, debe cargar DIV desde la l&#237;nea de comandos de MSDOS indicando el par&#225;metro<strong> /SAFE</strong> (introduciendo el comando D.EXE /SAFE desde el directorio en el que se instal&#243; el programa), para entrar en el &quot;Modo a prueba de fallos&quot;.<br/><br/>
<strong>&#191;Que debo hacer para aprender a programar?</strong><br/><br/>
Los conceptos b&#225;sicos no se explican en esta ayuda, sino en el manual de usuario de DIV Games Studio 2, en los cap&#237;tulos 4, 5 y 6.<br/><br/>
Adem&#225;s se puede aprender mucho de los ejemplos de las funciones del lenguaje (ver la lista de funciones en la ayuda sobre el lenguaje) y de los tutoriales, que son unos mini-juegos muy sencillos y dise&#241;ados para facilitar el aprendizaje del lenguaje (estos tutoriales se pueden encontrar en el directorio PRG\TUTOR de DIV Games Studio 2).<br/><br/>
<strong>&#191;C&#243;mo se cargan los gr&#225;ficos en los juegos?</strong><br/><br/>
En un juego se pueden utilizar los gr&#225;ficos contenidos en los mapas (archivos MAP o PCX), carg&#225;ndolos de uno en uno con las funciones <a href="#174">load_map()</a> o <a href="#174">load_pcx</a>, o bien metiendo varios gr&#225;ficos en un fichero FPG de gr&#225;ficos y carg&#225;ndolos despu&#233;s con la funci&#243;n <a href="#132">load_fpg()</a>, esta &#250;ltima opci&#243;n tiene la ventaja de que se pueden cargar y descargar muchos gr&#225;ficos de golpe en el juego.<br/><br/>
Despu&#233;s se suelen utilizar los gr&#225;ficos para asign&#225;rselos a la variable <a href="#1126">LOCAL graph</a> de los procesos del juego.<br/><br/>
<strong>&#191;Como mostrar un nuevo gr&#225;fico en un juego?</strong><br/><br/>
Para crear un nuevo gr&#225;fico o &quot;sprite&quot; en un juego, se debe primero crear un nuevo proceso (<a href="#1016">PROCESS</a>) con las &#243;rdenes que regir&#225;n el comportamiento del mismo en el juego, despu&#233;s cada vez que se quiera crear un proceso de dicho tipo, se deber&#225; llamar al proceso (ver como se hace una <a href="#1033">llamada a un proceso</a>).<br/><br/>
<strong>&#191;Como eliminar un proceso?</strong><br/><br/>
Para eliminar o &quot;matar&quot; a un proceso del juego, se puede ejecutar una sentencia <a href="#1028">RETURN</a> desde el mismo o bien, desde otro proceso, enviarle una se&#241;al s_kill (ver la funci&#243;n <a href="#158">signal()</a>, que es la empleada para esto).<br/><br/>
<strong>&#191;Cuales son las funciones para manejar el rat&#243;n?</strong><br/><br/>
El rat&#243;n no se controla con ninguna funci&#243;n, sino con la estructura global <a href="#1100">mouse</a>, puede acceder a la ayuda sobre <strong>lenguaje</strong> / <strong>datos globales</strong> para ver el resto de estructuras que controlan otros aspectos importantes de los juegos.<br/><br/>
<strong>&#191;De donde carga todos los archivos DIV?</strong><br/><br/>
Cuando en un programa se llama a una funci&#243;n como load_fpg( ... ) el gestor interno de DIV intenta localizar este archivo siguiendo el siguiente esquema (supongamos que se intenta cargar el archivo &quot;DIR\FICHERO.EXT&quot;):<br/><br/>
- Primero se sit&#250;a donde se encuentra el ejecutable (EXE) del juego, o en el directorio principal de DIV (donde est&#225; D.EXE) en caso de estar ejecutando el juego desde el entorno.<br/><br/>
- Despu&#233;s se intenta abrir desde este directorio el archivo seg&#250;n se ha especificado a la funci&#243;n (&quot;DIR\FICHERO.EXT&quot;).<br/><br/>
- En caso de no poder cargar este fichero, se intentar&#225; cargar el fichero dentro de un directorio que tenga como nombre la extensi&#243;n del propio fichero, es decir &quot;EXT\DIR\FICHERO.EXT&quot;.<br/><br/>
- Si tampoco se ha encontrado este, se probar&#225; a cargar el fichero sin indicar ninguna ruta, es decir &quot;FICHERO.EXT&quot;.<br/><br/>
- Y por &#250;ltimo, si no se ha localizado el fichero en ninguno de los anteriores directorios, se intentar&#225; buscar directamente en el directorio cuyo nombre coincide con la extensi&#243;n del fichero, obviando la ruta de acceso que se le pas&#243; a la funci&#243;n, es decir &quot;EXT\FICHERO.EXT&quot;.<br/><br/>
<hr/>
<br/><br/>
<h2 id="1301">Ayuda sobre la calculadora</h2><br/><br/>
<strong>&#191;Como funciona?</strong><br/><br/>
La calculadora incluida en el entorno tiene un funcionamiento ligeramente diferente a las calculadoras convencionales, est&#225; pensada para programadores, y por ello funciona como un evaluador de expresiones.<br/><br/>
Su uso es muy sencillo, basta con escribir la expresi&#243;n matem&#225;tica y pulsar la tecla <strong>Enter</strong>. Pulsando <strong>F1</strong> se acceder&#225; siempre a esta p&#225;gina de ayuda.<br/><br/>
Por ejemplo, puede teclear en la calculadora la expresi&#243;n 2+2 y pulsar <strong>Enter</strong>; aparecer&#225; un 4 en el cuadro de resultados. Para introducir una nueva expresi&#243;n debe borrarse previamente la anterior, lo que puede hacerse pulsando la tecla <strong>ESC</strong>.<br/><br/>
Es posible introducir expresiones complejas, utilizando par&#233;ntesis <strong>( )</strong> para indicar las prioridades en los c&#225;lculos.<br/><br/>
<hr/>
<br/><br/>
Los <strong>operadores</strong> que pueden utilizarse en las expresiones de la calculadora son los siguientes (se indican todos los sin&#243;nimos aceptados de cada operador):<br/><br/>
<strong> + -</strong>      Suma y Resta.<br/>
<strong> * /</strong>      Multiplicaci&#243;n y divisi&#243;n.<br/>
<strong> % MOD</strong>    M&#243;dulo, o resto de una divisi&#243;n entera.<br/>
<strong> &lt; &lt;&lt;</strong>     Rotaci&#243;n binaria a la izquierda.<br/>
<strong> &gt; &gt;&gt;</strong>     Rotaci&#243;n a la derecha.<br/>
<strong> ^ ^^ XOR</strong> OR exclusivo binario.<br/>
<strong> | || OR</strong>  OR binario.<br/>
<strong> &amp; &amp;&amp; AND</strong> AND binario.<br/>
<strong> ! NOT</strong>    Negaci&#243;n binaria.<br/>
<strong> SQRT</strong>     Raiz cuadrada.<br/>
<br/><br/>
<hr/>
<br/><br/>
La calculadora disponen de dos casillas que pueden alterar su <strong>modo de funcionamiento</strong>. Estas opciones son las siguientes:<br/><br/>
<strong>Int</strong> - Si se activa esta casilla, todas las operaciones se realizar&#225;n internamente en variables enteras, como en el lenguaje DIV. Por ejemplo, el resultado de dividir 8/3 ser&#225; 2.<br/><br/>
<strong>Hex</strong> - Cuando esta casilla est&#233; activada, el resultado se mostrar&#225; en el sistema hexadecimal. Tambi&#233;n se pueden introducir n&#250;meros en este sistema dentro de las expresiones precedidos de &#39;<strong>0x</strong>&#39; (como en el lenguaje).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> En el escritorio pueden tenerse abiertas tantas calculadoras como sean necesarias, de forma que se puedan mantener visibles de forma simult&#225;nea varias expresiones diferentes.<br/><br/>
<hr/>
<br/><br/>
<h2 id="1400">Opciones de compilaci&#243;n</h2><br/><br/>
Estas opciones modifican la forma en la que DIV interpreta un programa y el c&#243;digo que genera para &#233;l. Normalmente no ser&#225; necesario especificar ninguna opci&#243;n.<br/><br/>
Para a&#241;adir una o varias de estas opciones a un programa se debe especificar como la primera sentencia del mismo  (comentarios al margen) la palabra <strong>COMPILER_OPTIONS</strong> seguida de los nombres de las opciones incluidas.<br/><br/>
Si se incluyen varias opciones, deben aparecer separadas por comas, a&#241;adiendo siempre un punto y coma al final (tras la ultima opci&#243;n).<br/><br/>
<hr/>
<br/><br/>
<strong>Opciones de compilaci&#243;n disponibles:</strong><br/><br/>
<strong>_max_process=x</strong><br/><br/>
Donde x es un n&#250;mero entero positivo. Define el n&#250;mero de procesos simult&#225;neos m&#225;ximo permitidos en ejecuci&#243;n. Esto puede hacerse una vez completado un programa (cuando se sepa cuantos procesos puede llegar a tener a la vez), para ahorrar memoria en ejecuci&#243;n. En caso de no definirse este valor, se reservar&#225; un m&#237;nimo de 1 Mb (y un m&#225;ximo de 2 Mb) para la memoria del programa.<br/><br/>
<strong>_extended_conditions</strong><br/><br/>
Permite utilizar asignaciones dentro de una condici&#243;n (como: <strong>IF(id2=get_id(...))...)</strong>; esto estaba permitido por defecto en la primera versi&#243;n. Esta opci&#243;n puede ser necesaria para que muchos programas de la primera versi&#243;n funcionen en la segunda.<br/><br/>
<strong>_simple_conditions</strong><br/><br/>
Interpreta el s&#237;mbolo = como una comparaci&#243;n, cuando aparece dentro de una condici&#243;n. Este es un caso opuesto al anterior (e incompatible con &#233;l), al incluir esta opci&#243;n se permitir&#225; hacer comparaciones como <strong>IF(x=0)...</strong>, en lugar de interpretarlo como una asignaci&#243;n del valor 0 a la variable x.<br/><br/>
<strong>_case_sensitive</strong><br/><br/>
Diferencia en todos los nombres entre may&#250;sculas y min&#250;sculas. En caso de activarse esta opci&#243;n <strong>Abc</strong> y <strong>abc</strong> ser&#225;n dos nombres diferentes. Es importante saber que, en este caso, todas las palabras reservadas del lenguaje (<strong>program</strong>, <strong>loop</strong>, <strong>frame</strong>, <strong>if</strong>, ...) deber&#225;n ponerse en letras min&#250;sculas.<br/><br/>
<strong>_ignore_errors</strong><br/><br/>
Prohibe la aparici&#243;n de mensajes de error durante la ejecuci&#243;n del programa. La mayor&#237;a de errores ser&#225;n ignorados (como errores de memoria, si no se encuentra un fichero, divisiones por cero, etc.) , se desaconseja el uso de esta opci&#243;n pero, en caso de querer incluirse, debe hacerse &#250;nicamente en los programas ya finalizados, suficientemente probados, y sin errores conocidos, antes de realizar una instalaci&#243;n (ver las consideraciones finales).<br/><br/>
<strong>_free_sintax</strong><br/><br/>
Permite usar una sintaxis libre. Con esta opci&#243;n no ser&#225;n necesarios los s&#237;mbolos <strong>;</strong> (punto y coma) del final de las sentencias y se podr&#225;n obviar los par&#233;ntesis de las condiciones en las sentencias como <strong>IF</strong>, <strong>WHILE</strong> o <strong>UNTIL</strong>. Por ejemplo, en este modo se dar&#225;n por v&#225;lidas sentencias como: <strong>IF a&lt;0 a=0 END</strong> (ver antes las consideraciones finales).<br/><br/>
<strong>_no_strfix</strong><br/><br/>
No terminar autom&#225;ticamente las cadenas de texto. Cuando se mete un car&#225;cter en un dato de tipo <a href="#1406">STRING</a> se genera c&#243;digo para, cuando este se inserte m&#225;s alla del final de la cadena, a&#241;adir espacios en blanco hasta el mismo y el car&#225;cter <strong>NUL</strong> (ascii 0) al final de la cadena. Esta opci&#243;n deshabilita esta caracter&#237;stica.<br/><br/>
<strong>_no_optimization</strong><br/><br/>
No optimizar el c&#243;digo generado. Por defecto se optimizan los programas, tanto en velocidad como en tama&#241;o. Esta opci&#243;n puede incluirse para deshabilitar estas optimizaciones. Es decir, si se especifica esta opci&#243;n, los programas ir&#225;n m&#225;s lentos y ocupar&#225;n m&#225;s memoria.<br/><br/>
<strong>_no_range_check</strong><br/><br/>
No comprobar accesos fuera de rango en tablas y estructuras. El compilador genera c&#243;digo para comprobar en tiempo de ejecuci&#243;n que las expresiones utilizadas como &#237;ndices de una tabla o estructura est&#225;n dentro de los l&#237;mites permitidos, para emitir un error cuando se acceda fuera de rango. Esta opci&#243;n prohibe que se genere dicho c&#243;digo.<br/><br/>
<strong>_no_id_check</strong><br/><br/>
No comprobar la validez de un c&#243;digo identificador. El compilador tambi&#233;n genera c&#243;digo para comprobar la validez de un identificador cuando se utiliza este para acceder a la variable local de otro proceso (como en <strong>id2.graph</strong>). Si se especifica esta opci&#243;n al comienzo del programa, no se realizar&#225;n estas comprobaciones.<br/><br/>
<strong>_no_null_check</strong><br/><br/>
No comprobar los accesos a punteros nulos (<strong>NULL POINTER</strong>). Deshabilitar las comprobaciones de accesos a memoria con punteros nulos o no definidos. Incluyendo esta opci&#243;n no se generar&#225; c&#243;digo para proteger estos accesos de lectura o escritura a memoria.<br/><br/>
<strong>_no_check</strong><br/><br/>
No realizar ninguna de las comprobaciones de seguridad. Esta opci&#243;n engloba a las tres anteriores, y prohibe al compilador generar c&#243;digo para comprobar cualquier tipo de operaci&#243;n an&#243;mala en tiempo de ejecuci&#243;n. Los programas pueden ganar velocidad, pero no se recomienda utilizar estas opciones a no ser que se trate de programas ya finalizados y sin errores.<br/><br/>
<hr/>
<br/><br/>
Para utilizar estas opciones, por ejemplo, se podr&#237;a comenzar un programa con la siguiente sentencia:<br/><br/>
<strong>COMPILER_OPTIONS _max_process=64,_no_id_check;</strong><br/><br/>
En este caso se indicar&#237;a al compilador que reservara memoria para que, en la ejecuci&#243;n del programa pudieran haber 64 procesos simult&#225;neamente, y no se comprobar&#237;a la validez de los identificadores en los accesos a variables locales de otros procesos (lo que puede ser &#250;til en programas que utilicen mucho estos accesos, siempre que el programador tenga la suficiente experiencia como para estar seguro de lo que hace).<br/><br/>
<hr/>
<br/><br/>
<strong>Importante: Consideraciones sobre algunas opciones.</strong><br/><br/>
<strong>1.</strong> Los usuarios nuevos en DIV o no muy experimentados en la programaci&#243;n pueden simplificar un poco las condiciones con la opci&#243;n <strong>_simple_conditions</strong>, de forma se puedan comparar dos valores con el s&#237;mbolo <strong>=</strong> (adem&#225;s de con el s&#237;mbolo <strong>==</strong>). En cambio, los usuarios que ya hubieran programado con la primera versi&#243;n y con m&#225;s experiencia, probablemente preferir&#225;n activar la opci&#243;n <strong>_extended_conditions</strong> de forma que se puedan crear condiciones complejas, con asignaciones dentro de las mismas.<br/><br/>
<strong>2.</strong> Las opciones <strong>_ignore_error</strong> y todas las variantes de <strong>_no_check</strong> deben utilizarse &#250;nicamente por programadores con mucha experiencia, y solo en la versi&#243;n final del programa. Si no se recomienda su uso, es porque pueden producirse errores graves de ejecuci&#243;n, siendo adem&#225;s muy dif&#237;cil averiguar cual ha sido la causa determinante.<br/><br/>
<strong>3.</strong> Los programas ya est&#225;n optimizados en general (el c&#243;digo generado es un <strong>60%</strong> m&#225;s r&#225;pido que en la primera versi&#243;n), y no se conseguir&#225;n grandes variaciones en la velocidad de ejecuci&#243;n con ninguna de estas opciones. Se pueden utilizar los <strong>perfiles de tiempo</strong> del trazador para ver la repercusi&#243;n de cada una.<br/><br/>
<strong>4.</strong> La opci&#243;n <strong>_ignore_errors</strong> suele ser poco conveniente, siempre ser&#225; mejor utilizar la funci&#243;n <a href="#240">ignore_error()</a> para ignorar, en todo caso, algunos errores determinados de forma selectiva.<br/><br/>
<strong>5.</strong> El uso de una sintaxis libre (con <strong>_free_sintax</strong>) tambi&#233;n tiene sus peligros. Ya que que los saltos de l&#237;nea y espacios en blanco carecen de significado, y pueden producirse interpretaciones indebidas en algunos casos. Por ejemplo, en la sentencia: <strong>IF derecha ++x END</strong>, el compilador interpretar&#225; que el s&#237;mbolo<strong> ++</strong> es el postincremento de <strong>derecha</strong>, en lugar del preincremento de <strong>x</strong> (aunque el s&#237;mbolo este unido a esta &#250;ltima variable). Otro caso similar podr&#237;a pasar al utilizar punteros al estilo C, con estas dos asignaciones consecutivas:  <strong>a=1 *ptr=2</strong>, el compilador las interpretar&#237;a como: <strong>a=(1*ptr)=2</strong> (aunque estuvieran en lineas diferentes). Aunque en general, si no se utilizan preincrementos o punteros al estilo C, no habr&#225;n problemas con la sintaxis libre (y tambi&#233;n se pueden utilizar par&#233;ntensis o puntos y coma en puntos concretos, para solucionar estos peque&#241;os problemas).<br/><br/>
<strong>6.</strong> En cambio la opci&#243;n <strong>_max_process</strong> (que es la &#250;nica que debe aparecer seguida de un s&#237;mbolo <strong>=</strong> y un n&#250;mero) se recomienda sin ning&#250;n tipo de reservas. Si se conoce el n&#250;mero de procesos que pueden llegar a haber a la vez en un programa, se podr&#225; reservar menos memoria para ellos (quedando esta libre para gr&#225;ficos, sonidos, etc.).<br/><br/>
<hr/>
<br/><br/>
<h2 id="1401">Tipos de datos</h2><br/><br/>
Al margen de los datos ya conocidos de la primera versi&#243;n (que ahora se conocen como <a href="#1402">INT</a>), existen datos de los tipos <a href="#1406">STRING</a> (cadenas de texto), <a href="#1403">WORD</a> (enteros positivos de 16 bit), <a href="#1404">BYTE</a> (enteros positivos de 8 bit) y <a href="#1405">POINTER</a> (punteros, de todos estos tipos). Adem&#225;s se pueden definir tablas y estructuras (tambi&#233;n de cualquiera de estos tipos) de 2 o 3 dimensiones (ver la <a href="#1011">declaraci&#243;n de una tabla</a>).<br/><br/>
<a href="#1402">INT</a> - Datos num&#233;ricos enteras entre -2147483648 y +2147483647 (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
<a href="#1403">WORD</a> - Datos num&#233;ricos enteros entre 0 y 65535 (enteros de 16 bit sin signo).<br/><br/>
<a href="#1404">BYTE</a> - Datos num&#233;ricos enteros entre 0 y 255 (enteros de 8 bit sin signo).<br/><br/>
<a href="#1405">POINTER</a> - Punteros a datos de cualquier otro tipo.<br/><br/>
<a href="#1406">STRING</a> - Cadenas de texto (tablas de car&#225;cteres de 8 bit sin signo, entre 0 y 255)<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La palabra reservada <strong>INT</strong> puede omitirse, ya que todos los datos ser&#225;n de este tipo por defecto (enteros de 32 bit con signo).<br/><br/>
<hr/>
Ver: <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1402">Datos de tipo INT</h2><br/><br/>
Datos num&#233;ricos enteras entre -2147483648 y +2147483647 (valores definidos en las constantes <a href="#1177">min_int</a> ... <a href="#1178">max_int</a>).<br/><br/>
Este es el dato de tipo b&#225;sico del lenguaje, cuaundo no se especifique el <strong>tipo de un dato</strong>, este ser&#225; <strong>INT</strong>.<br/><br/>
<hr/>
Ver: <a href="#1401">Tipos de datos</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1403">Datos de tipo WORD</h2><br/><br/>
Datos num&#233;ricos enteros entre 0 y 65535 (enteros de 16 bit sin signo).<br/><br/>
Las tablas de tipo <strong>WORD</strong> pueden significar un importante ahorro de memoria, respecto a las tablas de tipo <a href="#1402">INT</a> (ocupan <strong>2 veces menos</strong> memoria). Pero <strong>ser&#225;n m&#225;s r&#225;pidas las operaciones con datos de tipo</strong> <a href="#1402">INT</a>.<br/><br/>
Ver la <a href="#1407">alineaci&#243;n de datos en memoria</a>, donde se muestra la ocupaci&#243;n de memoria de los diferentes tipos de datos.<br/><br/>
<hr/>
Ver: <a href="#1401">Tipos de datos</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1404">Datos de tipo BYTE</h2><br/><br/>
Datos num&#233;ricos enteros entre 0 y 255 (enteros de 8 bit sin signo).<br/><br/>
Las tablas de tipo <a href="#1404">BYTE</a> pueden significar un importante ahorro de memoria, respecto a las tablas de tipo <a href="#1402">INT</a> (ocupan <strong>4 veces menos memoria</strong>). Pero <strong>ser&#225;n m&#225;s r&#225;pidas las operaciones con datos de tipo</strong> <a href="#1402">INT</a>.<br/><br/>
Ver la <a href="#1407">alineaci&#243;n de datos en memoria</a>, donde se muestra la ocupaci&#243;n de memoria de los diferentes tipos de datos.<br/><br/>
<hr/>
Ver: <a href="#1401">Tipos de datos</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1405">Datos de tipo POINTER</h2><br/><br/>
Punteros a datos de cualquier otro tipo (<a href="#1402">INT</a>), <a href="#1403">WORD</a>, <a href="#1404">BYTE</a> y <a href="#1406">STRING</a>).<br/><br/>
Los punteros en el lenguaje DIV tienen un funcionamiento ligeramente diferente a otros lenguajes de programaci&#243;n, son m&#225;s sencillos de utilizar.<br/><br/>
Estos punteros se utilizan como si fueran tablas m&#243;viles, es decir, tablas a las que se les puede decir donde deben situarse, asign&#225;ndoles un <a href="#1085">OFFSET</a> (de otro dato) a estos punteros. Entonces se podr&#225; acceder a los datos situados en dicha posici&#243;n como <strong>puntero[&#237;ndice]</strong>, tanto para lectura como para escritura de los valores.<br/><br/>
<hr/>
<br/><br/>
<strong>Diferentes datos de tipo puntero:</strong><br/><br/>
<strong>INT POINTER</strong> - Puntero a datos enteros. La palabra INT puede omitirse, declarando un puntero a <strong>INT</strong> simplemente como <strong>POINTER nombre;</strong>.<br/><br/>
<strong>WORD POINTER</strong> - Puntero a una lista o tabla de datos de tipo <strong>WORD</strong>.<br/><br/>
<strong>BYTE POINTER</strong> - Puntero a una lista o tabla de datos de tipo <strong>BYTE</strong>.<br/><br/>
<strong>STRING POINTER</strong> - Puntero a una cadena de texto contenida en un <strong>STRING</strong>.<br/><br/>
<strong>STRUCT POINTER</strong> - Puntero a una estructura, deben declararse como <strong>STRUCT POINTER nombre_estructura &lt;nombre&gt;;</strong>. Donde <strong>&lt;nombre&gt;</strong> ser&#225; el puntero.<br/><br/>
<hr/>
<br/><br/>
Por ejemplo, si en un programa existen varias tablas de tipo <strong>WORD</strong> (declaradas como <strong>WORD t1[9], t2[9], t3[9];</strong>), se puede definir un puntero denominado <strong>ptr</strong> que permita acceder a cualquiera de ellas (como <strong>WORD POINTER ptr</strong>;). Para referirse a una de las tablas se le debe asignar la direcci&#243;n de la misma al puntero (como con <strong>ptr = OFFSET t1;</strong>). A partir de ese momento, se podr&#225; acceder a los valores de la tabla con el puntero (se podr&#225; acceder a <strong>t1[n]</strong> como <strong>ptr[n]</strong>).<br/><br/>
El funcionamiento de los punteros <a href="#1402">INT</a>), <a href="#1403">WORD</a> y <a href="#1404">BYTE</a> es practicamente id&#233;ntico (permiten acceder a una lista de datos consecutivos).<br/><br/>
Los punteros <a href="#1406">STRING</a> permiten acceder &#250;nicamente a una sola cadena de texto (a todos los caracteres de la misma).<br/><br/>
En la declaraci&#243;n de los punteros <a href="#1012">STRUCT</a> debe indicarse el nombre de la estructura a la que van a referir, ya que solo podr&#225;n acceder a un tipo de estructura. No obstante, tras asignarle el <a href="#1085">OFFSET</a> de la estructura (o el de cualquier registro de la misma), permitir&#225;n el acceso a todos los campos y a los sucesivos registros, como si el puntero se tratara de una estructura convencional.<br/><br/>
<strong>Nota:</strong> Para declarar un puntero a una estructura es imprescindible haber declarado antes la misma. Bastar&#225; con una declaraci&#243;n en la que se indiquen los diferentes campos, no es necesario definir el n&#250;mero de registros de la estructura.<br/><br/>
<hr/>
<br/><br/>
<strong>Limitaci&#243;n en el acceso de los punteros.</strong><br/><br/>
No se podr&#225; acceder los datos apuntados hasta que no se haya establecido el <strong>OFFSET del puntero</strong>. No se puede asignar este <strong>OFFSET</strong> en la declaraci&#243;n del puntero, se debe hacer en una sentencia del programa, hasta llegar dicha sentencia el puntero valdr&#225; 0 (<strong>puntero nulo</strong>). El acceso a datos con un puntero nulo provocar&#225; un error de ejecuci&#243;n (ver las <a href="#1400">opciones de compilaci&#243;n</a>).<br/><br/>
Es posible <strong>limitar el rango de acceso de un puntero</strong>, indicando en su declaraci&#243;n el valor m&#225;ximo del &#237;ndice permitido para el mismo. Para ello s&#237;mplemente debe indicarse este entre corchetes, tras el nombre del puntero. Por ejemplo, la siguiente declaraci&#243;n:<br/><br/>
<strong>STRING POINTER s[32];</strong><br/><br/>
Definir&#225; un puntero a una cadena de texto, pero &#250;nicamente dejar&#225; acceder directamente a los 33 (de 0 a 32) primeros car&#225;cteres de la misma. Si se intentara acceder fuera de estos l&#237;mites, el programa advertir&#237;a de ello indicando un acceso fuera de rango.<br/><br/>
<hr/>
Ver: <a href="#1401">Tipos de datos</a> - <a href="#1009">Declaraci&#243;n de un dato</a> - <a href="#1085">OFFSET</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1406">Datos de tipo STRING</h2><br/><br/>
Las tablas <strong>STRING</strong> son una excepci&#243;n, reciben un tratamiento especial como <strong>cadenas de texto</strong>, y &#250;nicamente pueden tener <strong>1 dimensi&#243;n</strong>. Si no se le asigna un literal, la cadena quedar&#225; inicializada a <strong>&quot;&quot;</strong> (<strong>cadena vac&#237;a</strong>).<br/><br/>
Si se define una cadena como <strong>STRING s=&quot;abc&quot;;</strong>, cuando se acceda a ella por su nombre (<strong>s</strong>) se estar&#225; refiriendo a la cadena contenida (<strong>&quot;abc&quot;</strong>). Adem&#225;s se podr&#225; acceder a cualquier caracter de la cadena como si fuese un elemento de una tabla (por ejemplo, la sentencia <strong>s[3]=&quot;d&quot;;</strong> a&#241;adir&#237;a una <strong>&quot;d&quot;</strong> a la cadena).<br/><br/>
<strong>Nota:</strong> No es necesario declarar entre corchetes la longitud de las cadenas de texto (se reservar&#225; espacio para guardar hasta 256 caracteres).<br/><br/>
<hr/>
<br/><br/>
<strong>Operaciones con cadenas de texto.</strong><br/><br/>
Dentro de un programa, suponiendo los datos <strong>s</strong> y <strong>r</strong> de tipo <strong>STRING</strong>, se podr&#237;an realizar operaciones como las siguientes.<br/><br/>
<strong>1.</strong> Se pueden utilizar los datos de tipo <strong>STRING</strong> en todas las funciones que requieren un texto (como <a href="#171">write</a>(0,0,0,0,s), <a href="#132">load_fpg</a>(r), ...).<br/><br/>
<strong>2.</strong> Tambi&#233;n es posible asignar literales a una cadena simplemente poniendo <strong>s=&quot;cualquier texto...&quot;;</strong> o asignar una cadena a otra, como con <strong>s=r;</strong>.<br/><br/>
<strong>3.</strong> Pueden sumarse cadenas con sentencias como <strong>s+=&quot;texto a a&#241;adir&quot;;</strong> o <strong>s=r+&quot;ho&quot;+&quot;la&quot;;</strong>.<br/><br/>
<strong>4.</strong> Adem&#225;s puede a&#241;adirse un car&#225;cter a una cadena con sentencias como <strong>s+=ascii;</strong> o <strong>r+=&quot;a&quot;;</strong>.<br/><br/>
<strong>5.</strong> Se puede quitar un car&#225;cter de la cadena (del final) con <strong>s--;</strong>, <strong>s-=1;</strong> o <strong>r=s-1;</strong>.<br/><br/>
<strong>6.</strong> Pueden compararse cadenas con condiciones como <strong>(s==&quot;hola&quot;)</strong>, <strong>(s&gt;=r)</strong>, <strong>(s&lt;&quot;0&quot;+r)</strong>, etc.<br/><br/>
<strong>7.</strong> Y, al margen de todas estas operaciones, existe un gran n&#250;mero de funciones de manejo de texto (ver la <a href="#1032">lista de funciones del lenguaje</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Literales de varias l&#237;neas.</strong><br/><br/>
Es posible definir literales en varias l&#237;neas, para ello s&#237;mplemente deber&#225; dividirse el texto en varios, y ponerse estos seguidos (sin separarse por ning&#250;n s&#237;mbolo). Por ejemplo, se podr&#237;a definir una constante como:<br/><br/>
<strong>saludo=&quot;&#161;Ho&quot;</strong><br/>
<strong>       &quot;la!&quot;;</strong><br/><br/>
Esto podr&#237;a utilizarse tambi&#233;n para inicializar los datos de tipo <strong>STRING</strong>. No hay l&#237;mite en el n&#250;mero de l&#237;neas. Entre dos literales seguidos &#250;nicamente podr&#237;an aparecer <a href="#1002">comentarios</a>.<br/><br/>
<hr/>
Ver: <a href="#1401">Tipos de datos</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1407">Alineaci&#243;n de datos en memoria</h2><br/><br/>
Es importante resaltar que todos los datos ser&#225;n, en este lenguaje, alineados a <strong>4 bytes</strong> (tama&#241;o de los datos de tipo <strong>INT</strong>. Esto quiere decir que el <strong>OFFSET</strong> de todos los datos se situar&#225; siempre en una direcci&#243;n de memoria absoluta <strong>m&#250;ltiplo de cuatro</strong>.<br/><br/>
Esto tiene implicaciones directas en los datos de los tipos <strong>WORD</strong> y <strong>BYTE</strong>. Ya que estos ocupan respectivamente <strong>2 bytes</strong> y <strong>1 byte</strong>. Por ello, si se define una variable de tipo <strong>WORD</strong> se desaprovechar&#225;n 2 bytes de memoria, y se define una variable de tipo <strong>BYTE</strong> se desaprovechar&#225;n 3 bytes (ya que el siguiente dato estar&#225; tambi&#233;n alineado a 4).<br/><br/>
Por ello, para aprovechar mejor la memoria del ordenador, es recomendable utilizar estos dos tipos de datos como tablas (ver la <a href="#1011">declaraci&#243;n de una tabla</a>), ya que los diferentes elementos de una tabla siempre se guardan consecutivos, y no se alinean en memoria.<br/><br/>
<hr/>
<br/><br/>
<strong>Ejemplos de ocupaci&#243;n de memoria:</strong><br/><br/>
<strong>BYTE b1;</strong> - Memoria requerida 1, Memoria ocupada 4.<br/><br/>
<strong>WORD w1;</strong> - Memoria requerida 2, Memoria ocupada 4.<br/><br/>
<strong>INT i1;</strong> - Memoria requerida 4, Memoria ocupada 4.<br/><br/>
<strong>BYTE b2[7];</strong> - Memoria requerida 8, Memoria ocupada 8.<br/><br/>
<strong>WORD w2[2];</strong> - Memoria requerida 6, Memoria ocupada 8.<br/><br/>
<strong>BYTE b3[2];</strong> - Memoria requerida 3, Memoria ocupada 4.<br/><br/>
<strong>WORD w3[3]</strong> - Memoria requerida 8, Memoria ocupada 8.<br/><br/>
<hr/>
<br/><br/>
Como se puede observar, la memoria ocupada (en bytes) por un dato siempre ser&#225; un valor m&#250;ltiplo de 4.<br/><br/>
Esto se debe tener en cuenta tambi&#233;n en los campos de las <a href="#1012">estructuras de datos</a> ya que, por ejemplo; dos variables de tipo <strong>WORD</strong> consecutivas ocupar&#225;n <strong>8 bytes</strong>, mientras que una tabla <strong>WORD</strong> con dos elementos ocupar&#225; s&#243;lo <strong>4 bytes</strong>.<br/><br/>
<hr/>
Ver: <a href="#1401">Tipos de datos</a> - <a href="#1009">Declaraci&#243;n de un dato</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1408">Los bloques FUNCTION</h2><br/><br/>
Los nuevos bloques <strong>FUNCTION</strong> se comportan de forma an&#225;loga a las funciones de otros lenguajes de programaci&#243;n, se ejecutan de forma secuencial (y no en paralelo como los bloques <a href="#1016">PROCESS</a>), no retornando hasta que no han terminado.<br/><br/>
<strong>FUNCTION</strong> <a href="#1001">&lt;nombre&gt;</a> <strong>(</strong> <a href="#1018">&lt;par&#225;metros&gt;</a> <strong>)</strong><br/>
<a href="#1008">&lt;Declaraci&#243;n de datos privados&gt;</a><br/>
<a href="#1086">BEGIN</a><br/>
<a href="#1017">&lt;sentencia&gt;</a> <strong>;</strong><br/>
...<br/>
<a href="#1091">END</a><br/><br/>
Estos bloques seguir&#225;n funcionando de forma muy similar a los procesos normales, pero con una importante diferencia: detendr&#225;n al proceso llamador hasta finalizar, es decir, que estas funciones dormir&#225;n al proceso que las ha llamado, hasta que estas funciones retornen o su proceso finalice.<br/><br/>
Si la funci&#243;n no utiliza sentencias <a href="#1029">FRAME</a>, se comportar&#225; igual que un proceso normal, pero si una funci&#243;n ejecuta la sentencia <a href="#1029">FRAME</a>, no volver&#225; al bloque que la llam&#243; (como lo har&#237;a un proceso normal).<br/><br/>
Por lo tanto, una funci&#243;n siempre puede devolver un valor con <a href="#1028">RETURN</a><strong>(</strong>&lt;expresi&#243;n&gt;<strong>)</strong>, incluso despu&#233;s de haber dado uno o varios <a href="#1029">FRAME</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Programaci&#243;n secuencial.</strong><br/><br/>
No se recomienda programar s&#243;lo con funciones y de forma secuencial, pero el conocer c&#243;mo se puede hacer facilitar&#225; el entendimiento de la programaci&#243;n DIV a programadores de otros lenguajes.<br/><br/>
Es posible hacer un programa al estilo de la programaci&#243;n tradicional utilizando exclusivamente los bloques <strong>FUNCTION</strong>, de esta forma &#250;nicamente habr&#225; un proceso en ejecuci&#243;n en cada momento.<br/><br/>
Al programar de esta forma, la sentencia <a href="#1029">FRAME</a> se convierte en la orden expl&#237;cita de <strong>volcado a v&#237;deo</strong>. Logicamente, si s&#243;lo hay un proceso ejecut&#225;ndose, cuando este ejecute esta orden el sistema mostrar&#225; la siguiente imagen del programa.<br/><br/>
Pero, programando asi, &#191;se podr&#237;an mostrar varios gr&#225;ficos en pantalla?.<br/><br/>
La respuesta es s&#237;, ya que se podr&#237;an crear una especie de mini-procesos que funcionaran como una instrucci&#243;n del estilo &quot;pinta un gr&#225;fico para la siguiente imagen&quot; (a diferencia de las funciones como <a href="#146">put()</a>, que pintan un gr&#225;fico para siempre).<br/><br/>
Para mostrar un gr&#225;fico en la siguiente imagen se debe construir un proceso que reciba los par&#225;metros visuales necesarios y simplemente ejecute una &#250;nica sentencia <a href="#1029">FRAME</a>, por ejemplo:<br/><br/>
<strong>PROCESS pinta_gr&#225;fico(x,y,graph)</strong><br/>
<strong>BEGIN</strong><br/>
<strong>    FRAME;</strong><br/>
<strong>END</strong><br/>
<br/><br/>
Al llamar a este proceso <strong>se crear&#237;a un proceso temporal que se pintar&#237;a en la siguiente imagen</strong> y entonces desaparecer&#237;a. Podr&#237;an contemplarse otros par&#225;metros (adem&#225;s de <a href="#1123">x</a>, <a href="#1124">y</a>, <a href="#1125">z</a>), como <a href="#1131">file</a>, <a href="#1128">size</a>, <a href="#1129">angle</a>, <a href="#1125">z</a>, ... (ver los <a href="#1201">datos locales predefinidos</a>).<br/><br/>
Claro que, al programar de esta forma, se deber&#237;a crear (normalmente en una <a href="#1012">estructura</a> global) una tabla de sprites de forma que el programa pudiera gestionar todos los gr&#225;ficos. Esto, que puede parecer complicado, es la forma natural de programar los juegos en cualquier otro lenguaje que no sea DIV.<br/><br/>
<hr/>
<br/><br/>
<strong>Aplicaciones en el programa principal.</strong><br/><br/>
Las sentencias que aparecen entre las palabras <a href="#1086">BEGIN</a> y <a href="#1091">END</a> del programa principal (tras las declaraciones de datos), controlan el <a href="#1015">proceso principal del programa</a>. Este es el encargado de inicializar el programa, realizar las presentaciones, controlar los bucles de men&#250;, los bucles de juego (creando los procesos necesarios), y finalizar el programa.<br/><br/>
En el programa principal, puede ser muy &#250;til llamar a bloques <strong>FUNCTION</strong>. Ya que de esta forma ser&#225; detenido el programa principal mientras se ejecuta la parte que controla dicha funci&#243;n.<br/><br/>
Por ejemplo, la secuencia de presentaci&#243;n podr&#237;a hacerse en una funci&#243;n, el men&#250; de opciones en otra, etc. Adem&#225;s, se recuerda que las funciones pueden al finalizar, devolver siempre un valor con <a href="#1028">RETURN</a><strong>(</strong>&lt;expresi&#243;n&gt;<strong>)</strong>, lo cual puede ser tambi&#233;n &#250;til para que, por ejemplo el men&#250;, devuelva el n&#250;mero de opci&#243;n que ha sido seleccionada.<br/><br/>
<strong>Nota:</strong> Que finalice la ejecuci&#243;n del c&#243;digo principal no implica que finalice la ejecuci&#243;n del programa, pues &#233;sta continuar&#225; si quedan procesos vivos; si se quiere forzar la terminaci&#243;n del programa cuando finalice este c&#243;digo, se puede utilizar, por ejemplo, la funci&#243;n <a href="#129">let_me_alone()</a> justo antes del <a href="#1091">END</a> del <a href="#1015">c&#243;digo principal</a>, o bien la funci&#243;n <a href="#109">exit()</a> (en cualquier punto del programa).<br/><br/>
<hr/>
Ver: <a href="#1016">Los bloques PROCESS</a> - <a href="#1000">Sintaxis</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1409">GLOBAL argv[], GLOBAL argc</h2><br/><br/>
<strong>argv[];</strong> // Argumentos del programa<br/>
<strong>argc;</strong>   // N&#250;mero de argumentos<hr/>
<br/><br/>
Pueden accederse a los par&#225;metros pasados a un programa (normalmente al ejecutarlo desde modo MSDOS), al estilo del lenguaje C, en los datos globales predefinidos <strong>argc</strong> y <strong>argv[]</strong>.<br/><br/>
La variable <strong>argc</strong> contendr&#225;, al ejecutarse el programa, el n&#250;mero de par&#225;metros. Siendo <strong>1</strong> el n&#250;mero m&#237;nimo, ya que se cuenta siempre como un par&#225;metro el nombre del propio ejecutable del juego.<br/><br/>
La tabla <strong>argv[]</strong> es una tabla de <strong>cadenas de texto</strong>, y tendr&#225; definidas tantas posiciones como indique la variable <strong>argc</strong>, y en <strong>argv[0]</strong> estar&#225; siempre el nombre del programa.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Cuando se ejecuta un programa desde el entorno ventanas de DIV, este no recibir&#225; m&#225;s par&#225;metros que el propio nombre del ejecutable. Por lo que estas variables ser&#225;n &#250;tiles &#250;nicamente en las versiones ya instaladas de los programas.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1410">GLOBAL STRUCT net</h2><br/><br/>
<strong>STRUCT net;</strong><br/>
<strong>device;</strong>      // Dispositivo de conexi&#243;n<br/>
<strong>com;</strong>         // Puerto de comunicaciones<br/>
<strong>speed;</strong>       // Velocidad de conexi&#243;n<br/>
<strong>number;</strong>      // N&#250;mero de tel&#233;fono<br/>
<strong>init;</strong>        // Cadena de inicio del m&#243;dem<br/>
<strong>mode;</strong>        // Modo (pulsos o tonos)<br/>
<strong>server;</strong>      // Indica si es servidor<br/>
<strong>max_players;</strong> // Numero m&#225;ximo de jugadores<br/>
<strong>num_players;</strong> // Numero actual de jugadores<br/>
<strong>END</strong><br/><br/>
Esta estructura de datos es de nivel muy avanzado y se requiere bastante experiencia en programaci&#243;n para poder crear un juego orientado a una conexi&#243;n de red (se puede encontrar m&#225;s informaci&#243;n en el <strong>manual de usuario</strong>).<br/><br/>
Contiene los datos sobre el hardware de red, se debe utilizar en conjunto con las funciones <a href="#180">net_join_game()</a> y <a href="#181">net_get_games()</a>.<br/><br/>
La estructura <strong>net</strong> tiene un &#250;nico registro. En los diferentes campos del mismo se se establecen los par&#225;metros que definen el tipo de conexi&#243;n.<br/><br/>
<hr/>
<br/><br/>
<strong>device</strong> - Dispositivo a trav&#233;s del cual se va a establecer la conexi&#243;n, este puede contener uno de estos tres valores:<br/><br/>
<strong>1</strong> - Conexi&#243;n en una <strong>red local</strong>, con protocolo IPX.<br/><br/>
<strong>2</strong> - Conexi&#243;n a trav&#233;s de un cable serie (s&#243;lo dos equipos).<br/><br/>
<strong>3</strong> - Conexi&#243;n por m&#243;dem (s&#243;lo dos equipos).<br/><br/>
En funci&#243;n del dispositivo se deber&#225;n inicializar unos u otros campos de la estructura <strong>net</strong>, ya que muchos de estos par&#225;metros son espec&#237;ficos para un dispositivo concreto.<br/><br/>
<hr/>
<br/><br/>
<strong>com</strong> - Puerto de comunicaciones a emplear para la conexi&#243;n, es decir, el n&#250;mero de dispositivo COM (de COM1 a COM4), indic&#225;ndolo como un valor num&#233;rico entre <strong>1</strong> y <strong>4</strong>.<br/><br/>
Este campo &#250;nicamente se debe definir para conexiones por cable serie o a trav&#233;s de un m&#243;dem.<br/><br/>
<hr/>
<br/><br/>
<strong>speed</strong> - Velocidad en baudios (n&#250;mero de bits por segundo), hasta 115000. Esta velocidad debe ajustarse a las posibilidades del cable o m&#243;dem empleado, y del volumen de datos que requiera la comunicaci&#243;n del programa.<br/><br/>
Este campo &#250;nicamente se debe definir para conexiones por cable serie o a trav&#233;s de un m&#243;dem.<br/><br/>
<hr/>
<br/><br/>
<strong>number</strong> - N&#250;mero de tel&#233;fono, por supuesto este campo es necesario &#250;nicamente en conexiones a trav&#233;s de m&#243;dem.<br/><br/>
Por ejemplo, se debe asignar el n&#250;mero de tel&#233;fono a marcar con una sentencia como la siguiente: <strong>net.number=&quot;912345678&quot;;</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>init</strong> - Cadena de inicio, tambi&#233;n es un campo exclusivo para las conexiones por m&#243;dem; por ejemplo una sentencia como: <strong>net.init=&quot;ATZ&quot;;</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>mode</strong> - Modo en el que se debe establecer la conexi&#243;n por m&#243;dem (tambi&#233;n s&#243;lo para este dispositivo), los valores pueden ser los siguientes:<br/><br/>
<strong>0</strong> - Pulsos.<br/><br/>
<strong>1</strong> - Tonos.<br/><br/>
<hr/>
<br/><br/>
<strong>server</strong> - Indica si un equipo es el servidor. Se trata de un dato informativo (es un campo de s&#243;lo lectura, no se debe modificar).<br/><br/>
En una conexi&#243;n, &#250;nicamente un equipo tendr&#225; el campo <strong>net.server</strong> a <strong>1</strong>, este equipo ser&#225; el servidor de la partida, y es el que debe centralizar las acciones m&#225;s importantes del programa.<br/><br/>
<hr/>
<br/><br/>
<strong>max_players</strong> - N&#250;mero m&#225;ximo de jugadores que se permiten en una partida, de <strong>2</strong> a <strong>16</strong>. Este es un campo &#250;til &#250;nicamente en conexiones por red local, ya que en conexiones de cable serie o m&#243;dem el n&#250;mero m&#225;ximo de jugadores siempre ser&#225; <strong>2</strong>.<br/><br/>
Este n&#250;mero debe coincidir con el n&#250;mero m&#225;ximo de registros que tenga la estructura global utilizada como paquetes de comunicaci&#243;n entre los diversos equipos.<br/><br/>
<hr/>
<br/><br/>
<strong>num_players</strong> - N&#250;mero actual de jugadores conectados a la partida, de <strong>1</strong> a <strong>net.max_players</strong>. Este es un valor din&#225;mico, que va variando segun se vayan produciendo las conexiones (se pueden ir conectando y desconectando jugadores en cualquier momento).<br/><br/>
La programaci&#243;n del juego es la que debe determinar si los jugadores pueden entrar y salir din&#225;micamente de la partida, o bien si deben estar todos conectados antes de que esta de comienzo.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#180">net_join_game()</a> - <a href="#181">net_get_games()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1411">GLOBAL STRUCT m8</h2><br/><br/>
<strong>STRUCT m8[9];</strong><br/>
<strong>z;</strong>      // Prioridad de impresi&#243;n<br/>
<strong>camera;</strong> // Identificador de la c&#225;mara<br/>
<strong>height;</strong> // Altura de la c&#225;mara<br/>
<strong>angle;</strong>  // Angulo vertical<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura de <strong>10</strong> registros contiene ciertos campos relacionados con par&#225;metros modificables de las <strong>ventanas de modo 8</strong>. Los diez registros tienen los mismos nombres de campos, pero cada uno de ellos modifica los par&#225;metros de una ventana de modo 8 diferente (ya que pueden activarse hasta 10 ventanas de este tipo).<br/><br/>
Una <strong>ventana de modo 8</strong> se podr&#237;a definir como una regi&#243;n de pantalla que muestra un mapa de sectores tridimensional.<br/><br/>
Para que un registro (del <strong>0</strong> al <strong>9</strong>) de la <strong>estructura m8</strong> tenga sentido, primero debe activarse dicha <strong>ventana de modo 8</strong> (del <strong>0</strong> al <strong>9</strong>) con la funci&#243;n <a href="#190">start_mode8()</a> (ver esta funci&#243;n para m&#225;s informaci&#243;n sobre las ventanas de modo 8}.<br/><br/>
Se entiende que los campos de esta estructura son complementarios a los par&#225;metros de llamada de esta &#250;ltima funci&#243;n. Para poder observar un ejemplo pr&#225;ctico de un modo 8, se puede acceder a la ayuda sobre la funci&#243;n <a href="#189">load_wld()</a> o de <a href="#190">start_mode8()</a>.<br/><br/>
<hr/>
<br/><br/>
<strong>Forma de uso de la estructura m8:</strong><br/><br/>
Para acceder a estos campos se debe preceder el nombre del campo por la palabra <strong>m8</strong>, el n&#250;mero de registro entre corchetes y el s&#237;mbolo <a href="#1063">. (punto)</a>.<br/><br/>
Por ejemplo, si se inicializaran dos ventanas de modo 8, la n&#250;mero 0 y la n&#250;mero 1, se podr&#237;a acceder a la variable <strong>camera</strong> de ambas ventanas como <strong>m8[0].camera</strong> y <strong>m8[1].camera</strong>, respectivamente. Cuando se acceda a la ventana n&#250;mero 0 de modo 8 se puede, adem&#225;s, omitir el n&#250;mero de ventanas entre corchetes, es decir, que la variable <strong>m8.camera</strong> y la variable <strong>m8[0].camera</strong> son, a todos los efectos, la misma para el lenguaje.<br/><br/>
<hr/>
<br/><br/>
<strong>Se muestra a continuaci&#243;n una descripci&#243;n detallada de cada campo</strong><br/><br/>
<strong>z</strong> - Prioridad de impresi&#243;n del modo 8, aqu&#237; se indica en qu&#233; plano de profundidad se debe pintar esta ventana, respecto al resto de procesos. Por defecto, esta variable valdr&#225; <strong>256</strong> lo cual quiere decir que, como los procesos por defecto tienen su variable <a href="#1125">local z</a> a <strong>0</strong>, la ventana de modo 8 se pintar&#225; en un plano de profundidad mayor, m&#225;s al fondo, visualiz&#225;ndose los gr&#225;ficos de los procesos por encima de la ventana. Para variar esta situaci&#243;n se puede modificar la variable <strong>z</strong> de la ventana (por ejemplo ponerla a<strong> -1</strong>) o la variable <strong>z</strong> de los procesos (por ejemplo ponerla a <strong>257</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>camera</strong> - <a href="#1039">C&#243;digo identificador del proceso</a> en el que se sit&#250;a la c&#225;mara. Para mover la c&#225;mara que controla la visi&#243;n del modo 8, &#250;nicamente se debe crear un proceso de modo 8, un proceso que tenga su variable local <a href="#1122">ctype</a> <strong>=</strong> <a href="#1412">c_m8</a>, y poner su <a href="#1039">c&#243;digo identificador</a> en la variable <strong>camera</strong> de esta estructura. Tras esto, s&#237;mplemente se deben modificar las variables locales <a href="#1123">x</a>, <a href="#1124">y</a>, <a href="#1125">z</a> y <a href="#1129">angle</a> de este proceso y, por ejemplo, utilizar la funci&#243;n <a href="#101">advance()</a> para mover hacia delante la c&#225;mara.<br/><br/>
<hr/>
<br/><br/>
<strong>height</strong> - Altura de la c&#225;mara respecto al proceso, por defecto este campo est&#225; inicializado a <strong>32</strong>. El proceso de modo 8 se situar&#225; verticalmente en su coordenada <strong>z</strong>, su variable local <strong>height</strong> determina la altura del propio proceso, y este campo (<strong>m8.height</strong>) determina la altura de la c&#225;mara (de los <strong>ojos</strong> del proceso respecto a su base).<br/><br/>
<hr/>
<br/><br/>
<strong>angle</strong> - Angulo vertical de la c&#225;mara, este &#225;ngulo es un valor entre<strong> -128</strong> y <strong>128</strong>. Define si la c&#225;mara mira hacia arriba o hacia abajo. Cuando <strong>m8.angle</strong> valga <strong>0</strong>, que es el valor por defecto, la c&#225;mara mirar&#225; hacia el centro.<br/><br/>
El &#225;ngulo horizontal ser&#225; la variable local <strong>angle</strong> del propio proceso que est&#225; siendo utilizado como c&#225;mara de la ventana (cuyo identificador est&#225; en <strong>m8.camera</strong>).<br/><br/>
<hr/>
<br/><br/>
V&#233;ase tambi&#233;n las <strong>variables locales</strong> relacionadas con el <strong>modo 8</strong>.<br/><br/>
<a href="#1421">LOCAL radius</a><br/>
<a href="#1422">LOCAL m8_wall</a><br/>
<a href="#1423">LOCAL m8_sector</a><br/>
<a href="#1424">LOCAL m8_nextsector</a><br/>
<a href="#1425">LOCAL m8_step</a><br/>
<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1412">c_m8</h2><br/><br/>
Constante: <strong>c_m8</strong> <hr/>
<br/><br/>
Esta constante se utiliza para asignarla a la variable local predefinida <a href="#1122">ctype</a> que sirve para definir el tipo de coordenadas que tendr&#225; un proceso. Su valor es <strong>3</strong>.<br/><br/>
&#201;ste es el valor asignado a <a href="#1122">ctype</a> para que las coordenadas del gr&#225;fico del proceso se interpreten como referidas a una ventana de modo 8, a coordenadas sobre el mapa de sectores tridimensional que se muestra en la misma.<br/><br/>
Para m&#225;s informaci&#243;n sobre las <strong>ventanas de modo 8</strong>, se puede acceder a la funci&#243;n <a href="#190">start_mode8()</a>, utilizada para activarlas.<br/><br/>
Existen otras constantes utilizadas para otros sistemas de coordenadas, la lista completa es la siguiente:<br/><br/>
<a href="#1167">c_screen</a> - Coordenadas de pantalla<br/>
<a href="#1168">c_scroll</a> - Coordenadas de scroll<br/>
<a href="#1169">c_m7</a>     - Coordenadas de modo 7<br/>
<strong>c_m8</strong>     - Coordenadas de modo 8<br/>
<br/><br/>
<hr/>
Ver: <a href="#1202">Constantes</a> - <a href="#1122">ctype</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1413">GLOBAL STRUCT dirinfo</h2><br/><br/>
<strong>STRUCT dirinfo;</strong><br/>
<strong>files;</strong>      // Numero de archivos en lista<br/>
<strong>name[1024];</strong> // Nombres de los archivos<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura global predefinida se utiliza como retorno de la funci&#243;n <a href="#231">get_dirinfo()</a>, para contener la lista de archivos de un directorio (o carpeta).<br/><br/>
Se trata de una estructura de un &#250;nico registro, que agrupa una variable <strong>files</strong> y una tabla de punteros a <strong>cadenas de texto</strong> (<strong>name[]</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Se muestra a continuaci&#243;n una descripci&#243;n detallada de cada campo</strong><br/><br/>
<strong>name[]</strong> - La funci&#243;n <a href="#231">get_dirinfo()</a> simplemente retorna el <strong>n&#250;mero total</strong> de archivos listados; los nombres de estos archivos se guardan en esta estructura global, en la tabla <strong>name[]</strong> de la misma (el primer nombre de archivo se guarda en <strong>dirinfo.name[0]</strong>, el segundo en <strong>dirinfo.name[1]</strong>, etc.).<br/><br/>
<hr/>
<br/><br/>
<strong>files</strong> - El <strong>n&#250;mero total</strong> de archivos listados que retorna esta funci&#243;n se guarda adem&#225;s este campo (es decir, en <strong>dirinfo.files</strong>).<br/><br/>
<hr/>
<br/><br/>
La lista de nombres de archivos se guarda siempre en orden alfab&#233;tico, no obstante se puede utilizar la funci&#243;n <a href="#213">qsort()</a> para ordenar la estructura por otro criterio.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#231">get_dirinfo()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1414">GLOBAL STRUCT fileinfo</h2><br/><br/>
<strong>STRUCT fileinfo;</strong><br/>
<strong>string fullpath[254];</strong> // Nombre completo<br/>
<strong>drive;</strong>                // Unidad de disco<br/>
<strong>string dir[254];</strong>      // Directorio<br/>
<strong>string name[7];</strong>       // Nombre<br/>
<strong>string ext[3];</strong>        // Extensi&#243;n<br/>
<strong>size;</strong>                 // Tama&#241;o (en bytes)<br/>
<strong>day;</strong>                  // D&#237;a<br/>
<strong>month;</strong>                // Mes<br/>
<strong>year;</strong>                 // A&#241;o<br/>
<strong>hour;</strong>                 // Hora<br/>
<strong>min;</strong>                  // Minuto<br/>
<strong>sec;</strong>                  // Segundo<br/>
<strong>attrib;</strong>               // Atributos<br/>
<strong>END</strong><br/>
<br/><br/>
Esta estructura global predefinida se utiliza como retorno de la funci&#243;n <a href="#232">get_fileinfo()</a>, para contener los atributos de un archivo (o subdirectorio).<br/><br/>
Se trata de una estructura de un &#250;nico registro, que agrupa varias cadenas de texto (datos de tipo <a href="#1406">STRING</a>) y variables num&#233;ricas (datos de tipo <a href="#1402">INT</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Se muestra a continuaci&#243;n una descripci&#243;n detallada de cada campo</strong><br/><br/>
<strong>fullpath</strong> - Nombre completo (incluyendo la ruta). La ruta de acceso al archivo se puede especificar completa (a partir del directorio raiz de la unidad, como &quot;C:\WINDOWS\...&quot;) o relativa al directorio actual (a partir de donde se ejecute el juego, como &quot;MAP\MIOS\...&quot;). En cualquier caso, en <strong>fileinfo.fullpath</strong> siempre se devolver&#225; la ruta completa a partir del directorio raiz, incluyendo la letra de la unidad.<br/><br/>
<hr/>
<br/><br/>
<strong>drive</strong> - Unidad de disco en la que se encuentra el archivo sobre el que se ha solicitado informaci&#243;n. La unidad no se devuelve como la letra correspondiente, sino como un n&#250;mero, estableci&#233;ndose la siguiente correspondencia: <strong>1</strong> para <strong>A:</strong>, <strong>2</strong> para <strong>B</strong>:, <strong>3</strong> para <strong>C:</strong>, etc.<br/><br/>
<hr/>
<br/><br/>
<strong>dir</strong> - Directorio donde se encuentra el archivo. En esta cadena no se devuelve &#250;nicamente el nombre de la carpeta que contiene al archivo, sino que se especifica la ruta completa, a partir del directorio raiz pasando por todos los directorios (por ejemplo &quot;\DIV\MAP\&quot;). Siempre se devolver&#225; con una barra invertida (\) al inicio y otra al final.<br/><br/>
<hr/>
<br/><br/>
<strong>name</strong> - Nombre del archivo, este campo (<strong>fileinfo.name</strong>), retorna el nombre del archivo, sin extensi&#243;n, de un m&#225;ximo de <strong>8 car&#225;cteres</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>ext</strong> - Extensi&#243;n del archivo. Como &#250;ltima parte del nombre se retorna en este campo la extensi&#243;n del archivo, en una cadena que incluye el punto que separa el nombre de la misma.<br/><br/>
<hr/>
<br/><br/>
<strong>size</strong> - Tama&#241;o del archivo, este valor ser&#225; <strong>0</strong> si se solicita informaci&#243;n sobre un directorio. El tama&#241;o se retorna como el n&#250;mero de datos simples, es decir, como el n&#250;mero de datos de tipo <a href="#1402">INT</a> que caben en el archivo (n&#250;mero de bytes entre cuatro). Es posible variar esta relaci&#243;n modificando la variable global <a href="#1420">unit_size</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>day</strong> - D&#237;a del mes de la &#250;ltima actualizaci&#243;n del archivo.<br/><br/>
<strong>month</strong> - Mes de la &#250;ltima actualizaci&#243;n del archivo.<br/><br/>
<strong>year</strong> - A&#241;o de la &#250;ltima actualizaci&#243;n del archivo.<br/><br/>
<strong>hour</strong> - Hora de la &#250;ltima actualizaci&#243;n (de <strong>0</strong> a <strong>23</strong>).<br/><br/>
<strong>min</strong> - Minuto dentro de la hora.<br/><br/>
<strong>sec</strong> - Segundo dentro del minuto.<br/><br/>
<hr/>
<br/><br/>
<strong>attrib</strong> - Atributos del archivo, estos indican las caracter&#237;sticas del archivo, tales como si es un archivo de sistema, s&#243;lo de lectura, oculto, etc. Este valor es la suma de las siguientes constantes:<br/><br/>
<strong>0</strong> - Archivo normal.<br/>
<strong>1</strong> - Archivo de s&#243;lo lectura.<br/>
<strong>2</strong> - Archivo oculto.<br/>
<strong>4</strong> - Archivo de sistema.<br/>
<strong>8</strong> - Etiqueta de volumen.<br/>
<strong>16</strong> - Subdirectorio.<br/>
<strong>32</strong> - Marcha de archivo.<br/>
<br/><br/>
Por ejemplo, para un archivo de sistema y oculto, el valor de <strong>fileinfo.attrib</strong> ser&#237;a <strong>6</strong> (2 Oculto + 4 Sistema).<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#232">get_fileinfo()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1415">GLOBAL STRUCT video_modes</h2><br/><br/>
<strong>STRUCT video_modes[31];</strong><br/>
<strong>wide;</strong>   // Ancho del modo<br/>
<strong>height;</strong> // Alto del modo<br/>
<strong>mode;</strong>   // N&#250;mero del modo<br/>
<strong>END</strong><br/>
<br/><br/>
En la estructura global predefinida <strong>video_modes</strong> se encuentra, al inicio de todos los programas, la <strong>lista de modos vesa</strong> soportados por el adaptador de v&#237;deo del ordenador (todos ellos de <strong>256 colores</strong>), hasta <strong>un m&#225;ximo de 32</strong> (del [0] al [31]).<br/><br/>
El n&#250;mero de modos encontrados se guarda en la variable global <a href="#1419">num_video_modes</a>.<br/><br/>
Esta informaci&#243;n la genera el sistema de forma autom&#225;tica, sin que se requiera llamar a ninguna funci&#243;n. Para todos los modos encontrados se registra la siguiente informaci&#243;n:<br/><br/>
<strong>wide</strong> - N&#250;mero de pixels en horizontal del modo de v&#237;deo.<br/><br/>
<strong>height</strong> - N&#250;mero de pixels en vertical del modo de v&#237;deo.<br/><br/>
<strong>mode</strong> - N&#250;mero de modo. Este valor se puede usar directamente como par&#225;metro para la funci&#243;n <a href="#157">set_mode()</a>.<br/><br/>
Una vez seleccionado el <strong>ancho</strong> y <strong>alto</strong> del modo de v&#237;deo que se desea activar, y por tanto se tiene el <strong>n&#250;mero de registro</strong> de la estructura del mismo, se se debe activar este llamando a la funci&#243;n como:<br/><br/>
<strong>set_mode(video_modes[</strong>&lt;n&#250;mero de registro&gt;<strong>].mode);</strong><br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Adem&#225;s de los modos registrados en esta estructura, existe una lista de modos de v&#237;deo est&#225;ndar, cuyos n&#250;meros se encuentran en las constantes <a href="#1150">m320x200 ... m1024x768</a>.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1419">num_video_modes</a> - <a href="#157">set_mode()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1416">GLOBAL channel[]</h2><br/><br/>
<strong>channel[31];</strong> // Utilizaci&#243;n de los canales de sonido<hr/>
<br/><br/>
La tabla globlal <strong>channel</strong> mantiene informaci&#243;n sobre la utilizaci&#243;n de los diferentes canales de sonido (hasta 32) del sistema de audio.<br/><br/>
Cada vez que se toca un sonido con la funci&#243;n <a href="#159">sound()</a>, se env&#237;a el mismo a uno de estos canales. Y cuando se inicia la reproducci&#243;n de un m&#243;dulo musical con la funci&#243;n <a href="#216">song()</a>, se reservan un determinado n&#250;mero de canales para el mismo (hasta 24).<br/><br/>
En esta tabla, cada posici&#243;n representa a uno de estos canales de sonido, y el sistema pondr&#225; a <strong>1</strong> cada posici&#243;n cuando se utilice su respectivo canal.<br/><br/>
La funci&#243;n <a href="#256">change_channel()</a> permite modificar los par&#225;metros de cada uno de estos canales.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> El sistema nunca pondr&#225; a <strong>0</strong> las posiciones de la tabla <strong>channel</strong>, debe ser el programa el que borre la tabla, para de esta forma poder determinar cuando se utiliza nuevamente un canal.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#256">change_channel()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1417">GLOBAL vsync</h2><br/><br/>
<strong>vsync=0;</strong> // Esperar al retrazo vertical<hr/>
<br/><br/>
La variable global predefinida <strong>vsync</strong> define un valor l&#243;gico (0 o 1) que indica si debe esperarse al <strong>retrazo vertical</strong> antes de volcar la siguiente imagen a v&#237;deo (cuando todos los procesos ejecuten la sentencia <a href="#1029">FRAME</a>).<br/><br/>
Por defecto esta variable estar&#225; siempre a <strong>0</strong>, es decir, que no se espera al retrazo vertical antes de volcar cada imagen a v&#237;deo.<br/><br/>
Para indicar al sistema que debe esperar al retrazo vertical se debe poner esta variable a <strong>1</strong> (con la sentencia <strong>vsync=1;</strong>).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Esperar el retrazo vertical puede proporcionar una suavidad de movimientos mucho mayor en los programas (el efecto es sobre todo m&#225;s notable en los efectos de panor&#225;mica, ver <a href="#163">start_scroll()</a>), pero esperar al retrazo tambi&#233;n enlentecer&#225; los programas en la gran mayor&#237;a de ocasiones.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1418">GLOBAL draw_z</h2><br/><br/>
<strong>draw_z=-255;</strong> // Plano de profundidad de las primitivas gr&#225;ficas<hr/>
<br/><br/>
Las <strong>primitivas gr&#225;ficas</strong> son las l&#237;neas rectas, rect&#225;ngulos, c&#237;rculos, etc., que se imprimen con la funci&#243;n <a href="#249">draw()</a>.<br/><br/>
En esta variable global se indica el plano de profundidad en el que deben aparecer las primitivas gr&#225;ficas en pantalla, esto es, qu&#233; debe aparecer por encima y qu&#233; por debajo.<br/><br/>
Los planos de profundidad pueden ser cualquier n&#250;mero entero dentro del rango (<a href="#1177">min_int</a> ... <a href="#1178">max_int</a>) y, cuanto mayor sea el n&#250;mero, m&#225;s al fondo se situar&#225; la imagen.<br/><br/>
Los gr&#225;ficos de los procesos tienen su variable <a href="#1125">local z</a> a <strong>0</strong> por defecto, los textos <a href="#1106">text_z</a> a<strong> -256</strong> y el puntero del rat&#243;n tiene <a href="#1100">mouse.z</a> a<strong> -512</strong> por defecto.<br/><br/>
Esto quiere decir que, por defecto, si no se no modifican estos valores, aparecer&#225;n las primitivas gr&#225;ficas sobre los procesos, pero por debajo de los textos y del puntero del rat&#243;n.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota 1:</strong> La variable <strong>draw_z</strong> es <a href="#1006">GLOBAL</a> para todas las primitivas gr&#225;ficas, es decir, que no se pueden representar estas en diferentes planos.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#249">draw()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1419">GLOBAL num_video_modes</h2><br/><br/>
<strong>num_video_modes;</strong> // N&#250;mero de modos de v&#237;deo detectados<hr/>
<br/><br/>
La variable global <strong>num_video_modes</strong> contiene el n&#250;mero de modos de v&#237;deo VESA que se han detectado en el adaptador gr&#225;fico del sistema.<br/><br/>
Los par&#225;metros de cada uno de estos modos se registran en la estructura global <a href="#1415">video_modes</a>, por lo tanto la variable <strong>num_video_modes</strong> define el n&#250;mero de registros definidos en dicha estructura.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Adem&#225;s de los modos registrados en dicha estructura, existe una lista de <strong>10 modos de v&#237;deo est&#225;ndar</strong>, cuyos n&#250;meros se encuentran en las constantes <a href="#1150">m320x200 ... m1024x768</a>.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1415">STRUCT video_modes</a> - <a href="#157">set_mode()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1420">GLOBAL unit_size</h2><br/><br/>
<strong>unit_size=4;</strong> // Unidad m&#237;nima de lectura/escritura<hr/>
<br/><br/>
La variable global predefinida <strong>unit_size</strong> indica cual es el tama&#241;o de la unidad m&#237;nima de lectura y escritura de las funciones de archivos basadas en <strong>handles</strong>.<br/><br/>
Por defecto valdr&#225; siempre <strong>4</strong>, ya que 4 bytes es el tama&#241;o de los datos est&#225;ndar <a href="#1402">INT</a> (enteros de 32 bit), y todos los datos se alinean en memoria cada 4 bytes (ver la <a href="#1407">alineaci&#243;n de datos en memoria</a>).<br/><br/>
Las funciones que tienen en cuenta el tama&#241;o de unidad indicado en <strong>unit_size</strong> son las siguientes:<br/><br/>
<a href="#225">fread()</a><br/>
<a href="#226">fwrite()</a><br/>
<a href="#227">fseek()</a><br/>
<a href="#228">ftell()</a><br/>
<a href="#229">filelength()</a><br/>
<br/><br/>
Y adem&#225;s el campo <strong>size</strong> de la estructura global <a href="#1414">fileinfo</a>.<br/><br/>
<hr/>
<br/><br/>
Que el tama&#241;o m&#237;nimo sea 4 implica que no se pueden leer ni escribir archivos cuya longitud no sea m&#250;ltiplo de dicho n&#250;mero.<br/><br/>
Se puede cambiar este tama&#241;o; por ejemplo asignando <strong>1</strong> a <strong>unit_size</strong> (con la sentencia <strong>unit_size=1;</strong>). De este modo, todas las <strong>longitudes</strong> de las funciones anteriores se indicar&#225;n ahora en bytes (y no en datos).<br/><br/>
No obstante, al cambiar el tama&#241;o de la unidad, se debe tener en cuenta lo siguiente:<br/><br/>
- <a href="#1094">SIZEOF()</a> continuar&#225; devolviendo la longitud en datos (de 4 bytes). Por ejemplo, para grabar una tabla en disco no bastar&#225; con indicar <strong>sizeof(</strong>&lt;tabla&gt;<strong>)</strong> como longitud, sino que se deber&#225; multiplicar la misma por 4 (en caso de haber definido <strong>unit_size</strong> como <strong>1</strong>).<br/><br/>
- Las funciones de archivos <a href="#155">save()</a> y <a href="#130">load()</a> (que no son funciones basadas en <strong>handles</strong>) continuar&#225;n indicando la longitud en datos.<br/><br/>
- Las funciones de memoria din&#225;mica <a href="#257">malloc()</a> y <a href="#258">free()</a> tambi&#233;n continuar&#225;n trabajando con longitudes en datos, por lo que se deber&#225;n hacer los ajustes oportunos en caso de trabajar con ambos conjutos de funciones.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#1407">Alineaci&#243;n de datos en memoria</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1421">LOCAL radius</h2><br/><br/>
<strong>radius;</strong> // Radio (ancho) de los procesos de modo 8<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>radius</strong>.<br/><br/>
Esta variable local se utiliza exclusivamente en los procesos de un modo 8 (aquellos que tienen asignado <a href="#1412">c_m8</a> a <a href="#1122">ctype</a>).<br/><br/>
En <strong>radius</strong> se indica el radio, o tama&#241;o en horizontal, del proceso. El sistema requiere este valor para calcular las colisiones con los l&#237;mites de los sectores del mapa tridimensional.<br/><br/>
Cuanto menor sea el valor de <strong>radius</strong> para un proceso, m&#225;s se podr&#225; acercar este a las paredes del mismo y, por lo tanto, mayores se ver&#225;n los puntos (o texel) de las texturas de las mismas.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para m&#225;s informaci&#243;n sobre el modo 8, v&#233;ase la estructura global <a href="#1411">m8</a> y la funci&#243;n <a href="#190">start_mode8()</a>, que es la empleada para inicializar regiones de este tipo.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1422">LOCAL m8_wall</h2><br/><br/>
<strong>m8_wall;</strong> // N&#250;mero de pared del mapa de sectores<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>m8_wall</strong>.<br/><br/>
Esta variable local se utiliza exclusivamente en los procesos de un modo 8 (aquellos que tienen asignado <a href="#1412">c_m8</a> a <a href="#1122">ctype</a>).<br/><br/>
En <strong>m8_wall</strong> el sistema guardar&#225;, de forma autom&#225;tica, el n&#250;mero de pared contra la que ha colisionado el proceso.<br/><br/>
Esta informaci&#243;n puede ser &#250;til para detectar distintas zonas activas dentro de un mapa de sectores (como puertas, interruptores, etc.).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para m&#225;s informaci&#243;n sobre el modo 8, v&#233;ase la estructura global <a href="#1411">m8</a> y la funci&#243;n <a href="#190">start_mode8()</a>, que es la empleada para inicializar regiones de este tipo.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1423">LOCAL m8_sector</h2><br/><br/>
<strong>m8_sector;</strong> // N&#250;mero de sector en el que se encuentra el proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>m8_sector</strong>.<br/><br/>
Esta variable local se utiliza exclusivamente en los procesos de un modo 8 (aquellos que tienen asignado <a href="#1412">c_m8</a> a <a href="#1122">ctype</a>).<br/><br/>
En <strong>m8_sector</strong> el sistema guardar&#225;, de forma autom&#225;tica, el n&#250;mero de sector sobre el que se encuentra el proceso, dentro del mapa.<br/><br/>
La informaci&#243;n del n&#250;mero sector puede ser &#250;til para programar eventos en funci&#243;n del sector en el que entre un proceso.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para m&#225;s informaci&#243;n sobre el modo 8, v&#233;ase la estructura global <a href="#1411">m8</a> y la funci&#243;n <a href="#190">start_mode8()</a>, que es la empleada para inicializar regiones de este tipo.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1424">LOCAL m8_nextsector</h2><br/><br/>
<strong>m8_nextsector;</strong> // Sector hacia el que se dirige el proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>m8_nextsector</strong>.<br/><br/>
Esta variable local se utiliza exclusivamente en los procesos de un modo 8 (aquellos que tienen asignado <a href="#1412">c_m8</a> a <a href="#1122">ctype</a>).<br/><br/>
En <strong>m8_nextsector</strong> el sistema guardar&#225;, de forma autom&#225;tica, cual es el sector hacia el que se dirige un proceso. Es decir, cuando el proceso colisione con una pared de mapa, el sistema comprobar&#225; si tras la misma existe alg&#250;n otro sector y, en ese caso, indicar&#225; en esta variable su n&#250;mero.<br/><br/>
Esta informaci&#243;n puede ser &#250;til, por ejemplo, para obtener las alturas a las que se encuentra dicho sector (ver <a href="#193">get_sector_height()</a>) y, de esta forma, averiguar si el proceso debe subir o bajar, y cuanto, para acceder a dicho sector.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para m&#225;s informaci&#243;n sobre el modo 8, v&#233;ase la estructura global <a href="#1411">m8</a> y la funci&#243;n <a href="#190">start_mode8()</a>, que es la empleada para inicializar regiones de este tipo.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1425">LOCAL m8_step</h2><br/><br/>
<strong>m8_step;</strong> // Altura que puede subir el proceso<hr/>
<br/><br/>
Esta variable predefinida es <a href="#1007">LOCAL</a>, lo que significa que cada proceso tendr&#225; su propio valor en su variable <strong>m8_step</strong>.<br/><br/>
Esta variable local se utiliza exclusivamente en los procesos de un modo 8 (aquellos que tienen asignado <a href="#1412">c_m8</a> a <a href="#1122">ctype</a>).<br/><br/>
En <strong>m8_step</strong> se indica cual es la altura m&#225;xima que el proceso puede subir para alcanzar un sector contiguo, algo as&#237; como &quot;la altura de escal&#243;n&quot; que puede subir este proceso.<br/><br/>
Cuando un proceso avance hacia otro sector m&#225;s elevado, el sistema comprobar&#225; mediante esta variable si el proceso puede acceder directamente al mismo, en caso afirmativo se ajustar&#225; la nueva altura del proceso de forma autom&#225;tica y, en caso contrario, el proceso se detendr&#225; (pues colisionar&#225; con la pared que separa ambos sectores).<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Para m&#225;s informaci&#243;n sobre el modo 8, v&#233;ase la estructura global <a href="#1411">m8</a> y la funci&#243;n <a href="#190">start_mode8()</a>, que es la empleada para inicializar regiones de este tipo.<br/><br/>
<hr/>
Ver: <a href="#1201">Datos locales</a> - <a href="#190">start_mode8()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="1426">GLOBAL fps</h2><br/><br/>
<strong>fps;</strong> // N&#250;mero de im&#225;genes por segundo<hr/>
<br/><br/>
La variable global predefinida <strong>fps</strong> (frames per second) mantiene el n&#250;mero de im&#225;genes por segundo que est&#225; mostrando un programa.<br/><br/>
Esta variable es actualizada por el gestor de procesos de DIV Games Studio autom&#225;ticamente. No se mantiene el valor instant&#225;neo, sino una media de los &#250;ltimos segundos, por ello se necesita cierto tiempo de ejecuci&#243;n para que el valor de <strong>fps</strong> se estabilice.<br/><br/>
La funci&#243;n <a href="#156">set_fps()</a> permite establecer el n&#250;mero de im&#225;genes por segundo del programa, pero de esta forma se establece el n&#250;mero de im&#225;genes ideal, y no el real (que es el que contabiliza <strong>fps</strong>).<br/><br/>
Es decir, que esta variable sirve de cuenta para saber cuantas im&#225;genes se est&#225;n volcando a v&#237;deo por cada segundo, como media.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La variable <strong>fps</strong> mantiene un dato de s&#243;lo lectura, no se conseguir&#225; ning&#250;n efecto modificando su contenido desde un programa.<br/><br/>
<hr/>
Ver: <a href="#1200">Datos globales</a> - <a href="#156">set_fps()</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2000">&#161;Bienvenido a DIV 2!</h2><br/><br/>
Este texto muestra los conceptos b&#225;sicos para introducirle en el manejo de este entorno de desarrollo.<br/><br/>
Utilizando esta ayuda electr&#243;nica se podr&#225; acceder a mucha informaci&#243;n sobre este entorno, aun as&#237;, el aprendizaje del lenguaje de programaci&#243;n y las opciones del programa se describen &#250;nicamente en el <strong>Manual de usuario</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> Si esta es la primera vez que Vd. utiliza este entorno de programaci&#243;n de videojuegos, debe saber que, para salir de todos los programas ejecutados desde DIV, podr&#225; siempre utilizar la combinaci&#243;n de teclas <strong>ALT</strong>+<strong>X</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Novedades respecto a la versi&#243;n anterior</strong><br/><br/>
- <a href="#2001">Novedades en el lenguaje</a><br/>
- <a href="#2002">Novedades en el entorno</a><br/>
<br/><br/>
<strong>Relaci&#243;n de los temas de introducci&#243;n</strong><br/><br/>
- <a href="#1">C&#243;mo usar el sistema de ayuda</a><br/>
- <a href="#1300">Respuestas a preguntas comunes (FAQ)</a><br/>
- <a href="#2003">Resoluci&#243;n de problemas de configuraci&#243;n</a><br/>
<br/><br/>
- <a href="#2004">&#191;Que es DIV Games Studio?</a><br/>
- <a href="#2005">Trabajando con las ventanas</a><br/>
- <a href="#2006">Tipos de ventanas</a><br/>
- <a href="#2010">Fijando un modo de video</a><br/>
- <a href="#2011">La ventana de configuraci&#243;n</a><br/>
- <a href="#2012">Toma de contacto con el lenguaje</a><br/>
- <a href="#2013">Trazando los programas</a><br/>
<br/><br/>
<hr/>
<br/><br/>
DIV Games Studio apareci&#243; en el mercado en Diciembre de 1998 como el primer entorno de desarrollo con un lenguaje de programaci&#243;n dise&#241;ado exclusivamente para la programaci&#243;n de juegos.<br/><br/>
En un principio, nuestra pretensi&#243;n como desarrolladores no fu&#233; la creaci&#243;n de un entorno profesional, sino m&#225;s bien de crear un entorno simple y ameno que pudiera servir como introducci&#243;n al apasionante mundo del desarrollo de juegos; algo as&#237; como un &quot;juego para hacer juegos&quot; en el que cualquier persona pudiera aprender a programar.<br/><br/>
La muy buena aceptaci&#243;n del mismo ha conducido a la aparici&#243;n de esta segunda versi&#243;n del entorno, en la que se mantiene la misma filosof&#237;a.<br/><br/>
Las muchas opiniones, cr&#237;ticas y sugerencias recibidas han permitido crear un DIV un poco mejor en todos sus aspectos. Se ha intentado mejorar, aunque s&#243;lo fuera un poco, todas las facetas del entorno. De esta forma no hay grandes diferencias con la versi&#243;n anterior, pero si muchas (y muy pr&#225;cticas).<br/><br/>
Tenemos que dar las gracias a todas las personas que han apoyado nuestra idea y a este producto, de cualquier forma. A fecha de presentaci&#243;n de esta segunda versi&#243;n seguimos sin conocer de la existencia de una alternativa a este entorno lo cual, a pesar de que a nosotros se supone que deber&#237;a alegrarnos, nos parece tan increible como triste.<br/><br/>
Somos conscientes de que quedan muchos pasos por dar, y Vd. vuelve a tener ahora la oportunidad de sugerirnos hacia donde.<br/><br/>
<strong>El equipo de DIV Games Studio.</strong><br/><br/>
<hr/>
Ver: <a href="#2014">Acerca de...</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2001">Novedades del lenguaje en la versi&#243;n 2.0</h2><br/><br/>
<strong>M&#225;s lenguaje.</strong> Se ha ampliado el lenguaje de programaci&#243;n, incluyendo m&#250;ltiples caracter&#237;sticas nuevas y funciones internas, a continuaci&#243;n se detallan las principales novedades del <strong>lenguaje DIV</strong> en su <strong>versi&#243;n 2.0</strong>.<br/><br/>
<hr/>
<br/><br/>
Las <strong>opciones de compilaci&#243;n</strong> son una nueva caracter&#237;stica de esta versi&#243;n, de esta forma se permite adaptar el proceso de compilaci&#243;n a las necesidades de cada proyecto (ver <a href="#1400">Compiler_options</a>).<br/><br/>
Al margen de los datos ya conocidos de la primera versi&#243;n (que ahora se conocen como <a href="#1402">INT</a>), existen datos de los tipos <a href="#1406">STRING</a> (cadenas de texto), <a href="#1403">WORD</a> (enteros positivos de 16 bit), <a href="#1404">BYTE</a> (enteros positivos de 8 bit) y <a href="#1405">POINTER</a> (punteros, de todos estos tipos).<br/><br/>
Adem&#225;s se pueden definir <strong>tablas</strong> y <strong>estructuras</strong> (tambi&#233;n de cualquiera de estos tipos) de <strong>2</strong> o <strong>3 dimensiones</strong> (ver la <a href="#1011">declaraci&#243;n de una tabla</a>), y las estructuras se pueden inicializar globalmente (ver la <a href="#1012">declaraci&#243;n de una estructura</a>).<br/><br/>
Los nuevos <a href="#1408">bloques FUNCTION</a> se comportan de forma an&#225;loga a las funciones de otros lenguajes de programaci&#243;n, se ejecutan de forma secuencial (y no en paralelo como los procesos), no retornando hasta que no han terminado.<br/><br/>
Se ha mejorado varios aspectos del <strong>trazador de programas</strong>, con nuevas funciones y soporte para los nuevos tipos de datos. Destacan entre estas novedades los <strong>perfiles de tiempo</strong>, que pueden accederse con <strong>F11</strong> desde el trazador, donde se puede observar el tiempo consumido por la ejecuci&#243;n y pintado de cada proceso.<br/><br/>
Se ha mejorado el <strong>sistema de control de errores</strong> de los programas, con lo que se crean ejecutables m&#225;s s&#243;lidos y estables, existiendo ahora adem&#225;s la posibilidad de anular ciertos errores de ejecuci&#243;n (ver la funci&#243;n <a href="#240">ignore_error()</a>.<br/><br/>
Se han a&#241;adido una gran cantidad de <strong>nuevas funciones de gesti&#243;n de archivos</strong>, mucho m&#225;s flexibles y potentes; v&#233;ase por ejemplo <a href="#223">fopen()</a>, <a href="#227">fseek()</a>, <a href="#231">get_dirinfo()</a>, <a href="#235">chdir()</a>, <a href="#237">remove()</a>) o <a href="#238">disk_free()</a>.<br/><br/>
Al margen del soporte de m&#250;sica CD-Audio y los efectos digitales, existen ahora varias funciones para la reproducci&#243;n de m&#243;dulos musicales <strong>MOD</strong>, <strong>S3M</strong> y <strong>XM</strong> (ver <a href="#214">load_song()</a>, <a href="#216">song()</a> o <a href="#218">set_song_pos()</a>).<br/><br/>
<strong>Generador de c&#243;digo optimizado.</strong> El c&#243;digo generado para los programas es mejor y m&#225;s r&#225;pido (un m&#237;nimo de un 60%) respecto a la versi&#243;n anterior. Adem&#225;s los programas <strong>EXE</strong> creados son mucho m&#225;s peque&#241;os.<br/><br/>
<strong>Funciones para juegos en red.</strong> Ahora es posible crear con DIV Games Studio juegos para jugar por <strong>cable serie</strong>, <strong>m&#243;dem</strong> y <strong>red local IPX</strong>. Con un sistema muy simple controlado por las funciones <a href="#180">net_join_game()</a> y <a href="#181">net_get_games()</a>.<br/><br/>
Otra de las novedades es la integraci&#243;n en el lenguaje de un potente manejo de cadenas de texto, con los datos de tipo <a href="#1406">STRING</a>, m&#250;ltiples funciones (como por ejemplo <a href="#203">strcat()</a>, <a href="#206">strchr()</a>, <a href="#209">upper()</a> o <a href="#211">strdel()</a>) y una sintaxis adaptada para trabajar con expresiones de cadenas directamente en el lenguaje.<br/><br/>
<strong>Soporte para memoria din&#225;mica</strong>. Es posible pedir y liberar memoria din&#225;micamente en los programas, gracias a las funciones <a href="#257">malloc()</a> y <a href="#258">free()</a> (lo que se ve complementado con los nuevos datos de tipo <a href="#1405">POINTER</a>). Adem&#225;s la funci&#243;n <a href="#239">memory_free()</a> permite determinar la memoria libre disponible en el sistema.<br/><br/>
Tambi&#233;n se ha a&#241;adido la posibilidad de <strong>ordenaci&#243;n</strong> y <strong>desordenaci&#243;n</strong>, con una simple pero potente funci&#243;n denominada <a href="#213">qsort()</a> que permite ordenar y desordenar estructuras de datos, tomando cualquier campo como &#237;ndice de la misma.<br/><br/>
Otra de las novedades muy solicitada es la <strong>b&#250;squeda de caminos</strong>. Se trata de varias funciones (ver <a href="#185">path_find()</a>) que permiten localizar rutas libres (llamadas por algunos &quot;rutinas de inteligencia artificial&quot;).<br/><br/>
<strong>Compresi&#243;n de datos.</strong> Todo es m&#225;s compacto; los ejecutables y los datos instalados (se pueden crear <strong>instalaciones compactadas y protegidas</strong>). Adem&#225;s se incluyen funciones de compresi&#243;n en el lenguaje (ver <a href="#262">compress_file()</a>).<br/><br/>
<strong>Nuevo modo 8.</strong> Un nuevo modo con hasta 10 regiones de pantalla, que permite visualizar mapas de sectores tridimensionales. Con un editor integrado en el entorno y m&#250;ltiples funciones (ver por ejemplo <a href="#190">start_mode8()</a>, <a href="#192">set_sector_height()</a>, o <a href="#196">set_fog()</a>).<br/><br/>
<hr/>
<br/><br/>
<strong>Y un largo etc&#233;tera.</strong> Las novedades del lenguaje no acaban aqu&#237;, existen muchas otras mejoras y funciones (adem&#225;s de los errores de la primera versi&#243;n que se han corregido). A continuaci&#243;n se detallan brevemente otras novedades del lenguaje DIV.<br/><br/>
- Una nueva funci&#243;n, denominada <a href="#266">force_pal()</a>, permite que todos <strong>los gr&#225;ficos cargados en un programa se adapten autom&#225;ticamente a una paleta</strong> en tiempo de ejecuci&#243;n.<br/><br/>
- Existen funciones de encriptaci&#243;n de datos, tanto en memoria como de archivos, estas son <a href="#259">encode()</a>, <a href="#260">encode_file()</a> y <a href="#261">decode_file()</a>.<br/><br/>
- La <strong>declaraci&#243;n de librer&#237;as</strong> se realiza ahora en la cabecera del programa, tras la sentencia <strong>PROGRAM</strong> (ver <a href="#1014">IMPORT</a>).<br/><br/>
- Ahora es posible crear programas en <strong>muchos m&#225;s modos de v&#237;deo</strong>, ya que se pueden detectar los modos vesa disponibles (ver <a href="#1415">video_modes</a>).<br/><br/>
- En esta nueva versi&#243;n se prohiben inicialmente las <strong>asignaciones dentro de una condici&#243;n</strong>, para facilitar la programaci&#243;n a usuarios no experimentados. No obstante esto puede cambiarse (ver <a href="#1400">_extended_conditions y _simple_conditions</a>).<br/><br/>
- Ahora es posible definir el <strong>n&#250;mero m&#225;ximo de procesos</strong> que pueden haber en el programa en tiempo de ejecuci&#243;n (ver <a href="#1400">_max_process</a>).<br/><br/>
- Es posible definir <strong>literales en varias l&#237;neas</strong>, para ello s&#237;mplemente deber&#225; dividirse el texto en varios, y ponerse estos seguidos (ver los <a href="#1047">s&#237;mbolos delimitadores de literales</a>).<br/><br/>
- El <strong>sistema de sonido</strong> es totalmente nuevo, y ahora se permite la reproducci&#243;n de <strong>archivos WAV de mucha m&#225;s calidad</strong> en los programas (ver <a href="#134">load_wav()</a> y los nuevos campos de la estructura <a href="#1104">setup</a>). Tambi&#233;n se han a&#241;adido funciones de sonido como <a href="#256">change_channel()</a> o <a href="#221">is_playing_sound()</a>.<br/><br/>
- Tambi&#233;n se permite ahora utilizar directamente <strong>im&#225;genes en formato PCX</strong> en los programas (ver <a href="#174">load_pcx()</a>), as&#237; como grabar estos archivos (ver <a href="#241">save_map/pcx()</a>).<br/><br/>
- Existen funciones para fijar <strong>un color de la paleta</strong> (<a href="#179">set_color()</a>) y tambi&#233;n para localizar colores (<a href="#264">find_color()</a>).<br/><br/>
- Varias <strong>funciones matem&#225;ticas</strong> como <a href="#242">sin()</a>, <a href="#243">cos()</a>, <a href="#244">tan()</a>, <a href="#245">asin()</a>, ...<br/><br/>
- Tambi&#233;n se han incluido <strong>primitivas para dibujar</strong> distintas gr&#225;ficas en pantalla: l&#237;neas, rect&#225;ngulos y cajas, c&#237;rculos, ... (ver <a href="#249">draw()</a>).<br/><br/>
- Se han a&#241;adido <strong>otras funciones</strong> diversas que amplian las posibilidades existentes en la creaci&#243;n de programas, como <a href="#212">screen_copy()</a>, <a href="#253">write_in_map()</a>, <a href="#254">calculate()</a>, <a href="#265">load_screen()</a>, <a href="#183">xadvance()</a>, <a href="#188">new_map()</a>, ...<br/><br/>
- Tambi&#233;n se puede contar l&#225;s <strong>im&#225;genes por segundo</strong> (ver <a href="#1426">fps</a>), obtener los <strong>par&#225;metros del programa</strong> (ver <a href="#1409">argv[]</a>), esperar el <strong>retrazo vertical</strong> (ver <a href="#1417">vsync</a>), controlar mejor el rat&#243;n en los programas (ver <a href="#1100">mouse.cursor</a> y <a href="#1100">mouse.speed</a>), etc.<br/><br/>
<hr/>
<br/><br/>
Y adem&#225;s, todas las funciones, datos y posibilidades que ya brindaba la primera versi&#243;n de DIV Games Studio, &#161;que siguen aqu&#237;! <strong>:)</strong><br/><br/>
<hr/>
<strong>Ver tambi&#233;n:</strong> <a href="#2002">Novedades del entorno gr&#225;fico</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2002">Novedades del entorno en la versi&#243;n 2.0</h2><br/><br/>
<strong>M&#225;s flexibilidad y sencillez de uso.</strong> El entorno de desarrollo de DIV Games Studio ha evolucionado en m&#250;ltiples peque&#241;os aspectos, y entre todos conforman un interfaz a&#250;n m&#225;s intuitivo que el de la versi&#243;n anterior.<br/><br/>
<hr/>
<br/><br/>
<strong>Una nueva ayuda.</strong> La ayuda se ha actualizado, se ha estructurado mejor, y por supuesto contempla todas las novedades del lenguaje DIV. El formato de la ventana incluye una nueva barra de navegaci&#243;n.<br/><br/>
<strong>Multiples tama&#241;os de pincel.</strong> En el editor gr&#225;fico se pueden seleccionar ahora pinceles de m&#250;ltiples tama&#241;os y formas, monocromos o en escala de grises. Con la tecla <strong>T</strong> se accede al nuevo di&#225;logo; se pueden a&#241;adir nuevos pinceles, a&#241;adi&#233;ndolos al fichero <strong>BRUSH.FPG</strong> del directorio <strong>SYSTEM</strong>.<br/><br/>
<strong>Dibujo con capas o texturas.</strong> En el editor gr&#225;fico se accede con la tecla <strong>U</strong> a un nuevo di&#225;logo en el que se puede seleccionar cualquiera de los mapas del escritorio como textura para pintar (con la tecla <strong>X</strong> se puede ver y desplazar esta textura). Se ha mejorado la herramienta del <strong>aerosol</strong>, la barra de <strong>puntos de control</strong>, y adem&#225;s se han a&#241;adido <strong>nuevos comandos de teclado</strong> (como <strong>K</strong> para copiar un gr&#225;fico a ventana, o<strong> +/-</strong> para cambiar de punto de control).<br/><br/>
<strong>Visualizadores gr&#225;ficos.</strong> Casi todas las ventanas para abrir archivos disponen de una casilla denominada <strong>Im&#225;genes</strong> que permite visualizar el contenido de estos archivos antes de que sean cargados. Adem&#225;s es posible <strong>cargar varios archivos de una s&#243;la</strong> vez marcando estos con el rat&#243;n mientras se mantiene la tecla <strong>Control</strong> pulsada (la tecla <strong>May&#250;sculas</strong> permite marcar varios consecutivos).<br/><br/>
<strong>Sistema mejorado de ficheros.</strong> En esta versi&#243;n se ha mejorado la gesti&#243;n interna de los FPG; se han eliminado errores, se pueden visualizar reducciones de los mapas contenidos, imprimir las listas, transferir un FPG completo a un mapa y viceversa.<br/><br/>
<strong>Editor de efectos de sonido.</strong> El sistema de audio es completamente nuevo, permiti&#233;ndose muchas m&#225;s operaciones, formatos e incluy&#233;ndose un <strong>mezclador</strong> y un <strong>editor de efectos</strong> de sonido. Se puede acceder a este editor a partir del men&#250; de sonidos.<br/><br/>
<strong>Evaluaci&#243;n de expresiones.</strong> Ahora se puede acceder a las nuevas ventanas <strong>calculadoras</strong> (desde el men&#250; de sistema) para evaluar expresiones num&#233;ricas mientras se est&#225; programando, sin salir del entorno.<br/><br/>
<strong>Generador de sprites.</strong> El generador de personajes es tambi&#233;n una nueva caracter&#237;stica de esta versi&#243;n. Se ha dise&#241;ado para ofrecer una base sobre la que realizar dibujos de seres humanos y animaciones realistas. Pudiendo ser posteriormente utilizados estos fotogramas en el editor gr&#225;fico para realizar sobre los mismos cualquier tipo de modificaci&#243;n.<br/><br/>
<strong>Editor de mapas tridimensionales.</strong> El men&#250; de mapas 3D, as&#237; como el editor de estos y todas las funciones relacionadas con los mismos del lenguaje de programaci&#243;n son una nueva caracter&#237;stica de esta versi&#243;n de DIV Games Studio.<br/><br/>
<strong>Perfiles de tiempo.</strong> Desde el trazador de programas se puede acceder, pulsando F11, a los perfiles de tiempo del programa. Estas estad&#237;sticas indican que est&#225; consumiendo tiempo de proceso durante la ejecuci&#243;n de un programa, y permiten la optimizaci&#243;n de la velocidad de los programas manualmente.<br/><br/>
<strong>Nuevos ejemplos.</strong> Se incluyen m&#250;ltiples juegos y programas desarrollados por los usuarios con la versi&#243;n anterior de DIV Games Studio. Adem&#225;s, en el CD-ROM se podr&#225;n encontrar m&#250;ltiples utilidades shareware o de libre uso que complementan a este entorno de desarrollo.<br/><br/>
<strong>Facilidad de impresi&#243;n.</strong> Esta versi&#243;n de DIV Games Studio permite imprimir, adem&#225;s de los listados de los programas, las listas de gr&#225;ficos contenidas en un FPG y las p&#225;ginas de ayuda electr&#243;nica.<br/><br/>
<strong>Controles de volumen.</strong> Dentro de las mejoras incluidas en el sistema de audio, ahora existe un mejor control de los niveles de volumen, tanto en el entorno como en los progrmas. En el reproductor de CD aparece un peque&#241;o bot&#243;n que da acceso al mezclador.<br/><br/>
<strong>Librer&#237;a de gr&#225;ficos.</strong> Se ha ampliado y estructurado mejor la librer&#237;a de gr&#225;ficos incluida con el programa. Adem&#225;s ahora se pueden importar mapas de cualquier n&#250;mero de colores en formatos BMP, PCX o JPG.<br/><br/>
<strong>Nuevo sistema de instalaci&#243;n.</strong> El sistema de instalaci&#243;n de los programas ha sido completamente redise&#241;ado, gener&#225;ndose instalaciones protegidas contra modificaciones y m&#225;s compactas, utilizando un <strong>interface gr&#225;fico adaptable y m&#225;s intuitivo</strong>.<br/><br/>
<hr/>
<br/><br/>
<strong>Y un largo etc&#233;tera.</strong> Existen muchas otras peque&#241;as mejoras en el entorno, muchas que pasar&#225;n desapercibidas, pero que estan ah&#237; haci&#233;ndolo m&#225;s potente y f&#225;cil de utilizar. A continuaci&#243;n se detallan algunas que pueden ser m&#225;s relevantes.<br/><br/>
- Se ha <strong>optimizado el proceso de entrada y salida</strong> del entorno, as&#237; como la ejecuci&#243;n de los programas desde el m&#237;smo, ahora las cargas son m&#225;s r&#225;pidas y los tiempos de espera m&#225;s cortos.<br/><br/>
- El editor de programas muestra ahora los <strong>listados coloreados</strong>, resaltando las palabras clave del lenguaje, adem&#225;s se puede configurar mejor definiendo, por ejemplo, el tama&#241;o de las tabulaciones.<br/><br/>
- Ahora, al entrar en el entorno, se podr&#225; seleccionar si desea <strong>continuar con la sesi&#243;n anterior</strong> o <strong>comenzar una nueva</strong>.<br/><br/>
- Es posible seleccionar <strong>m&#225;s modos de visualizaci&#243;n</strong> para el entorno, dependiendo de los modos soportados por su tarjeta de v&#237;deo y el adaptador VESA instalado.<br/><br/>
- Un <strong>editor de gamas de colores</strong> facilita la generaci&#243;n de explosiones (que ahora puede ser abortada) y la preparaci&#243;n del tapiz de fondo (ahora se muestra una previsualizaci&#243;n del mismo).<br/><br/>
- Se puede configurar la <strong>velocidad del puntero del rat&#243;n</strong> con una peque&#241;a barra presente en la ventana de configuraci&#243;n del men&#250; de sistema.<br/><br/>
- En las ventanas de las fuentes <strong>aparece una muestra de letras</strong>, adem&#225;s de indicarse que conjuntos de caracteres tienen definidos.<br/><br/>
- Es posible generar fuentes de <strong>letras con antidentado</strong>, simplemente creando las mismas con un reborde de 1 punto del color de fondo.<br/><br/>
<hr/>
<strong>Ver tambi&#233;n:</strong> <a href="#2001">Novedades del lenguaje de programaci&#243;n</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2003">Resoluci&#243;n de problemas de configuraci&#243;n</h2><br/><br/>
<strong>Soluci&#243;n gen&#233;rica a los problemas de audio.</strong><br/><br/>
Si el sistema de audio de no pudo ser inicializado, es debido a un conflicto con su tarjeta de sonido. Este problema suele producirse por uno de estos motivos:<br/><br/>
- Que su tarjeta est&#233; siendo utilizada por <strong>otro programa</strong> simult&#225;neamente. No se podr&#225; inicializar el dispositivo si existe alg&#250;n otro programa leyendo o escribiendo datos en la tarjeta (como un reproductor de MP3 o un capturador de sonido).<br/><br/>
- Puede haberse producido un problema con la <strong>autodetecci&#243;n</strong> de los par&#225;metros de su tarjeta. Debe ejecutar el programa de configuraci&#243;n de sonido o bien definir estos valores en la variable BLASTER o ULTRASND del entorno de su sistema (puede encontrar m&#225;s informaci&#243;n en el manual de usuario de DIV Games Studio 2).<br/><br/>
- Debido a una <strong>incompatibilidad</strong> de su tarjeta. Si esta no es una tarjeta de las marcas GRAVIS (tm) o SOUND BLASTER (tm), puede que sea incompatible con DIV Games Studio. La mayor&#237;a de tarjetas cl&#243;nicas suelen ser compatibles con las tarjetas SOUND BLASTER, pero pueden no ser compatibles al 100% y presentar alg&#250;n problema.<br/><br/>
Si no reconoce en ninguno de estos tres casos su problema particular debe, en primer lugar, ejecutar el programa de configuraci&#243;n del sonido. Esto puede hacerlo desde DIV pulsando <strong>F4</strong>, cargando el programa <strong>SETUP.PRG</strong> del directorio <strong>SETUP</strong>, y ejecut&#225;ndolo con <strong>F10</strong>.<br/><br/>
En este programa deber&#225; introducir los par&#225;metros de su tarjeta de sonido. Para obtener estos par&#225;metros a trav&#233;s de Windows es probable que deba consultar el manual del mismo, aunque normalmente podr&#225; acceder a ellos de la siguiente forma: pulsando con el bot&#243;n derecho en &quot;Mi Pc&quot;, activando Propiedades \ Administrador de dispositivos \ Dispositivos de sonido, video y juegos, seleccionando su tarjeta de de Audio (normalmente una compatible con &quot;Sound Blaster&quot; o &quot;SB&quot;) y pulsando en Propiedades. Entonces aparecer&#225; el di&#225;logo con las caracteristicas de su tarjeta de sonido donde, en el apartado Recursos podr&#225; encontrar:<br/><br/>
<strong>1.</strong> El n&#250;mero de IRQ de su tarjeta como &quot;petici&#243;n de interrupci&#243;n&quot;.<br/><br/>
<strong>2.</strong> El n&#250;mero de DMA y el de DMA2 (tambi&#233;n denominado como HDMA o DMA16) como los dos &quot;accesos directos a memoria&quot;.<br/><br/>
<strong>3.</strong> El n&#250;mero de Puerto como el valor inicial del primer &quot;intervalo de entrada/salida&quot;.<br/><br/>
Tambi&#233;n puede probar a configurar el sistema de sonido indicando en el programa de configuraci&#243;n una tarjeta menor (anterior a la suya). Por ejemplo, si vd. tuviera una tarjeta compatible con una <strong>Sound Blaster AWE 64</strong> o <strong>128</strong> y no pudiera inicializar el sistema de sonido; pruebe a configurar el sistema como si tuviera una <strong>Sound Blaster 16</strong>, o una <strong>Sound Blaster Pro</strong>.<br/><br/>
Como &#250;ltimo recurso, si no fuese posible configurar el sonido en su sistema, deber&#225; desactivarlo. Para ello deber&#225; ejecutar igualmente el programa de configuraci&#243;n y seleccionar <strong>&lt;Sin Sonido&gt;</strong> en el campo que define el tipo de tarjeta. Entonces pulse el bot&#243;n <strong>&lt;Guardar&gt;</strong> para establecer esta configuraci&#243;n y desactivar el sonido en DIV Games Studio 2.<br/><br/>
Si a&#250;n as&#237; no consigue que se escuchen en su ordenador los efectos de sonido del programa, probablemente se deba a que no dispone de una tarjeta de sonido 100% compatible con la familia Sound Blaster o Gravis Ultrasound. Consulte, para ello, al proveedor de su equipo.<br/><br/>
<strong>Nota:</strong> La reproducci&#243;n de CD-Audio es independiente al sistema de sonido digital cuya configuraci&#243;n se ha descrito aqu&#237;; por ello podr&#225; seguir reproduciendo m&#250;sica de CD aunque el sistema de sonido no se encuentre debidamente inicializado.<br/><br/>
<hr/>
<br/><br/>
<strong>Problemas de v&#237;deo.</strong><br/><br/>
Si en alg&#250;n momento se entra en DIV en una resoluci&#243;n no visible, lo primero que debe hacerse es salir del entorno pulsando la combinaci&#243;n <strong>ESC+Control</strong> (o <strong>ALT+X</strong> y <strong>Enter</strong> a continuaci&#243;n) y, despu&#233;s, volver a entrar en el modo a prueba de fallos. Para ello se debe, desde la l&#237;nea de comandos de <strong>MSDOS</strong> y en el directorio (carpeta) en la que se haya instalado el programa, ejecutar el siguiente comando:<br/><br/>
<strong>  D /SAFE</strong><br/>
<br/><br/>
De esta forma se entrar&#225; en el entorno en baja resoluci&#243;n (en 320x200, el modo m&#225;s compatible de todos), a partir de este modo podr&#225;  intentar poner otros que sean compatibles tanto con su tarjeta como con su monitor.<br/><br/>
En aquellos equipos en los que el sistema de v&#237;deo no sea compatible con el est&#225;ndar VESA debe utilizarse un driver vesa. Para esto, debe contactar con el proveedor o servicio t&#233;cnico de su equipo hardware (un driver es un peque&#241;o programa que debe instalarse en el ordenador para dar soporte a algunos dispositivos como, en este caso, su tarjeta de v&#237;deo).<br/><br/>
<hr/>
<br/><br/>
<strong>Problemas con el rat&#243;n.</strong><br/><br/>
Si el rat&#243;n se desplaza a saltos por la pantalla, en lugar de punto a punto, es debido a que est&#225; utilizando un dispositivo de rat&#243;n obsoleto o incorrecto (un driver de rat&#243;n no actualizado). Puede solucionar este problema de una de estas formas:<br/><br/>
<strong>1.</strong> Contacte con el proveedor de su equipo para conseguir un dispositivo de rat&#243;n actualizado.<br/><br/>
<strong>2.</strong> Cambie la resoluci&#243;n del programa (con la opci&#243;n <strong>Sistema\Modo de v&#237;deo</strong>) por otra en la que no se produzca este problema.<br/><br/>
<strong>3.</strong> (MS-DOS, s&#243;lo para usuarios avanzados). Comente la l&#237;nea de su fichero autoexec.bat en la que carga el dispositivo de rat&#243;n. Puede hacer &#233;sto desde el propio DIV, cargue con F4 este fichero (situado en el directorio raiz de su disco duro de arranque) y a&#241;ada la palabra REM al inicio la l&#237;nea que carga el dispositivo de rat&#243;n (una l&#237;nea que normalmente acaba con ...mouse.com). Entonces pulse F2 para grabar el fichero nuevamente, ci&#233;rrelo (pulsando sobre el icono superior izquierdo de la ventana de texto), salga de DIV (ALT+X) y reinicie su equipo. Si despu&#233;s tuviese problemas con alg&#250;n otro programa que requiriera ese dispositivo, vuelva a editar el mismo fichero y quite la palabra REM que a&#241;adi&#243; en el mismo.<br/><br/>
<hr/>
<br/><br/>
<strong>Soluci&#243;n a posibles problemas en la instalaci&#243;n.</strong><br/><br/>
En caso de encontrar alg&#250;n problema, revise los requerimientos m&#237;nimos del programa indicados en el programa. Si tiene alguna duda sobre alguno de los elementos consulte al servicio t&#233;cnico de su ordenador o al proveedor de su equipo.<br/><br/>
Lo m&#225;s probable es que se presente alg&#250;n problema de lectura del CD- ROM con su unidad lectora; para ello, limpie la superficie del CD de DIV Games Studio cuidadosamente con un pa&#241;o limpio y seco, y vuelva a intentar la instalaci&#243;n del programa.<br/><br/>
<strong>Instalaci&#243;n manual</strong><br/><br/>
Si no ha podido instalar correctamente el programa y dispone de mucho espacio libre en el disco duro de su ordenador (suficiente para realizar una instalaci&#243;n m&#225;xima del mismo), entonces puede probar a realizar una instalaci&#243;n manual del programa, para ello siga los siguientes pasos:<br/><br/>
<strong>Usuarios de MS-DOS</strong> - Suponiendo que su unidad de CD-ROM sea la D:, sit&#250;ese en la unidad de CD-ROM con el siguiente comando:<br/><br/>
<strong>  D:</strong><br/><br/>
Y pulse Enter. Despu&#233;s introduzca los siguientes comandos (suponiendo que su unidad de disco duro es la C):<br/><br/>
<strong>  XCOPY DATA\*.* C:\DIV\*.* /S</strong><br/>
<strong>  C:</strong><br/>
<strong>  CD \DIV</strong><br/>
<strong>  DEL INSTALL*.*</strong><br/>
<br/><br/>
Pulsando Enter tras cada uno de estos comandos. Si tiene suficiente espacio el programa se instalar&#225; sin ning&#250;n problema, introduzca el siguiente comando para ejecutarlo posteriormente:<br/><br/>
<strong>  D /SAFE</strong><br/>
<br/><br/>
Para las proximas ejecuciones del programa, siga las instrucciones convencionales.<br/><br/>
<strong>Usuarios de Windows 95/98</strong> - Abra una sesi&#243;n de MS-DOS (pulsando dos veces sobre su icono, o bien desde el men&#250; inicio \ programas \ ms-dos) y siga las instrucciones para usuarios de MS- DOS. Para las siguientes ejecuciones del programa podr&#225; utilizar las instrucciones de su sistema operativo, teniendo en cuenta que el programa se habr&#225; instalado en la carpeta DIV de su disco duro.<br/><br/>
<hr/>
<br/><br/>
Si no consigue que el programa funcione correctamente con ninguno de estos consejos, entonces contacte con el servicio t&#233;cnico de Hammer, cuyo tel&#233;fono es (91) 304 06 22, y su horario de atenci&#243;n los Martes y Jueves de 16:00  a 18:00.<br/><br/>
Se recuerda que, debido a que DIV Games Studio es un producto de venta masiva y con un soporte t&#233;cnico limitado, debe procurar seguir cuidadosamente las instrucciones antes de contactar con este servicio.<br/><br/>
<strong>Importante:</strong> No se podr&#225; realizar en dicho servicio t&#233;cnico ninguna consulta acerca del lenguaje de programaci&#243;n, ya que no se ofrece m&#225;s soporte del mismo que este <strong>hipertexto de ayuda</strong> y el <strong>manual de usuario</strong> del programa. Con ellos puede solucionar cualquier duda que se le plantee.<br/><br/>
<hr/>
<br/><br/>
<h2 id="2004">&#191;Que es DIV Games Studio?</h2><br/><br/>
Se podr&#237;a decir que es un entorno gr&#225;fico que integra un nuevo lenguaje de programaci&#243;n para videojuegos junto a otras utilidades como un programa de dibujo, herramientas para crear fuentes de letras, paletas, etc.<br/><br/>
El lenguaje de programaci&#243;n ha sido dise&#241;ado en exclusiva para la creaci&#243;n de juegos y, como podr&#225; observar, permite obtener muy buenos resultados con programas muy cortos y sencillos.<br/><br/>
No es necesario que usted sepa programar para poder utilizarlo, DIV se ha dise&#241;ado para que se pueda aprender a programar con &#233;l. Es simplemente cuesti&#243;n de perderle el miedo a la palabra &quot;programar&quot; ...<br/><br/>
<hr/>
Ver: <a href="#2005">Trabajando con las ventanas</a> - <a href="#2000">Introducci&#243;n a 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2005">Trabajando con las ventanas</h2><br/><br/>
Las ventanas, pueden desplazarse hacia cualquier posici&#243;n de pantalla si se pulsa sobre la barra de t&#237;tulo con el rat&#243;n y se arrastra hasta la nueva posici&#243;n.<br/><br/>
<strong>Barra de t&#237;tulo.</strong> - Es la zona superior de las ventanas, donde se muestra su nombre en color blanco sobre fondo azul. Cuando el nombre de la ventana aparece en colores grises, es porque la ventana no est&#225; seleccionada (debido a que habr&#225; alguna de su misma categor&#237;a que lo est&#233;), para seleccionarla bastar&#225; con pulsar sobre ella.<br/><br/>
<strong>Arrastrar.</strong> - Este t&#233;rmino se aplica dentro del entorno gr&#225;fico a la acci&#243;n de pulsar con el rat&#243;n sobre un objeto, desplazarlo a una nueva posici&#243;n, y finalmente soltar el bot&#243;n del rat&#243;n.<br/><br/>
Para pedir al sistema que coloque una ventana autom&#225;ticamente, se debe realizar una doble pulsaci&#243;n con el rat&#243;n sobre la barra de t&#237;tulo de la ventana. Si el sistema encuentra una posici&#243;n mejor para la ventana, la desplazar&#225; hasta ella.<br/><br/>
Las ventanas pueden estar en <strong>diferentes modos</strong>, y en funci&#243;n del mismo su operatividad sera distinta. A continuaci&#243;n se describen estos modos:<br/><br/>
<strong>1. Ventanas activas:</strong> Son las que tienen, normalmente, si no se cambia la configuraci&#243;n de colores, la barra de t&#237;tulo iluminada, en letras blancas sobre fondo azul y est&#225;n sobre las dem&#225;s en el escritorio.<br/><br/>
<strong>2. Ventanas inactivas:</strong> Este tipo de ventanas tienen la barra de t&#237;tulo oscurecida, en letras negras sobre fondo gris oscuro. Para activar una de estas ventanas bastar&#225; con pulsar sobre ellas.<br/><br/>
<strong>3. Ventanas en segundo plano:</strong> Son ventanas que est&#225;n oscurecidas; esto es debido a que est&#225;n, al menos parcialmente, tapadas por otras ventanas. Con estas ventanas no se podr&#225; interaccionar hasta que no se pasen a primer plano pulsando con el rat&#243;n sobre ellas.<br/><br/>
<strong>4. Iconos:</strong> Los iconos son las ventanas que se ha minimizado, es decir, que se han reducido temporalmente. Los iconos no muestran ning&#250;n dibujo, &#250;nicamente un bot&#243;n con un signo &quot;+&quot; seguido del t&#237;tulo de la ventana.<br/><br/>
<strong>Nota:</strong> Para arrastrar los gr&#225;ficos (a un fichero, al escritorio, etc.) no se debe pulsar sobre la barra de t&#237;tulo de la ventana (con lo que se arrastrar&#237;a la misma), si no sobre el contenido de la ventana. Es decir, que hay que pulsar m&#225;s o menos en el centro de la ventana y, sin soltar el bot&#243;n del rat&#243;n, desplazarlo a la nueva posici&#243;n.<br/><br/>
<hr/>
Ver: <a href="#2006">Tipos de ventanas</a> - <a href="#2000">Introducci&#243;n a DIV 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2006">Tipos de ventanas</h2><br/><br/>
Las ventanas se pueden clasificar seg&#250;n su funci&#243;n, realiz&#225;ndose las siguientes agrupaciones:<br/><br/>
<strong>1. Di&#225;logos interactivos:</strong> &#201;stos son los cuadros que se utilizan para solicitar informaci&#243;n al usuario; existe una gran variedad de ellos, por lo que ya se ir&#225;n viendo en las respectivas opciones<br/><br/>
<strong>2. Cuadros de error:</strong> Son di&#225;logos en los que la barra de t&#237;tulo aparece en blanco sobre rojo e informan de alg&#250;n problema que se haya producido.<br/><br/>
<strong>3. Men&#250;s de opciones:</strong> Los men&#250;s son una lista de opciones que llaman a otros men&#250;s, ventanas o di&#225;logos al pulsar sobre ellas. Todos los men&#250;s parten del men&#250; principal. Algunos men&#250;s tienen ciertas opciones desactivadas (se muestra un puntero con un s&#237;mbolo prohibido al situar el rat&#243;n sobre ellas); esto es debido a que dichas opciones interact&#250;an con un tipo de ventanas en concreto, y no hay ninguna ventana de dicho tipo activa (se debe antes crear o cargar una).<br/><br/>
<strong>4. Programas:</strong> En estas ventanas es donde se crean los programas y son ventanas de edici&#243;n de texto. Para editar un programa debe estar su ventana activada (s&#243;lo uno de los programas cargados puede estar activado). La edici&#243;n de texto es muy similar a otros editores de texto (soporta el est&#225;ndar EDIT entre ellos).<br/><br/>
Para pedir ayuda en un programa sobre una palabra del lenguaje hay que situar el cursor parpadeante de edici&#243;n (no el puntero del rat&#243;n) sobre la misma y, despu&#233;s, pulsar la tecla <strong>F1</strong>. Estas ventanas pueden cambiarse de tama&#241;o pulsando en el bot&#243;n inferior derecho de las mismas y arrastrando con el rat&#243;n o pulsando <strong>Control</strong>+<strong>Z</strong>.<br/><br/>
<strong>5. Mapas o gr&#225;ficos:</strong> Estas ventanas son las que contienen un mapa (bitmap) o gr&#225;fico (un dibujo de los empleados en un juego) y se controlan por medio del men&#250; de mapas. Pueden cargarse de un archivo MAP (formato propio), importarse de un archivo PCX, BMP o JPG. Para editar los gr&#225;ficos se debe realizar una doble pulsaci&#243;n del bot&#243;n del rat&#243;n en el centro de estas ventanas entrando, de este modo, en el editor gr&#225;fico (descrito en el <strong>manual de usuario</strong>). Estos gr&#225;ficos pueden arrastrarse hasta el tapiz (para hacer una copia), hasta otro gr&#225;fico (para insertarlos), hasta un fichero de gr&#225;ficos (para incluirlos) o hasta la papelera (para borrarlos), para ello se debe arrastrar desde el centro de las ventanas, en lugar de la barra de t&#237;tulo.<br/><br/>
<strong>6. Mapas 3D:</strong> Estos son los mapas vectoriales creados en el editor de mapas 3D, en su ventana se muestran como un conjunto de pol&#237;gonos cerrados representando el alzado de un plano. Su creaci&#243;n no es trivial, y se describe en el <strong>manual de usuario</strong>. Estos mapas se guardan en disco en los archivos con extensi&#243;n WLD.<br/><br/>
<strong>7. FPG o Ficheros para gr&#225;ficos:</strong> Estas ventanas muestran el contenido de un fichero del disco. Son librer&#237;as o colecciones de gr&#225;ficos utilizadas en los juegos; su utilidad reside en no tener que cargar en un juego una gran cantidad de mapas por separado. Tienen dos modos b&#225;sicos de funcionamiento, activados mediante una casilla denominada &quot;Info&quot; en su parte inferior. Cuando esta casilla no est&#225; activada (por defecto) se pueden marcar y desmarcar una serie de gr&#225;ficos sobre la que pretende realizar una operaci&#243;n, o bien arrastrar gr&#225;ficos hacia fuera del fichero (hacia el tapiz, otros ficheros, mapas o la papelera). Cuando dicha casilla est&#225; activada se pueden editar los c&#243;digos de los gr&#225;ficos y sus descripciones. Estos FPG se controlan siempre mediante el men&#250; de ficheros.<br/><br/>
Las ventanas de los FPG son siempre un reflejo directo del &quot;fichero para gr&#225;ficos&quot; contenido en el disco duro del ordenador, por ello pueden cerrarse en cualquier momento, sin tener que guardarlas previamente. No se perder&#225; nunca su contenido. La opci&#243;n <strong>Ficheros \ Guardar</strong> como permite hacer una copia del FPG con otro nombre distinto (como copia temporal o de seguridad).<br/><br/>
<strong>8. Fuentes de letras:</strong> Las fuentes o tipos de letra son unas ventanas peque&#241;as que representan una tipograf&#237;a concreta. Se debe pulsar sobre ellas para ver una muestra del fuente a tama&#241;o real. Se corresponden con archivos FNT (formato propio) y son controladas por el men&#250; de fuentes, desde el cual se puede acceder al generador de fuentes que es la herramienta utilizada para crear nuevas fuentes de letras. Las fuentes de letras se utilizan dentro del programa de dibujo y en los programas para escribir textos.<br/><br/>
<strong>9. Efectos de sonido:</strong> Representan en pantalla un archivo PCM (pulse code modulation) o WAV con un efecto de sonido. Se controlan mediante el men&#250; de sonidos, pudiendo crearse efectos nuevos (con la grabadora de sonidos) o editarse. Se puede encontrar una librer&#237;a de efectos de sonido ya preparados para su utilizaci&#243;n en los juegos. Para escuchar un efecto de sonido se debe tener una tarjeta de sonido compatible con las familias Sound Blaster o Gravis Ultrasound correctamente configurada y pulsar sobre una de estas ventanas.<br/><br/>
<strong>10. M&#243;dulos musicales:</strong> Se pueden cargar canciones en los formatos MOD, S3M y XM. Estas se representan en una peque&#241;a ventana que permite activar o parar su reproducci&#243;n. No siendo posible componer estos m&#243;dulos desde el propio entorno.<br/><br/>
<strong>11. Ventana de ayuda:</strong> Se controla principalmente con el rat&#243;n, pudiendo utilizar tambi&#233;n los cursores, las teclas de avance y retroceso p&#225;gina y la tecla Borrar para volver a la p&#225;gina anterior (es la tecla que est&#225; sobre Enter). En las ventanas de ayuda se muestran en blanco los textos que hacen referencia a otras p&#225;ginas de ayuda. Se debe pulsar sobre estas referencias para acceder a dichas p&#225;ginas. En las ventanas de ayuda tambi&#233;n se muestran programas de ejemplo que se pueden extraer pulsando sobre su t&#237;tulo, ejecutar con la tecla F10 y abortar pulsando ALT+X.<br/><br/>
<strong>12. Calculadoras:</strong> Las ventanas de las calculadoras funcionan como evaluadores de expresiones matem&#225;ticas, al estilo de las expresiones presentes en los programas. Su funcionamiento es muy simple, ya que basta con introducir una expresi&#243;n y pulsar Enter para ver el resultado. Pudi&#233;ndose utilizar par&#233;ntesis para indicar subexpresiones.<br/><br/>
<strong>Nota:</strong> La ventana de la papelera se debe activar primero a partir del men&#250; de sistema, con la opci&#243;n correspondiente (<strong>Sistema \ Papelera</strong>) del mismo.<br/><br/>
<hr/>
Ver: <a href="#2010">Fijando un modo de video</a> - <a href="#2000">Introducci&#243;n a DIV 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2007">Versi&#243;n de demostraci&#243;n</h2><br/><br/>
Esta es una copia de DIV Games Studio 2 exclusiva para su evaluaci&#243;n, y est&#225; limitada a 31 ejecuciones del programa.<br/><br/>
Esta versi&#243;n de demostraci&#243;n es completamente funcional, y se ha creado con el prop&#243;sito de que vd. pueda evaluar las posibilidades del programa y la compatibilidad del mismo con su sistema, antes de adquirir una copia registrada del mismo.<br/><br/>
Tan s&#243;lo existen dos funciones restringidas en esta versi&#243;n:<br/><br/>
- El <strong>tama&#241;o de los programas</strong> que pueden ser compilados est&#225; limitado por un n&#250;mero de objetos m&#225;ximo.<br/><br/>
- Los programas instalables (al crear un EXE independiente de DIV con la opci&#243;n <strong>Programas</strong> \ <strong>Crear instalacion</strong>) quedar&#225;n marcados por un mensaje informativo.<br/><br/>
Estas restricciones no existen en la versi&#243;n comercial del programa, pero adem&#225;s se recuerda que esta viene acompa&#241;ada de un <strong>Manual de Usuario</strong> imprescindible para acceder a todas las funciones del programa y para el aprendizaje del lenguaje de programaci&#243;n de DIV 2.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La informaci&#243;n contenida en el Manual de Usuario de DIV Games Studio 2 (sobre las novedades del entorno, las opciones del programa, el tutorial del nuevo lenguaje, ...) no se podr&#225; encontrar en esta ayuda electr&#243;nica.<br/><br/>
<hr/>
<br/><br/>
<h2 id="2008">Conflicto con el dispositivo de sonido</h2><br/><br/>
El sistema de audio de DIV Games Studio no pudo ser inicializado debido a un conflicto con su tarjeta de sonido. Este problema suele producirse por uno de estos motivos:<br/><br/>
- Que su tarjeta est&#233; siendo utilizada por <strong>otro programa</strong> simult&#225;neamente. No se podr&#225; inicializar el dispositivo si existe alg&#250;n otro programa leyendo o escribiendo datos en la tarjeta (como un reproductor de MP3 o un capturador de sonido).<br/><br/>
- Puede haberse producido un problema con la <strong>autodetecci&#243;n</strong> de los par&#225;metros de su tarjeta. Debe ejecutar el programa de configuraci&#243;n de sonido o bien definir estos valores en la variable BLASTER o ULTRASND del entorno de su sistema (puede encontrar m&#225;s informaci&#243;n en el manual de usuario de DIV Games Studio 2).<br/><br/>
- Debido a una <strong>incompatibilidad</strong> de su tarjeta. Si esta no es una tarjeta de las marcas GRAVIS (tm) o SOUND BLASTER (tm), puede que sea incompatible con DIV Games Studio. La mayor&#237;a de tarjetas cl&#243;nicas suelen ser compatibles con las tarjetas SOUND BLASTER, pero pueden no ser compatibles al 100% y presentar alg&#250;n problema.<br/><br/>
<hr/>
<br/><br/>
<strong>Soluci&#243;n gen&#233;rica a los problemas de audio.</strong><br/><br/>
Si no reconoce en ninguno de estos tres casos su problema particular debe, en primer lugar, ejecutar el programa de configuraci&#243;n del sonido. Esto puede hacerlo desde DIV pulsando <strong>F4</strong>, cargando el programa <strong>SETUP.PRG</strong> del directorio <strong>SETUP</strong>, y ejecut&#225;ndolo con <strong>F10</strong>.<br/><br/>
En el primer cap&#237;tulo del <strong>manual de usuario</strong> encontrar&#225; informaci&#243;n sobre como obtener los par&#225;metros de su tarjeta de sonido.<br/><br/>
Tambi&#233;n puede probar a configurar el sistema de sonido indicando en el programa de configuraci&#243;n una tarjeta menor (anterior a la suya). Por ejemplo, si vd. tuviera una tarjeta compatible con una <strong>Sound Blaster AWE 64</strong> o <strong>128</strong> y no pudiera inicializar el sistema de sonido; pruebe a configurar el sistema como si tuviera una <strong>Sound Blaster 16</strong>, o una <strong>Sound Blaster Pro</strong>.<br/><br/>
Como &#250;ltimo recurso, si no fuese posible configurar el sonido en su sistema, deber&#225; desactivarlo. Para ello deber&#225; ejecutar igualmente el programa de configuraci&#243;n y seleccionar <strong>&lt;Sin Sonido&gt;</strong> en el campo que define el tipo de tarjeta. Entonces pulse el bot&#243;n <strong>&lt;Guardar&gt;</strong> para establecer esta configuraci&#243;n y desactivar el sonido en DIV Games Studio 2.<br/><br/>
<hr/>
<br/><br/>
<strong>Nota:</strong> La reproducci&#243;n de CD-Audio es independiente al sistema de sonido digital cuya configuraci&#243;n se ha descrito aqu&#237;; por ello podr&#225; seguir reproduciendo m&#250;sica de CD aunque el sistema de sonido no se encuentre debidamente inicializado.<br/><br/>
<hr/>
<br/><br/>
<h2 id="2009">El dispositivo de sonido no est&#225; inicializado</h2><br/><br/>
No se podr&#225;n reproducir sonidos digitales dentro de DIV Games Studio 2 si el dispositivo de sonido est&#225; desactivado.<br/><br/>
Probablemente se haya seleccionado en el programa de configuraci&#243;n <strong>&lt;Sin Sonido&gt;</strong>, en lugar de indicar el tipo de tarjeta de audio instalada en su equipo (o una compatible con la misma).<br/><br/>
<hr/>
Ver: <a href="#2008">Conflictos con el dispositivo de sonido</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2010">Fijando un modo de video</h2><br/><br/>
La opci&#243;n <strong>Sistema \ Modo de v&#237;deo</strong> da acceso a un cuadro de di&#225;logo que permite modificar la resoluci&#243;n utilizada por el entorno gr&#225;fico de DIV Games Studio 2.<br/><br/>
Las resoluciones de v&#237;deo se indican como el n&#250;mero de puntos en horizontal y vertical existentes en la pantalla en dicho modo y var&#237;an entre 320x200 (baja resoluci&#243;n) y la resoluci&#243;n m&#225;xima que permita su tarjeta de v&#237;deo. Para seleccionar una nueva resoluci&#243;n se debe pulsar sobre la lista que aparece en el cuadro y despu&#233;s en el bot&#243;n de <strong>Aceptar</strong>.<br/><br/>
<strong>Nota:</strong> Algunos de estos modos de v&#237;deo pueden visualizarse incorrectamente (por ejemplo, una resoluci&#243;n que est&#233; permitida por su tarjeta de v&#237;deo pero no por su monitor); en estos casos se deber&#225; esperar unos <strong>15 segundos</strong> para que el entorno recupere la resoluci&#243;n anterior. No debe pulsar ninguna tecla, ni realizar ninguna acci&#243;n, simplemente espere.<br/><br/>
<strong>Selecci&#243;n de la fuente del sistema.</strong><br/><br/>
Dos casillas permiten seleccionar la fuente utilizada por el sistema, existiendo dos posibilidades que no s&#243;lo difieren en el tama&#241;o de las letras sino, en general, en el tama&#241;o de todas las ventanas del entorno.<br/><br/>
<strong>1. Fuente peque&#241;a (y ventanas peque&#241;as).</strong> En este modo todas las ventanas, men&#250;s y cuadros se ver&#225;n en un tama&#241;o menor, siendo el apropiado para modos de baja resoluci&#243;n o equipos con un monitor lo suficientemente grande.<br/><br/>
<strong>2. Fuente grande (y ventanas grandes).</strong> Este modo podr&#225; ser activado &#250;nicamente en resoluciones a partir de 640x480 y es el apropiado para estas resoluciones en monitores peque&#241;os.<br/><br/>
<strong>Nota:</strong> La fuente de letras utilizada en los programas y en la ventana de ayuda es independiente de la seleccionada para el sistema, y se define en la ventana de configuraci&#243;n, accesible tambi&#233;n desde este mismo men&#250; de sistema.<br/><br/>
<hr/>
Ver: <a href="#2011">La ventana de configuraci&#243;n</a> - <a href="#2000">Introducci&#243;n a DIV 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2011">La ventana de configuraci&#243;n</h2><br/><br/>
Mediante la opci&#243;n <strong>Sistema\Configuraci&#243;n</strong> se acceder&#225; a un cuadro de di&#225;logo dividido en varias secciones, que se muestran a continuaci&#243;n.<br/><br/>
<strong>Colores de ventanas</strong><br/><br/>
Esta primera secci&#243;n establece los colores utilizados por el entorno; se pueden indicar los colores para el fondo de las ventanas, la tinta para las letras y el color de la barra de t&#237;tulo. Para cambiar estos colores se debe pulsar sobre las cajas. El sistema no s&#243;lo utiliza estos tres colores sino que, a partir de ellos, genera una gama de colores intermedios para los textos, cursores, botones, etc.<br/><br/>
<strong>Editor de programas</strong><br/><br/>
Establece la apariencia de las ventanas de edici&#243;n de programas. Se pueden seleccionar colores variados para los diferentes objetos (palabras o s&#237;mbolos) presentes en los programas.<br/><br/>
<strong>1.</strong> Fondo de la ventana de edici&#243;n.<br/>
<strong>2.</strong> Tinta general para las letras.<br/>
<strong>3.</strong> Cursor de edici&#243;n.<br/>
<strong>4.</strong> Comentarios explicativos de los programas.<br/>
<strong>5.</strong> S&#237;mbolos y operadores de expresiones.<br/>
<strong>6.</strong> Palabras reservadas del lenguaje.<br/>
<strong>7.</strong> N&#250;meros dentro del programa.<br/>
<strong>8.</strong> Literales, o textos entre comillas.<br/>
<br/><br/>
Los bloques de texto marcados dentro del editor se ver&#225;n con los colores de tinta y fondo intercambiados.<br/><br/>
Una caja de texto permite definir el tama&#241;o (en n&#250;mero de espacios) del tabulador en el editor de programas, como un n&#250;mero entre 1 y 16. Afectando a este al indentado de las sentencias en el lenguaje. Por defecto se tabula cada 4 columnas.<br/><br/>
Tambi&#233;n es posible seleccionar aqu&#237; el tama&#241;o de las letras de los programas y la ayuda, desde 6x8 hasta 9x16 puntos. Todas las fuentes de letras para edici&#243;n son de espaciado fijo.<br/><br/>
<strong>Programa de dibujo</strong><br/><br/>
Se define la cantidad de memoria reservada para deshacer opciones en el editor gr&#225;fico, la velocidad del puntero de rat&#243;n y su representaci&#243;n.<br/><br/>
La cantidad de &quot;memoria de deshacer&quot; se especifica en Kbytes, por defecto es 1088Kb (algo m&#225;s de un mega), y no es necesario modificar este valor a no ser que no se pueda realizar una operaci&#243;n en el editor gr&#225;fico por falta de memoria de deshacer (en cuyo caso el programa advertir&#225; de ello). Cuanta m&#225;s memoria de deshacer se reserve, menos memoria quedar&#225; disponible en el sistema para el resto de acciones.<br/><br/>
La velocidad del puntero del rat&#243;n se define con una peque&#241;a barra horizontal (m&#225;s r&#225;pido a la izquierda y mas lento a la derecha), y afecta a todo el entorno de ventanas, no s&#243;lo al programa de dibujo.<br/><br/>
<strong>Opciones globales del entorno</strong><br/><br/>
<strong>1. Ventanas emergentes.</strong> Indica que todos los movimientos de ventanas deben ser visualizados, cuando se abren, se cierren, se minimicen, etc. Si se desactiva esta opci&#243;n, el entorno perder&#225; efectismo pero ganar&#225; velocidad de respuesta.<br/><br/>
<strong>2. Mover ventanas completas.</strong> Indica que al arrastrarse las ventanas a una nueva posici&#243;n se debe ver en todo momento el resultado final. Puede ser conveniente desactivar esta opci&#243;n en los equipos m&#225;s lentos.<br/><br/>
<strong>3. Guardar sesi&#243;n siempre.</strong> Indica que al salir de DIV Games Studio se debe guardar el estado del escritorio y todos sus objetos (programas, mapas, sonidos, etc.). Si se desactiva esta opci&#243;n la entrada y salida del entorno ser&#225; m&#225;s r&#225;pida, pero se puede correr el riesgo de perder trabajos que no hayan sido guardados.<br/><br/>
<strong>4. Colorear los listados.</strong> Indica que, cuando se est&#233; editando un archivo con extensi&#243;n PRG, se deben aplicar todos los colores anteriormente seleccionados para el editor. En caso contrario se aplicar&#225;n &#250;nicamente los colores de fondo, tinta y cursor. Al igual que cuando se edite un archivo que no sea un PRG.<br/><br/>
<strong>Nota:</strong> Si se cierra la ventana de configuraci&#243;n o se pulsa la tecla ESC se perder&#225;n todos los cambios realizados en la misma, restableci&#233;ndose los valores de la configuraci&#243;n anterior.<br/><br/>
<hr/>
Ver: <a href="#2012">Toma de contacto con el lenguaje</a> - <a href="#2000">Introducci&#243;n a DIV 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2012">Toma de contacto con el lenguaje</h2><br/><br/>
En esta secci&#243;n se explicar&#225; c&#243;mo ejecutar los juegos ejemplo de DIV Games Studio y unas instrucciones r&#225;pidas para que vd. pueda comenzar a investigar sobre ellos, adquiriendo de esta forma las primeras nociones de este lenguaje de programaci&#243;n.<br/><br/>
<strong>Instrucciones generales</strong><br/><br/>
Todos los juegos incluidos son simples ejemplos, cuya complejidad no pretende competir con los juegos comerciales que pueden ser creados con esta herramienta. Aunque se trate de juegos completos, la mayor&#237;a son muy sencillos o muy cortos.<br/><br/>
El motivo es que se ha pretendido mostrar las t&#233;cnicas que emplean y c&#243;mo se realizan los programas, ofreciendo con ellos un bot&#243;n de muestra, en lugar de enormes listados en los que el lector se pierda.<br/><br/>
<strong>Nota:</strong> Estos juegos no pueden nunca mostrar las posibilidades reales de este entorno de desarrollo, ya que pr&#225;cticamente ning&#250;n juego las utiliza. La gran mayor&#237;a de las nuevas y potentes capacidades de esta versi&#243;n de DIV Games Studio no han sido utilizadas en ning&#250;n ejemplo, d&#225;ndole a vd. la posibilidad de ser de los primeros que intenten, o quiz&#225; logren, exprimirlas al m&#225;ximo.<br/><br/>
Para ejecutar cualquiera de los ejemplos se debe, primero, cargar el programa con la opci&#243;n <strong>Programas\Abrir programa</strong>, con lo que aparecer&#225; una ventana con el listado del programa cargado.<br/><br/>
<strong>El sistema de ayuda</strong><br/><br/>
Una de las mejores opciones es investigar, examinando los programas e intentando realizar alg&#250;n cambio en ellos; al situarse sobre cualquier palabra reservada, constante, variable, funci&#243;n, etc., del lenguaje se puede pulsar la tecla F1 para ver una p&#225;gina de ayuda sobre dicho objeto.<br/><br/>
Si, al pulsar F1, no apareciera la ayuda sobre el objeto (sino que aparece el &#237;ndice general), es porque &#233;ste no es un nombre propio del lenguaje DIV, sino que se trata de alg&#250;n dato o proceso exclusivo del juego (los procesos son una especie de funciones que rigen el comportamiento de los gr&#225;ficos, o &#39;sprites&#39;, en los juegos).<br/><br/>
<strong>Nota:</strong> Se recomienda comenzar a examinar juegos sencillos, como los tutoriales o, sobre todo, los ejemplos incluidos en la ayuda electr&#243;nica; para acceder a ellos debe pulsar el bot&#243;n denominado Funciones de la ventana de ayuda y, desde esa p&#225;gina, ir accediendo a las diferentes explicaciones de las funciones del lenguaje de programaci&#243;n, de donde se pueden extraer peque&#241;os ejemplos pulsando sobre su cabecera o titular.<br/><br/>
Los textos que comienzan con el s&#237;mbolo // (doble barra) son comentarios explicativos, no forman parte del programa, sino que &#250;nicamente consisten en &quot;notas aclaratorias&quot; sobre el funcionamiento interno del programa. Estos comentarios suelen ser de gran ayuda para comprender el funcionamiento de los programas. Tambi&#233;n pueden aparecer comentarios entre los s&#237;mbolos /* y */ (a lo largo de varias l&#237;neas del programa).<br/><br/>
Para irse a uno de los procesos del programa (uno de los bloques que tienen los programas para controlar un gr&#225;fico o sprite del juego) se debe pulsar la tecla F5 y seleccionar el nombre del proceso en cuesti&#243;n con el rat&#243;n.<br/><br/>
<strong>Ejecuci&#243;n de los ejemplos</strong><br/><br/>
Para ejecutar uno de los programas cargados, se debe pulsar con el rat&#243;n sobre su ventana y despu&#233;s la tecla F10 (esta acci&#243;n tambi&#233;n se puede realizar con la opci&#243;n Programas \ Ejecutar).<br/><br/>
Las instrucciones de los juegos var&#237;an de unos a otros, pero la mayor&#237;a permiten salir pulsando la tecla ESC y se manejan mayoritariamente con las teclas de los cursores y la tecla Control (ver los <a href="#1292">comandos comunes en los juegos</a>).<br/><br/>
La tecla de Pausa se podr&#225; utilizar en todos los juegos para detener su ejecuci&#243;n moment&#225;neamente. Todos los programas pueden abortarse en cualquier punto, independientemente de su programaci&#243;n, si se pulsa la combinaci&#243;n de teclas ALT+X.<br/><br/>
<hr/>
Ver: <a href="#2013">Trazando los programas</a> - <a href="#2000">Introducci&#243;n a DIV 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2013">Trazando los programas</h2><br/><br/>
Las mentes m&#225;s inquietas pueden curiosear en los juegos pulsando la tecla F12 (desde el propio juego, estando &#233;ste en ejecuci&#243;n), que permite acceder al trazador de programas, que es una utilidad dise&#241;ada para ejecutar paso a paso los juegos. Pudiendo observar todos los procesos y modificar sus datos (si se da con el dato apropiado, se pueden cambiar todos los par&#225;metros del juego, el n&#250;mero de fase, las vidas, ...).<br/><br/>
En la parte superior de esta ventana aparece una lista con los procesos activos en cada momento (algo as&#237; como los mu&#241;ecos o gr&#225;ficos que est&#225; empleando el programa). Estos se pueden seleccionar con el rat&#243;n y, pulsando el bot&#243;n <strong>Ver datos</strong>, se ver&#225;n todas las variables, contadores, etc. que el proceso est&#225; utilizando.<br/><br/>
En la parte inferior de la pantalla aparece el listado del programa, que b&#225;sicamente son las &#243;rdenes que el ordenador debe ir cumpliendo para que el juego funcione. Este aparece dividido normalmente en peque&#241;os bloques que comienzan con palabra <strong>PROCESS</strong> (una de las palabras reservadas del lenguaje de programaci&#243;n). En cada uno de estos bloques vienen especificadas las ordenes para elemento concreto del juego (por ejemplo, para un disparo, un enemigo o una explosi&#243;n).<br/><br/>
<strong>Funcionamiento general de los programas</strong><br/><br/>
A grandes rasgos, los juegos siempre son una secuencia de im&#225;genes. Para componer cada imagen intervienen varios elementos (o procesos) en funci&#243;n del tipo de juego. Todos estos elementos deben realizar una serie de operaciones o c&#225;lculos (normalmente muy simples) para determinar cual debe ser su apariencia en la siguiente imagen (que dibujo o gr&#225;fico se debe mostrar, en que posici&#243;n, a que tama&#241;o, etc.)<br/><br/>
El ordenador va cumpliendo las &#243;rdenes especificadas para cada proceso hasta encontrarse con la orden <strong>FRAME</strong> (imagen o fotograma). Esta orden indica que un proceso ya est&#225; listo para mostrarse en la siguiente imagen, es decir, que ya ha definido todos los par&#225;metros que definir&#225;n su apariencia en la siguiente imagen.<br/><br/>
<strong>Nota:</strong> A las &#243;rdenes especificadas en un programa se les denomina sentencias. Cada una de estas sentencia indica una operaci&#243;n o c&#225;lculo que el ordenador debe realizar.<br/><br/>
De esta forma, el ordenador ir&#225; relizando todas estas operaciones y c&#225;lculos que le vayan indicando las ordenes de cada proceso, hasta que todos los procesos activos hayan dado la orden <strong>FRAME</strong>. En ese momento, el ordenador dejar&#225; de ejecutar &#243;rdenes y se dedicar&#225; en exclusiva a componer la siguiente imagen que debe aparecer en el monitor.<br/><br/>
Luego en los juegos van alternando siempre estas dos tareas, primero se ejecutan las &#243;rdenes, y despu&#233;s se compone y muestra la imagen.<br/><br/>
<strong>Controles b&#225;sicos del trazador</strong><br/><br/>
Esto puede ser visualizado desde el trazador de programas, por medio de varios botones que permiten que las acciones de un programa o juego se vayan realizando poco a poco, de forma visible. Los principales botones son los siguientes:<br/><br/>
<strong>1. Paso.</strong> Indica al ordenador que ejecute la siguiente orden del siguiente proceso. El siguiente proceso aparece resaltado en color blanco en la lista superior del trazador, y la siguiente orden a realizar (por este proceso) aparece en el listado del programa resaltada en el mismo color.<br/><br/>
<strong>2. Ejec.Proceso.</strong> Este bot&#243;n se utiliza para que el ordenador ejecute todas las instrucciones del siguiente proceso hasta llegar a una orden FRAME, es decir, que realice todas las operaciones necesarias para que el siguiente proceso pueda ser visualizado en la siguiente imagen.<br/><br/>
<strong>3. Sgte.Frame.</strong> Este bot&#243;n es el utilizado para avanzar el juego imagen a imagen. Cada vez que sea pulsado se ejecutar&#225;n todas las &#243;rdenes pendientes de todos los procesos activos, se compondr&#225; la nueva imagen, y finalmente se volcar&#225; a v&#237;deo (se denomina &quot;volcar a v&#237;deo&quot; a la acci&#243;n de transferir una imagen que se acaba de componer a la tarjeta de v&#237;deo, de forma que esta se visualice en el monitor del ordenador).<br/><br/>
Cuando se realiza un programa, todos los aspectos imaginables pueden ser controlados: el &#243;rden en el que se ejecutan las &#243;rdenes de los diferentes procesos, el &#243;rden en el que los gr&#225;ficos se superponen en pantalla, las reacciones varios procesos al superponerse (al &quot;tocarse&quot; uno con el otro), cuando deben emitirse los efectos de sonido, las reacciones de cada proceso al teclado, rat&#243;n, ...<br/><br/>
<hr/>
Ver: <a href="#2000">Introducci&#243;n a DIV 2</a> <hr/>
<br/><br/>
<h2 id="2014">Acerca de ...</h2><br/><br/>
Idea original y programa por: Daniel Navarro<br/><br/>
Programaci&#243;n auxiliar: Juanjo Garrido<br/><br/>
Programaci&#243;n modo 8 y red: Luis Fernando Fern&#225;ndez<br/><br/>
Apoyo en programaci&#243;n: Fernando P&#233;rez<br/><br/>
Ejemplos y pruebas: Antonio Marchal, Luis Sureda, Manuel Caba&#241;as, Daniel Mu&#241;oz<br/><br/>
Gr&#225;ficos: Santiago Garc&#237;a, Miguel Angel Carrillo, Carlos Caba&#241;as, Rafael Barraso, Julio C&#233;sar L&#243;pez, Jos&#233; Fern&#225;ndez, Eva Astorga, J.Ricardo Abell&#225;, Pablo de la Sierra<br/><br/>
Efectos de sonido: Carlos Illana<br/><br/>
Apoyo moral: C&#233;sar Valencia<br/><br/>
Producci&#243;n: Mario de Luis, Carlos Doral<br/><br/>
Beta-tester: Ferm&#237;n Vicente Rosas,Iv&#225;n Garc&#237;a Cortijo, Pedro Tomas Matilla, Roberto Selva Gomis, Daniel Bustos Fern&#225;ndes, Enrique Gonz&#225;lez Mart&#237;nez, Juan Alcaraz S&#225;nchez, Juan Gomar Vidal, Gin&#233;s Garc&#237;a Mateos, Ismael Fern&#225;ndez Bustos (Nota: Lamentamos no haber podido enviar una copia a todos los Betatester con los que se contact&#243;, por falta de tiempo.)<br/><br/>
Gracias a: Bel&#233;n P&#233;rez, Wonder, Pete, Rubo, DDI, Tizo, Sobakus, Juangake, Christian, Tom&#225;s Cuadra, Javier Carri&#243;n, David Pic&#243;n, Pedro P. Aull&#243;, JB, Zeen, Jens Grobecker, J.C. Ar&#233;valo, Carlos Doral, Rafa S. Gago, Antonio Ruiz y Gonzalo Mart&#237;n<br/><br/>
DOS/4GW (c) Rational Systems, Inc. 1990,94<br/><br/>
DIV Games Studio (c) 1998,99 Hammer Technologies.<br/><br/>
(c) 98,99 Hammer Technologies.<br/><br/>
DIV Games Studio - v2.01<br/><br/>
Daniel Navarro Medrano.<br/><br/>
<hr/>
Ver: <a href="#2000">Introducci&#243;n a DIV 2</a><br/><br/>
<hr/>
<br/><br/>
<h2 id="2047">Ultimo t&#233;rmino posible dentro de este hipertexto</h2>

</body></html>
